
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model MovieInteraction
 * 
 */
export type MovieInteraction = $Result.DefaultSelection<Prisma.$MovieInteractionPayload>
/**
 * Model WatchLog
 * 
 */
export type WatchLog = $Result.DefaultSelection<Prisma.$WatchLogPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ReviewComment
 * 
 */
export type ReviewComment = $Result.DefaultSelection<Prisma.$ReviewCommentPayload>
/**
 * Model ReviewFavorite
 * 
 */
export type ReviewFavorite = $Result.DefaultSelection<Prisma.$ReviewFavoritePayload>
/**
 * Model MovieList
 * 
 */
export type MovieList = $Result.DefaultSelection<Prisma.$MovieListPayload>
/**
 * Model MovieListItem
 * 
 */
export type MovieListItem = $Result.DefaultSelection<Prisma.$MovieListItemPayload>
/**
 * Model ImportRun
 * 
 */
export type ImportRun = $Result.DefaultSelection<Prisma.$ImportRunPayload>
/**
 * Model ImportAuditRow
 * 
 */
export type ImportAuditRow = $Result.DefaultSelection<Prisma.$ImportAuditRowPayload>
/**
 * Model Ballot
 * 
 */
export type Ballot = $Result.DefaultSelection<Prisma.$BallotPayload>
/**
 * Model AwardEvent
 * 
 */
export type AwardEvent = $Result.DefaultSelection<Prisma.$AwardEventPayload>
/**
 * Model AwardSeason
 * 
 */
export type AwardSeason = $Result.DefaultSelection<Prisma.$AwardSeasonPayload>
/**
 * Model Movie
 * 
 */
export type Movie = $Result.DefaultSelection<Prisma.$MoviePayload>
/**
 * Model AwardWinner
 * 
 */
export type AwardWinner = $Result.DefaultSelection<Prisma.$AwardWinnerPayload>
/**
 * Model StreamingSubscription
 * 
 */
export type StreamingSubscription = $Result.DefaultSelection<Prisma.$StreamingSubscriptionPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model OnboardingState
 * 
 */
export type OnboardingState = $Result.DefaultSelection<Prisma.$OnboardingStatePayload>
/**
 * Model UserPreferredGenre
 * 
 */
export type UserPreferredGenre = $Result.DefaultSelection<Prisma.$UserPreferredGenrePayload>
/**
 * Model UserTopTen
 * 
 */
export type UserTopTen = $Result.DefaultSelection<Prisma.$UserTopTenPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.movieInteraction`: Exposes CRUD operations for the **MovieInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieInteractions
    * const movieInteractions = await prisma.movieInteraction.findMany()
    * ```
    */
  get movieInteraction(): Prisma.MovieInteractionDelegate<ExtArgs>;

  /**
   * `prisma.watchLog`: Exposes CRUD operations for the **WatchLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchLogs
    * const watchLogs = await prisma.watchLog.findMany()
    * ```
    */
  get watchLog(): Prisma.WatchLogDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.reviewComment`: Exposes CRUD operations for the **ReviewComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewComments
    * const reviewComments = await prisma.reviewComment.findMany()
    * ```
    */
  get reviewComment(): Prisma.ReviewCommentDelegate<ExtArgs>;

  /**
   * `prisma.reviewFavorite`: Exposes CRUD operations for the **ReviewFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewFavorites
    * const reviewFavorites = await prisma.reviewFavorite.findMany()
    * ```
    */
  get reviewFavorite(): Prisma.ReviewFavoriteDelegate<ExtArgs>;

  /**
   * `prisma.movieList`: Exposes CRUD operations for the **MovieList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieLists
    * const movieLists = await prisma.movieList.findMany()
    * ```
    */
  get movieList(): Prisma.MovieListDelegate<ExtArgs>;

  /**
   * `prisma.movieListItem`: Exposes CRUD operations for the **MovieListItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MovieListItems
    * const movieListItems = await prisma.movieListItem.findMany()
    * ```
    */
  get movieListItem(): Prisma.MovieListItemDelegate<ExtArgs>;

  /**
   * `prisma.importRun`: Exposes CRUD operations for the **ImportRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportRuns
    * const importRuns = await prisma.importRun.findMany()
    * ```
    */
  get importRun(): Prisma.ImportRunDelegate<ExtArgs>;

  /**
   * `prisma.importAuditRow`: Exposes CRUD operations for the **ImportAuditRow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportAuditRows
    * const importAuditRows = await prisma.importAuditRow.findMany()
    * ```
    */
  get importAuditRow(): Prisma.ImportAuditRowDelegate<ExtArgs>;

  /**
   * `prisma.ballot`: Exposes CRUD operations for the **Ballot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ballots
    * const ballots = await prisma.ballot.findMany()
    * ```
    */
  get ballot(): Prisma.BallotDelegate<ExtArgs>;

  /**
   * `prisma.awardEvent`: Exposes CRUD operations for the **AwardEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AwardEvents
    * const awardEvents = await prisma.awardEvent.findMany()
    * ```
    */
  get awardEvent(): Prisma.AwardEventDelegate<ExtArgs>;

  /**
   * `prisma.awardSeason`: Exposes CRUD operations for the **AwardSeason** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AwardSeasons
    * const awardSeasons = await prisma.awardSeason.findMany()
    * ```
    */
  get awardSeason(): Prisma.AwardSeasonDelegate<ExtArgs>;

  /**
   * `prisma.movie`: Exposes CRUD operations for the **Movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movie.findMany()
    * ```
    */
  get movie(): Prisma.MovieDelegate<ExtArgs>;

  /**
   * `prisma.awardWinner`: Exposes CRUD operations for the **AwardWinner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AwardWinners
    * const awardWinners = await prisma.awardWinner.findMany()
    * ```
    */
  get awardWinner(): Prisma.AwardWinnerDelegate<ExtArgs>;

  /**
   * `prisma.streamingSubscription`: Exposes CRUD operations for the **StreamingSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StreamingSubscriptions
    * const streamingSubscriptions = await prisma.streamingSubscription.findMany()
    * ```
    */
  get streamingSubscription(): Prisma.StreamingSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs>;

  /**
   * `prisma.onboardingState`: Exposes CRUD operations for the **OnboardingState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OnboardingStates
    * const onboardingStates = await prisma.onboardingState.findMany()
    * ```
    */
  get onboardingState(): Prisma.OnboardingStateDelegate<ExtArgs>;

  /**
   * `prisma.userPreferredGenre`: Exposes CRUD operations for the **UserPreferredGenre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferredGenres
    * const userPreferredGenres = await prisma.userPreferredGenre.findMany()
    * ```
    */
  get userPreferredGenre(): Prisma.UserPreferredGenreDelegate<ExtArgs>;

  /**
   * `prisma.userTopTen`: Exposes CRUD operations for the **UserTopTen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTopTens
    * const userTopTens = await prisma.userTopTen.findMany()
    * ```
    */
  get userTopTen(): Prisma.UserTopTenDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.0.0
   * Query Engine version: 5dbef10bdbfb579e07d35cc85fb1518d357cb99e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    MovieInteraction: 'MovieInteraction',
    WatchLog: 'WatchLog',
    Review: 'Review',
    ReviewComment: 'ReviewComment',
    ReviewFavorite: 'ReviewFavorite',
    MovieList: 'MovieList',
    MovieListItem: 'MovieListItem',
    ImportRun: 'ImportRun',
    ImportAuditRow: 'ImportAuditRow',
    Ballot: 'Ballot',
    AwardEvent: 'AwardEvent',
    AwardSeason: 'AwardSeason',
    Movie: 'Movie',
    AwardWinner: 'AwardWinner',
    StreamingSubscription: 'StreamingSubscription',
    UserSettings: 'UserSettings',
    OnboardingState: 'OnboardingState',
    UserPreferredGenre: 'UserPreferredGenre',
    UserTopTen: 'UserTopTen'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "movieInteraction" | "watchLog" | "review" | "reviewComment" | "reviewFavorite" | "movieList" | "movieListItem" | "importRun" | "importAuditRow" | "ballot" | "awardEvent" | "awardSeason" | "movie" | "awardWinner" | "streamingSubscription" | "userSettings" | "onboardingState" | "userPreferredGenre" | "userTopTen"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      MovieInteraction: {
        payload: Prisma.$MovieInteractionPayload<ExtArgs>
        fields: Prisma.MovieInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload>
          }
          findFirst: {
            args: Prisma.MovieInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload>
          }
          findMany: {
            args: Prisma.MovieInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload>[]
          }
          create: {
            args: Prisma.MovieInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload>
          }
          createMany: {
            args: Prisma.MovieInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload>[]
          }
          delete: {
            args: Prisma.MovieInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload>
          }
          update: {
            args: Prisma.MovieInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload>
          }
          deleteMany: {
            args: Prisma.MovieInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieInteractionPayload>
          }
          aggregate: {
            args: Prisma.MovieInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieInteraction>
          }
          groupBy: {
            args: Prisma.MovieInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<MovieInteractionCountAggregateOutputType> | number
          }
        }
      }
      WatchLog: {
        payload: Prisma.$WatchLogPayload<ExtArgs>
        fields: Prisma.WatchLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload>
          }
          findFirst: {
            args: Prisma.WatchLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload>
          }
          findMany: {
            args: Prisma.WatchLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload>[]
          }
          create: {
            args: Prisma.WatchLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload>
          }
          createMany: {
            args: Prisma.WatchLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload>[]
          }
          delete: {
            args: Prisma.WatchLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload>
          }
          update: {
            args: Prisma.WatchLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload>
          }
          deleteMany: {
            args: Prisma.WatchLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WatchLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchLogPayload>
          }
          aggregate: {
            args: Prisma.WatchLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchLog>
          }
          groupBy: {
            args: Prisma.WatchLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchLogCountArgs<ExtArgs>
            result: $Utils.Optional<WatchLogCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ReviewComment: {
        payload: Prisma.$ReviewCommentPayload<ExtArgs>
        fields: Prisma.ReviewCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          findFirst: {
            args: Prisma.ReviewCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          findMany: {
            args: Prisma.ReviewCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>[]
          }
          create: {
            args: Prisma.ReviewCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          createMany: {
            args: Prisma.ReviewCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>[]
          }
          delete: {
            args: Prisma.ReviewCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          update: {
            args: Prisma.ReviewCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          deleteMany: {
            args: Prisma.ReviewCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewCommentPayload>
          }
          aggregate: {
            args: Prisma.ReviewCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewComment>
          }
          groupBy: {
            args: Prisma.ReviewCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCommentCountAggregateOutputType> | number
          }
        }
      }
      ReviewFavorite: {
        payload: Prisma.$ReviewFavoritePayload<ExtArgs>
        fields: Prisma.ReviewFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload>
          }
          findFirst: {
            args: Prisma.ReviewFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload>
          }
          findMany: {
            args: Prisma.ReviewFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload>[]
          }
          create: {
            args: Prisma.ReviewFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload>
          }
          createMany: {
            args: Prisma.ReviewFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload>[]
          }
          delete: {
            args: Prisma.ReviewFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload>
          }
          update: {
            args: Prisma.ReviewFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload>
          }
          deleteMany: {
            args: Prisma.ReviewFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewFavoritePayload>
          }
          aggregate: {
            args: Prisma.ReviewFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewFavorite>
          }
          groupBy: {
            args: Prisma.ReviewFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewFavoriteCountAggregateOutputType> | number
          }
        }
      }
      MovieList: {
        payload: Prisma.$MovieListPayload<ExtArgs>
        fields: Prisma.MovieListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload>
          }
          findFirst: {
            args: Prisma.MovieListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload>
          }
          findMany: {
            args: Prisma.MovieListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload>[]
          }
          create: {
            args: Prisma.MovieListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload>
          }
          createMany: {
            args: Prisma.MovieListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload>[]
          }
          delete: {
            args: Prisma.MovieListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload>
          }
          update: {
            args: Prisma.MovieListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload>
          }
          deleteMany: {
            args: Prisma.MovieListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListPayload>
          }
          aggregate: {
            args: Prisma.MovieListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieList>
          }
          groupBy: {
            args: Prisma.MovieListGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieListGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieListCountArgs<ExtArgs>
            result: $Utils.Optional<MovieListCountAggregateOutputType> | number
          }
        }
      }
      MovieListItem: {
        payload: Prisma.$MovieListItemPayload<ExtArgs>
        fields: Prisma.MovieListItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieListItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieListItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload>
          }
          findFirst: {
            args: Prisma.MovieListItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieListItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload>
          }
          findMany: {
            args: Prisma.MovieListItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload>[]
          }
          create: {
            args: Prisma.MovieListItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload>
          }
          createMany: {
            args: Prisma.MovieListItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieListItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload>[]
          }
          delete: {
            args: Prisma.MovieListItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload>
          }
          update: {
            args: Prisma.MovieListItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload>
          }
          deleteMany: {
            args: Prisma.MovieListItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieListItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieListItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovieListItemPayload>
          }
          aggregate: {
            args: Prisma.MovieListItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovieListItem>
          }
          groupBy: {
            args: Prisma.MovieListItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieListItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieListItemCountArgs<ExtArgs>
            result: $Utils.Optional<MovieListItemCountAggregateOutputType> | number
          }
        }
      }
      ImportRun: {
        payload: Prisma.$ImportRunPayload<ExtArgs>
        fields: Prisma.ImportRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload>
          }
          findFirst: {
            args: Prisma.ImportRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload>
          }
          findMany: {
            args: Prisma.ImportRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload>[]
          }
          create: {
            args: Prisma.ImportRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload>
          }
          createMany: {
            args: Prisma.ImportRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload>[]
          }
          delete: {
            args: Prisma.ImportRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload>
          }
          update: {
            args: Prisma.ImportRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload>
          }
          deleteMany: {
            args: Prisma.ImportRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportRunPayload>
          }
          aggregate: {
            args: Prisma.ImportRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportRun>
          }
          groupBy: {
            args: Prisma.ImportRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportRunCountArgs<ExtArgs>
            result: $Utils.Optional<ImportRunCountAggregateOutputType> | number
          }
        }
      }
      ImportAuditRow: {
        payload: Prisma.$ImportAuditRowPayload<ExtArgs>
        fields: Prisma.ImportAuditRowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportAuditRowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportAuditRowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload>
          }
          findFirst: {
            args: Prisma.ImportAuditRowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportAuditRowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload>
          }
          findMany: {
            args: Prisma.ImportAuditRowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload>[]
          }
          create: {
            args: Prisma.ImportAuditRowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload>
          }
          createMany: {
            args: Prisma.ImportAuditRowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportAuditRowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload>[]
          }
          delete: {
            args: Prisma.ImportAuditRowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload>
          }
          update: {
            args: Prisma.ImportAuditRowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload>
          }
          deleteMany: {
            args: Prisma.ImportAuditRowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportAuditRowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportAuditRowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportAuditRowPayload>
          }
          aggregate: {
            args: Prisma.ImportAuditRowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportAuditRow>
          }
          groupBy: {
            args: Prisma.ImportAuditRowGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportAuditRowGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportAuditRowCountArgs<ExtArgs>
            result: $Utils.Optional<ImportAuditRowCountAggregateOutputType> | number
          }
        }
      }
      Ballot: {
        payload: Prisma.$BallotPayload<ExtArgs>
        fields: Prisma.BallotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BallotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BallotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload>
          }
          findFirst: {
            args: Prisma.BallotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BallotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload>
          }
          findMany: {
            args: Prisma.BallotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload>[]
          }
          create: {
            args: Prisma.BallotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload>
          }
          createMany: {
            args: Prisma.BallotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BallotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload>[]
          }
          delete: {
            args: Prisma.BallotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload>
          }
          update: {
            args: Prisma.BallotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload>
          }
          deleteMany: {
            args: Prisma.BallotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BallotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BallotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BallotPayload>
          }
          aggregate: {
            args: Prisma.BallotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBallot>
          }
          groupBy: {
            args: Prisma.BallotGroupByArgs<ExtArgs>
            result: $Utils.Optional<BallotGroupByOutputType>[]
          }
          count: {
            args: Prisma.BallotCountArgs<ExtArgs>
            result: $Utils.Optional<BallotCountAggregateOutputType> | number
          }
        }
      }
      AwardEvent: {
        payload: Prisma.$AwardEventPayload<ExtArgs>
        fields: Prisma.AwardEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AwardEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AwardEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload>
          }
          findFirst: {
            args: Prisma.AwardEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AwardEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload>
          }
          findMany: {
            args: Prisma.AwardEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload>[]
          }
          create: {
            args: Prisma.AwardEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload>
          }
          createMany: {
            args: Prisma.AwardEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AwardEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload>[]
          }
          delete: {
            args: Prisma.AwardEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload>
          }
          update: {
            args: Prisma.AwardEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload>
          }
          deleteMany: {
            args: Prisma.AwardEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AwardEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AwardEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardEventPayload>
          }
          aggregate: {
            args: Prisma.AwardEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAwardEvent>
          }
          groupBy: {
            args: Prisma.AwardEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AwardEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AwardEventCountArgs<ExtArgs>
            result: $Utils.Optional<AwardEventCountAggregateOutputType> | number
          }
        }
      }
      AwardSeason: {
        payload: Prisma.$AwardSeasonPayload<ExtArgs>
        fields: Prisma.AwardSeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AwardSeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AwardSeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload>
          }
          findFirst: {
            args: Prisma.AwardSeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AwardSeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload>
          }
          findMany: {
            args: Prisma.AwardSeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload>[]
          }
          create: {
            args: Prisma.AwardSeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload>
          }
          createMany: {
            args: Prisma.AwardSeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AwardSeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload>[]
          }
          delete: {
            args: Prisma.AwardSeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload>
          }
          update: {
            args: Prisma.AwardSeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload>
          }
          deleteMany: {
            args: Prisma.AwardSeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AwardSeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AwardSeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardSeasonPayload>
          }
          aggregate: {
            args: Prisma.AwardSeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAwardSeason>
          }
          groupBy: {
            args: Prisma.AwardSeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<AwardSeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.AwardSeasonCountArgs<ExtArgs>
            result: $Utils.Optional<AwardSeasonCountAggregateOutputType> | number
          }
        }
      }
      Movie: {
        payload: Prisma.$MoviePayload<ExtArgs>
        fields: Prisma.MovieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findFirst: {
            args: Prisma.MovieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          findMany: {
            args: Prisma.MovieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          create: {
            args: Prisma.MovieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          createMany: {
            args: Prisma.MovieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>[]
          }
          delete: {
            args: Prisma.MovieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          update: {
            args: Prisma.MovieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          deleteMany: {
            args: Prisma.MovieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoviePayload>
          }
          aggregate: {
            args: Prisma.MovieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovie>
          }
          groupBy: {
            args: Prisma.MovieGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovieGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovieCountArgs<ExtArgs>
            result: $Utils.Optional<MovieCountAggregateOutputType> | number
          }
        }
      }
      AwardWinner: {
        payload: Prisma.$AwardWinnerPayload<ExtArgs>
        fields: Prisma.AwardWinnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AwardWinnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AwardWinnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload>
          }
          findFirst: {
            args: Prisma.AwardWinnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AwardWinnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload>
          }
          findMany: {
            args: Prisma.AwardWinnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload>[]
          }
          create: {
            args: Prisma.AwardWinnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload>
          }
          createMany: {
            args: Prisma.AwardWinnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AwardWinnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload>[]
          }
          delete: {
            args: Prisma.AwardWinnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload>
          }
          update: {
            args: Prisma.AwardWinnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload>
          }
          deleteMany: {
            args: Prisma.AwardWinnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AwardWinnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AwardWinnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardWinnerPayload>
          }
          aggregate: {
            args: Prisma.AwardWinnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAwardWinner>
          }
          groupBy: {
            args: Prisma.AwardWinnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AwardWinnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AwardWinnerCountArgs<ExtArgs>
            result: $Utils.Optional<AwardWinnerCountAggregateOutputType> | number
          }
        }
      }
      StreamingSubscription: {
        payload: Prisma.$StreamingSubscriptionPayload<ExtArgs>
        fields: Prisma.StreamingSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreamingSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreamingSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.StreamingSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreamingSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload>
          }
          findMany: {
            args: Prisma.StreamingSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload>[]
          }
          create: {
            args: Prisma.StreamingSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload>
          }
          createMany: {
            args: Prisma.StreamingSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StreamingSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.StreamingSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload>
          }
          update: {
            args: Prisma.StreamingSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.StreamingSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StreamingSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StreamingSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreamingSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.StreamingSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStreamingSubscription>
          }
          groupBy: {
            args: Prisma.StreamingSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StreamingSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreamingSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<StreamingSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      OnboardingState: {
        payload: Prisma.$OnboardingStatePayload<ExtArgs>
        fields: Prisma.OnboardingStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OnboardingStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OnboardingStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload>
          }
          findFirst: {
            args: Prisma.OnboardingStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OnboardingStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload>
          }
          findMany: {
            args: Prisma.OnboardingStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload>[]
          }
          create: {
            args: Prisma.OnboardingStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload>
          }
          createMany: {
            args: Prisma.OnboardingStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OnboardingStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload>[]
          }
          delete: {
            args: Prisma.OnboardingStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload>
          }
          update: {
            args: Prisma.OnboardingStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload>
          }
          deleteMany: {
            args: Prisma.OnboardingStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OnboardingStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OnboardingStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OnboardingStatePayload>
          }
          aggregate: {
            args: Prisma.OnboardingStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOnboardingState>
          }
          groupBy: {
            args: Prisma.OnboardingStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<OnboardingStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.OnboardingStateCountArgs<ExtArgs>
            result: $Utils.Optional<OnboardingStateCountAggregateOutputType> | number
          }
        }
      }
      UserPreferredGenre: {
        payload: Prisma.$UserPreferredGenrePayload<ExtArgs>
        fields: Prisma.UserPreferredGenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferredGenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferredGenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload>
          }
          findFirst: {
            args: Prisma.UserPreferredGenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferredGenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload>
          }
          findMany: {
            args: Prisma.UserPreferredGenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload>[]
          }
          create: {
            args: Prisma.UserPreferredGenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload>
          }
          createMany: {
            args: Prisma.UserPreferredGenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferredGenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload>[]
          }
          delete: {
            args: Prisma.UserPreferredGenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload>
          }
          update: {
            args: Prisma.UserPreferredGenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload>
          }
          deleteMany: {
            args: Prisma.UserPreferredGenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferredGenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPreferredGenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferredGenrePayload>
          }
          aggregate: {
            args: Prisma.UserPreferredGenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferredGenre>
          }
          groupBy: {
            args: Prisma.UserPreferredGenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferredGenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferredGenreCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferredGenreCountAggregateOutputType> | number
          }
        }
      }
      UserTopTen: {
        payload: Prisma.$UserTopTenPayload<ExtArgs>
        fields: Prisma.UserTopTenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTopTenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTopTenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload>
          }
          findFirst: {
            args: Prisma.UserTopTenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTopTenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload>
          }
          findMany: {
            args: Prisma.UserTopTenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload>[]
          }
          create: {
            args: Prisma.UserTopTenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload>
          }
          createMany: {
            args: Prisma.UserTopTenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTopTenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload>[]
          }
          delete: {
            args: Prisma.UserTopTenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload>
          }
          update: {
            args: Prisma.UserTopTenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload>
          }
          deleteMany: {
            args: Prisma.UserTopTenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTopTenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTopTenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTopTenPayload>
          }
          aggregate: {
            args: Prisma.UserTopTenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTopTen>
          }
          groupBy: {
            args: Prisma.UserTopTenGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTopTenGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTopTenCountArgs<ExtArgs>
            result: $Utils.Optional<UserTopTenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    interactions: number
    watchLogs: number
    reviews: number
    reviewComments: number
    reviewFavorites: number
    movieLists: number
    ballots: number
    subscriptions: number
    importRuns: number
    topTen: number
    preferredGenres: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    interactions?: boolean | UserCountOutputTypeCountInteractionsArgs
    watchLogs?: boolean | UserCountOutputTypeCountWatchLogsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    reviewComments?: boolean | UserCountOutputTypeCountReviewCommentsArgs
    reviewFavorites?: boolean | UserCountOutputTypeCountReviewFavoritesArgs
    movieLists?: boolean | UserCountOutputTypeCountMovieListsArgs
    ballots?: boolean | UserCountOutputTypeCountBallotsArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    importRuns?: boolean | UserCountOutputTypeCountImportRunsArgs
    topTen?: boolean | UserCountOutputTypeCountTopTenArgs
    preferredGenres?: boolean | UserCountOutputTypeCountPreferredGenresArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieInteractionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWatchLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewFavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMovieListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieListWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBallotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BallotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamingSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImportRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTopTenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTopTenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPreferredGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferredGenreWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    comments: number
    favorites: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ReviewCountOutputTypeCountCommentsArgs
    favorites?: boolean | ReviewCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewCommentWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewFavoriteWhereInput
  }


  /**
   * Count Type MovieListCountOutputType
   */

  export type MovieListCountOutputType = {
    items: number
  }

  export type MovieListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | MovieListCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * MovieListCountOutputType without action
   */
  export type MovieListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListCountOutputType
     */
    select?: MovieListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MovieListCountOutputType without action
   */
  export type MovieListCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieListItemWhereInput
  }


  /**
   * Count Type ImportRunCountOutputType
   */

  export type ImportRunCountOutputType = {
    auditRows: number
    watchLogs: number
  }

  export type ImportRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditRows?: boolean | ImportRunCountOutputTypeCountAuditRowsArgs
    watchLogs?: boolean | ImportRunCountOutputTypeCountWatchLogsArgs
  }

  // Custom InputTypes
  /**
   * ImportRunCountOutputType without action
   */
  export type ImportRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRunCountOutputType
     */
    select?: ImportRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportRunCountOutputType without action
   */
  export type ImportRunCountOutputTypeCountAuditRowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportAuditRowWhereInput
  }

  /**
   * ImportRunCountOutputType without action
   */
  export type ImportRunCountOutputTypeCountWatchLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchLogWhereInput
  }


  /**
   * Count Type AwardEventCountOutputType
   */

  export type AwardEventCountOutputType = {
    seasons: number
  }

  export type AwardEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasons?: boolean | AwardEventCountOutputTypeCountSeasonsArgs
  }

  // Custom InputTypes
  /**
   * AwardEventCountOutputType without action
   */
  export type AwardEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEventCountOutputType
     */
    select?: AwardEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AwardEventCountOutputType without action
   */
  export type AwardEventCountOutputTypeCountSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardSeasonWhereInput
  }


  /**
   * Count Type AwardSeasonCountOutputType
   */

  export type AwardSeasonCountOutputType = {
    winners: number
  }

  export type AwardSeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winners?: boolean | AwardSeasonCountOutputTypeCountWinnersArgs
  }

  // Custom InputTypes
  /**
   * AwardSeasonCountOutputType without action
   */
  export type AwardSeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeasonCountOutputType
     */
    select?: AwardSeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AwardSeasonCountOutputType without action
   */
  export type AwardSeasonCountOutputTypeCountWinnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardWinnerWhereInput
  }


  /**
   * Count Type MovieCountOutputType
   */

  export type MovieCountOutputType = {
    winners: number
    interactions: number
    watchLogs: number
    listItems: number
  }

  export type MovieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winners?: boolean | MovieCountOutputTypeCountWinnersArgs
    interactions?: boolean | MovieCountOutputTypeCountInteractionsArgs
    watchLogs?: boolean | MovieCountOutputTypeCountWatchLogsArgs
    listItems?: boolean | MovieCountOutputTypeCountListItemsArgs
  }

  // Custom InputTypes
  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieCountOutputType
     */
    select?: MovieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountWinnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardWinnerWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieInteractionWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountWatchLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchLogWhereInput
  }

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeCountListItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieListItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    clerkId: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    clerkId: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    clerkId: number
    name: number
    email: number
    emailVerified: number
    image: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    clerkId?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    clerkId?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    clerkId?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    clerkId: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    interactions?: boolean | User$interactionsArgs<ExtArgs>
    watchLogs?: boolean | User$watchLogsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewComments?: boolean | User$reviewCommentsArgs<ExtArgs>
    reviewFavorites?: boolean | User$reviewFavoritesArgs<ExtArgs>
    movieLists?: boolean | User$movieListsArgs<ExtArgs>
    ballots?: boolean | User$ballotsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    importRuns?: boolean | User$importRunsArgs<ExtArgs>
    topTen?: boolean | User$topTenArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    onboarding?: boolean | User$onboardingArgs<ExtArgs>
    preferredGenres?: boolean | User$preferredGenresArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    clerkId?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    interactions?: boolean | User$interactionsArgs<ExtArgs>
    watchLogs?: boolean | User$watchLogsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewComments?: boolean | User$reviewCommentsArgs<ExtArgs>
    reviewFavorites?: boolean | User$reviewFavoritesArgs<ExtArgs>
    movieLists?: boolean | User$movieListsArgs<ExtArgs>
    ballots?: boolean | User$ballotsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    importRuns?: boolean | User$importRunsArgs<ExtArgs>
    topTen?: boolean | User$topTenArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    onboarding?: boolean | User$onboardingArgs<ExtArgs>
    preferredGenres?: boolean | User$preferredGenresArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      interactions: Prisma.$MovieInteractionPayload<ExtArgs>[]
      watchLogs: Prisma.$WatchLogPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      reviewComments: Prisma.$ReviewCommentPayload<ExtArgs>[]
      reviewFavorites: Prisma.$ReviewFavoritePayload<ExtArgs>[]
      movieLists: Prisma.$MovieListPayload<ExtArgs>[]
      ballots: Prisma.$BallotPayload<ExtArgs>[]
      subscriptions: Prisma.$StreamingSubscriptionPayload<ExtArgs>[]
      importRuns: Prisma.$ImportRunPayload<ExtArgs>[]
      topTen: Prisma.$UserTopTenPayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      onboarding: Prisma.$OnboardingStatePayload<ExtArgs> | null
      preferredGenres: Prisma.$UserPreferredGenrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clerkId: string | null
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    interactions<T extends User$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "findMany"> | Null>
    watchLogs<T extends User$watchLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$watchLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    reviewComments<T extends User$reviewCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findMany"> | Null>
    reviewFavorites<T extends User$reviewFavoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewFavoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "findMany"> | Null>
    movieLists<T extends User$movieListsArgs<ExtArgs> = {}>(args?: Subset<T, User$movieListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "findMany"> | Null>
    ballots<T extends User$ballotsArgs<ExtArgs> = {}>(args?: Subset<T, User$ballotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    importRuns<T extends User$importRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$importRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "findMany"> | Null>
    topTen<T extends User$topTenArgs<ExtArgs> = {}>(args?: Subset<T, User$topTenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    onboarding<T extends User$onboardingArgs<ExtArgs> = {}>(args?: Subset<T, User$onboardingArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    preferredGenres<T extends User$preferredGenresArgs<ExtArgs> = {}>(args?: Subset<T, User$preferredGenresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly clerkId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.interactions
   */
  export type User$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    where?: MovieInteractionWhereInput
    orderBy?: MovieInteractionOrderByWithRelationInput | MovieInteractionOrderByWithRelationInput[]
    cursor?: MovieInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieInteractionScalarFieldEnum | MovieInteractionScalarFieldEnum[]
  }

  /**
   * User.watchLogs
   */
  export type User$watchLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    where?: WatchLogWhereInput
    orderBy?: WatchLogOrderByWithRelationInput | WatchLogOrderByWithRelationInput[]
    cursor?: WatchLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchLogScalarFieldEnum | WatchLogScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewComments
   */
  export type User$reviewCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    where?: ReviewCommentWhereInput
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    cursor?: ReviewCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * User.reviewFavorites
   */
  export type User$reviewFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    where?: ReviewFavoriteWhereInput
    orderBy?: ReviewFavoriteOrderByWithRelationInput | ReviewFavoriteOrderByWithRelationInput[]
    cursor?: ReviewFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewFavoriteScalarFieldEnum | ReviewFavoriteScalarFieldEnum[]
  }

  /**
   * User.movieLists
   */
  export type User$movieListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    where?: MovieListWhereInput
    orderBy?: MovieListOrderByWithRelationInput | MovieListOrderByWithRelationInput[]
    cursor?: MovieListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieListScalarFieldEnum | MovieListScalarFieldEnum[]
  }

  /**
   * User.ballots
   */
  export type User$ballotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    where?: BallotWhereInput
    orderBy?: BallotOrderByWithRelationInput | BallotOrderByWithRelationInput[]
    cursor?: BallotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BallotScalarFieldEnum | BallotScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    where?: StreamingSubscriptionWhereInput
    orderBy?: StreamingSubscriptionOrderByWithRelationInput | StreamingSubscriptionOrderByWithRelationInput[]
    cursor?: StreamingSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StreamingSubscriptionScalarFieldEnum | StreamingSubscriptionScalarFieldEnum[]
  }

  /**
   * User.importRuns
   */
  export type User$importRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    where?: ImportRunWhereInput
    orderBy?: ImportRunOrderByWithRelationInput | ImportRunOrderByWithRelationInput[]
    cursor?: ImportRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportRunScalarFieldEnum | ImportRunScalarFieldEnum[]
  }

  /**
   * User.topTen
   */
  export type User$topTenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    where?: UserTopTenWhereInput
    orderBy?: UserTopTenOrderByWithRelationInput | UserTopTenOrderByWithRelationInput[]
    cursor?: UserTopTenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTopTenScalarFieldEnum | UserTopTenScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.onboarding
   */
  export type User$onboardingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    where?: OnboardingStateWhereInput
  }

  /**
   * User.preferredGenres
   */
  export type User$preferredGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    where?: UserPreferredGenreWhereInput
    orderBy?: UserPreferredGenreOrderByWithRelationInput | UserPreferredGenreOrderByWithRelationInput[]
    cursor?: UserPreferredGenreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPreferredGenreScalarFieldEnum | UserPreferredGenreScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({ 
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model MovieInteraction
   */

  export type AggregateMovieInteraction = {
    _count: MovieInteractionCountAggregateOutputType | null
    _avg: MovieInteractionAvgAggregateOutputType | null
    _sum: MovieInteractionSumAggregateOutputType | null
    _min: MovieInteractionMinAggregateOutputType | null
    _max: MovieInteractionMaxAggregateOutputType | null
  }

  export type MovieInteractionAvgAggregateOutputType = {
    movieId: number | null
    ratingHalf: number | null
  }

  export type MovieInteractionSumAggregateOutputType = {
    movieId: number | null
    ratingHalf: number | null
  }

  export type MovieInteractionMinAggregateOutputType = {
    userId: string | null
    movieId: number | null
    watched: boolean | null
    watchlisted: boolean | null
    favorited: boolean | null
    ratingHalf: number | null
    ratedAt: Date | null
    favoritedAt: Date | null
    watchedAt: Date | null
    updatedAt: Date | null
  }

  export type MovieInteractionMaxAggregateOutputType = {
    userId: string | null
    movieId: number | null
    watched: boolean | null
    watchlisted: boolean | null
    favorited: boolean | null
    ratingHalf: number | null
    ratedAt: Date | null
    favoritedAt: Date | null
    watchedAt: Date | null
    updatedAt: Date | null
  }

  export type MovieInteractionCountAggregateOutputType = {
    userId: number
    movieId: number
    watched: number
    watchlisted: number
    favorited: number
    ratingHalf: number
    ratedAt: number
    favoritedAt: number
    watchedAt: number
    updatedAt: number
    _all: number
  }


  export type MovieInteractionAvgAggregateInputType = {
    movieId?: true
    ratingHalf?: true
  }

  export type MovieInteractionSumAggregateInputType = {
    movieId?: true
    ratingHalf?: true
  }

  export type MovieInteractionMinAggregateInputType = {
    userId?: true
    movieId?: true
    watched?: true
    watchlisted?: true
    favorited?: true
    ratingHalf?: true
    ratedAt?: true
    favoritedAt?: true
    watchedAt?: true
    updatedAt?: true
  }

  export type MovieInteractionMaxAggregateInputType = {
    userId?: true
    movieId?: true
    watched?: true
    watchlisted?: true
    favorited?: true
    ratingHalf?: true
    ratedAt?: true
    favoritedAt?: true
    watchedAt?: true
    updatedAt?: true
  }

  export type MovieInteractionCountAggregateInputType = {
    userId?: true
    movieId?: true
    watched?: true
    watchlisted?: true
    favorited?: true
    ratingHalf?: true
    ratedAt?: true
    favoritedAt?: true
    watchedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovieInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieInteraction to aggregate.
     */
    where?: MovieInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieInteractions to fetch.
     */
    orderBy?: MovieInteractionOrderByWithRelationInput | MovieInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieInteractions
    **/
    _count?: true | MovieInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieInteractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieInteractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieInteractionMaxAggregateInputType
  }

  export type GetMovieInteractionAggregateType<T extends MovieInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieInteraction[P]>
      : GetScalarType<T[P], AggregateMovieInteraction[P]>
  }




  export type MovieInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieInteractionWhereInput
    orderBy?: MovieInteractionOrderByWithAggregationInput | MovieInteractionOrderByWithAggregationInput[]
    by: MovieInteractionScalarFieldEnum[] | MovieInteractionScalarFieldEnum
    having?: MovieInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieInteractionCountAggregateInputType | true
    _avg?: MovieInteractionAvgAggregateInputType
    _sum?: MovieInteractionSumAggregateInputType
    _min?: MovieInteractionMinAggregateInputType
    _max?: MovieInteractionMaxAggregateInputType
  }

  export type MovieInteractionGroupByOutputType = {
    userId: string
    movieId: number
    watched: boolean
    watchlisted: boolean
    favorited: boolean
    ratingHalf: number | null
    ratedAt: Date | null
    favoritedAt: Date | null
    watchedAt: Date | null
    updatedAt: Date
    _count: MovieInteractionCountAggregateOutputType | null
    _avg: MovieInteractionAvgAggregateOutputType | null
    _sum: MovieInteractionSumAggregateOutputType | null
    _min: MovieInteractionMinAggregateOutputType | null
    _max: MovieInteractionMaxAggregateOutputType | null
  }

  type GetMovieInteractionGroupByPayload<T extends MovieInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], MovieInteractionGroupByOutputType[P]>
        }
      >
    >


  export type MovieInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    movieId?: boolean
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: boolean
    ratedAt?: boolean
    favoritedAt?: boolean
    watchedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    movie?: boolean | MovieInteraction$movieArgs<ExtArgs>
  }, ExtArgs["result"]["movieInteraction"]>

  export type MovieInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    movieId?: boolean
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: boolean
    ratedAt?: boolean
    favoritedAt?: boolean
    watchedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    movie?: boolean | MovieInteraction$movieArgs<ExtArgs>
  }, ExtArgs["result"]["movieInteraction"]>

  export type MovieInteractionSelectScalar = {
    userId?: boolean
    movieId?: boolean
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: boolean
    ratedAt?: boolean
    favoritedAt?: boolean
    watchedAt?: boolean
    updatedAt?: boolean
  }

  export type MovieInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    movie?: boolean | MovieInteraction$movieArgs<ExtArgs>
  }
  export type MovieInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    movie?: boolean | MovieInteraction$movieArgs<ExtArgs>
  }

  export type $MovieInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieInteraction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      movie: Prisma.$MoviePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      movieId: number
      watched: boolean
      watchlisted: boolean
      favorited: boolean
      ratingHalf: number | null
      ratedAt: Date | null
      favoritedAt: Date | null
      watchedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["movieInteraction"]>
    composites: {}
  }

  type MovieInteractionGetPayload<S extends boolean | null | undefined | MovieInteractionDefaultArgs> = $Result.GetResult<Prisma.$MovieInteractionPayload, S>

  type MovieInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieInteractionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieInteractionCountAggregateInputType | true
    }

  export interface MovieInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieInteraction'], meta: { name: 'MovieInteraction' } }
    /**
     * Find zero or one MovieInteraction that matches the filter.
     * @param {MovieInteractionFindUniqueArgs} args - Arguments to find a MovieInteraction
     * @example
     * // Get one MovieInteraction
     * const movieInteraction = await prisma.movieInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieInteractionFindUniqueArgs>(args: SelectSubset<T, MovieInteractionFindUniqueArgs<ExtArgs>>): Prisma__MovieInteractionClient<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieInteraction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieInteractionFindUniqueOrThrowArgs} args - Arguments to find a MovieInteraction
     * @example
     * // Get one MovieInteraction
     * const movieInteraction = await prisma.movieInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieInteractionClient<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieInteractionFindFirstArgs} args - Arguments to find a MovieInteraction
     * @example
     * // Get one MovieInteraction
     * const movieInteraction = await prisma.movieInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieInteractionFindFirstArgs>(args?: SelectSubset<T, MovieInteractionFindFirstArgs<ExtArgs>>): Prisma__MovieInteractionClient<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieInteractionFindFirstOrThrowArgs} args - Arguments to find a MovieInteraction
     * @example
     * // Get one MovieInteraction
     * const movieInteraction = await prisma.movieInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieInteractionClient<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieInteractions
     * const movieInteractions = await prisma.movieInteraction.findMany()
     * 
     * // Get first 10 MovieInteractions
     * const movieInteractions = await prisma.movieInteraction.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const movieInteractionWithUserIdOnly = await prisma.movieInteraction.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends MovieInteractionFindManyArgs>(args?: SelectSubset<T, MovieInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieInteraction.
     * @param {MovieInteractionCreateArgs} args - Arguments to create a MovieInteraction.
     * @example
     * // Create one MovieInteraction
     * const MovieInteraction = await prisma.movieInteraction.create({
     *   data: {
     *     // ... data to create a MovieInteraction
     *   }
     * })
     * 
     */
    create<T extends MovieInteractionCreateArgs>(args: SelectSubset<T, MovieInteractionCreateArgs<ExtArgs>>): Prisma__MovieInteractionClient<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieInteractions.
     * @param {MovieInteractionCreateManyArgs} args - Arguments to create many MovieInteractions.
     * @example
     * // Create many MovieInteractions
     * const movieInteraction = await prisma.movieInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieInteractionCreateManyArgs>(args?: SelectSubset<T, MovieInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieInteractions and returns the data saved in the database.
     * @param {MovieInteractionCreateManyAndReturnArgs} args - Arguments to create many MovieInteractions.
     * @example
     * // Create many MovieInteractions
     * const movieInteraction = await prisma.movieInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieInteractions and only return the `userId`
     * const movieInteractionWithUserIdOnly = await prisma.movieInteraction.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovieInteraction.
     * @param {MovieInteractionDeleteArgs} args - Arguments to delete one MovieInteraction.
     * @example
     * // Delete one MovieInteraction
     * const MovieInteraction = await prisma.movieInteraction.delete({
     *   where: {
     *     // ... filter to delete one MovieInteraction
     *   }
     * })
     * 
     */
    delete<T extends MovieInteractionDeleteArgs>(args: SelectSubset<T, MovieInteractionDeleteArgs<ExtArgs>>): Prisma__MovieInteractionClient<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieInteraction.
     * @param {MovieInteractionUpdateArgs} args - Arguments to update one MovieInteraction.
     * @example
     * // Update one MovieInteraction
     * const movieInteraction = await prisma.movieInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieInteractionUpdateArgs>(args: SelectSubset<T, MovieInteractionUpdateArgs<ExtArgs>>): Prisma__MovieInteractionClient<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieInteractions.
     * @param {MovieInteractionDeleteManyArgs} args - Arguments to filter MovieInteractions to delete.
     * @example
     * // Delete a few MovieInteractions
     * const { count } = await prisma.movieInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieInteractionDeleteManyArgs>(args?: SelectSubset<T, MovieInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieInteractions
     * const movieInteraction = await prisma.movieInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieInteractionUpdateManyArgs>(args: SelectSubset<T, MovieInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieInteraction.
     * @param {MovieInteractionUpsertArgs} args - Arguments to update or create a MovieInteraction.
     * @example
     * // Update or create a MovieInteraction
     * const movieInteraction = await prisma.movieInteraction.upsert({
     *   create: {
     *     // ... data to create a MovieInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieInteraction we want to update
     *   }
     * })
     */
    upsert<T extends MovieInteractionUpsertArgs>(args: SelectSubset<T, MovieInteractionUpsertArgs<ExtArgs>>): Prisma__MovieInteractionClient<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieInteractionCountArgs} args - Arguments to filter MovieInteractions to count.
     * @example
     * // Count the number of MovieInteractions
     * const count = await prisma.movieInteraction.count({
     *   where: {
     *     // ... the filter for the MovieInteractions we want to count
     *   }
     * })
    **/
    count<T extends MovieInteractionCountArgs>(
      args?: Subset<T, MovieInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieInteractionAggregateArgs>(args: Subset<T, MovieInteractionAggregateArgs>): Prisma.PrismaPromise<GetMovieInteractionAggregateType<T>>

    /**
     * Group by MovieInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieInteractionGroupByArgs['orderBy'] }
        : { orderBy?: MovieInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieInteraction model
   */
  readonly fields: MovieInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movie<T extends MovieInteraction$movieArgs<ExtArgs> = {}>(args?: Subset<T, MovieInteraction$movieArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieInteraction model
   */ 
  interface MovieInteractionFieldRefs {
    readonly userId: FieldRef<"MovieInteraction", 'String'>
    readonly movieId: FieldRef<"MovieInteraction", 'Int'>
    readonly watched: FieldRef<"MovieInteraction", 'Boolean'>
    readonly watchlisted: FieldRef<"MovieInteraction", 'Boolean'>
    readonly favorited: FieldRef<"MovieInteraction", 'Boolean'>
    readonly ratingHalf: FieldRef<"MovieInteraction", 'Int'>
    readonly ratedAt: FieldRef<"MovieInteraction", 'DateTime'>
    readonly favoritedAt: FieldRef<"MovieInteraction", 'DateTime'>
    readonly watchedAt: FieldRef<"MovieInteraction", 'DateTime'>
    readonly updatedAt: FieldRef<"MovieInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieInteraction findUnique
   */
  export type MovieInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * Filter, which MovieInteraction to fetch.
     */
    where: MovieInteractionWhereUniqueInput
  }

  /**
   * MovieInteraction findUniqueOrThrow
   */
  export type MovieInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * Filter, which MovieInteraction to fetch.
     */
    where: MovieInteractionWhereUniqueInput
  }

  /**
   * MovieInteraction findFirst
   */
  export type MovieInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * Filter, which MovieInteraction to fetch.
     */
    where?: MovieInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieInteractions to fetch.
     */
    orderBy?: MovieInteractionOrderByWithRelationInput | MovieInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieInteractions.
     */
    cursor?: MovieInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieInteractions.
     */
    distinct?: MovieInteractionScalarFieldEnum | MovieInteractionScalarFieldEnum[]
  }

  /**
   * MovieInteraction findFirstOrThrow
   */
  export type MovieInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * Filter, which MovieInteraction to fetch.
     */
    where?: MovieInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieInteractions to fetch.
     */
    orderBy?: MovieInteractionOrderByWithRelationInput | MovieInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieInteractions.
     */
    cursor?: MovieInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieInteractions.
     */
    distinct?: MovieInteractionScalarFieldEnum | MovieInteractionScalarFieldEnum[]
  }

  /**
   * MovieInteraction findMany
   */
  export type MovieInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * Filter, which MovieInteractions to fetch.
     */
    where?: MovieInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieInteractions to fetch.
     */
    orderBy?: MovieInteractionOrderByWithRelationInput | MovieInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieInteractions.
     */
    cursor?: MovieInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieInteractions.
     */
    skip?: number
    distinct?: MovieInteractionScalarFieldEnum | MovieInteractionScalarFieldEnum[]
  }

  /**
   * MovieInteraction create
   */
  export type MovieInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieInteraction.
     */
    data: XOR<MovieInteractionCreateInput, MovieInteractionUncheckedCreateInput>
  }

  /**
   * MovieInteraction createMany
   */
  export type MovieInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieInteractions.
     */
    data: MovieInteractionCreateManyInput | MovieInteractionCreateManyInput[]
  }

  /**
   * MovieInteraction createManyAndReturn
   */
  export type MovieInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovieInteractions.
     */
    data: MovieInteractionCreateManyInput | MovieInteractionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieInteraction update
   */
  export type MovieInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieInteraction.
     */
    data: XOR<MovieInteractionUpdateInput, MovieInteractionUncheckedUpdateInput>
    /**
     * Choose, which MovieInteraction to update.
     */
    where: MovieInteractionWhereUniqueInput
  }

  /**
   * MovieInteraction updateMany
   */
  export type MovieInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieInteractions.
     */
    data: XOR<MovieInteractionUpdateManyMutationInput, MovieInteractionUncheckedUpdateManyInput>
    /**
     * Filter which MovieInteractions to update
     */
    where?: MovieInteractionWhereInput
  }

  /**
   * MovieInteraction upsert
   */
  export type MovieInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieInteraction to update in case it exists.
     */
    where: MovieInteractionWhereUniqueInput
    /**
     * In case the MovieInteraction found by the `where` argument doesn't exist, create a new MovieInteraction with this data.
     */
    create: XOR<MovieInteractionCreateInput, MovieInteractionUncheckedCreateInput>
    /**
     * In case the MovieInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieInteractionUpdateInput, MovieInteractionUncheckedUpdateInput>
  }

  /**
   * MovieInteraction delete
   */
  export type MovieInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    /**
     * Filter which MovieInteraction to delete.
     */
    where: MovieInteractionWhereUniqueInput
  }

  /**
   * MovieInteraction deleteMany
   */
  export type MovieInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieInteractions to delete
     */
    where?: MovieInteractionWhereInput
  }

  /**
   * MovieInteraction.movie
   */
  export type MovieInteraction$movieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    where?: MovieWhereInput
  }

  /**
   * MovieInteraction without action
   */
  export type MovieInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
  }


  /**
   * Model WatchLog
   */

  export type AggregateWatchLog = {
    _count: WatchLogCountAggregateOutputType | null
    _avg: WatchLogAvgAggregateOutputType | null
    _sum: WatchLogSumAggregateOutputType | null
    _min: WatchLogMinAggregateOutputType | null
    _max: WatchLogMaxAggregateOutputType | null
  }

  export type WatchLogAvgAggregateOutputType = {
    movieId: number | null
  }

  export type WatchLogSumAggregateOutputType = {
    movieId: number | null
  }

  export type WatchLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    movieId: number | null
    watchedAt: Date | null
    rewatch: boolean | null
    tags: string | null
    note: string | null
    importId: string | null
    importRowId: string | null
    createdAt: Date | null
  }

  export type WatchLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    movieId: number | null
    watchedAt: Date | null
    rewatch: boolean | null
    tags: string | null
    note: string | null
    importId: string | null
    importRowId: string | null
    createdAt: Date | null
  }

  export type WatchLogCountAggregateOutputType = {
    id: number
    userId: number
    movieId: number
    watchedAt: number
    rewatch: number
    tags: number
    note: number
    importId: number
    importRowId: number
    createdAt: number
    _all: number
  }


  export type WatchLogAvgAggregateInputType = {
    movieId?: true
  }

  export type WatchLogSumAggregateInputType = {
    movieId?: true
  }

  export type WatchLogMinAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    watchedAt?: true
    rewatch?: true
    tags?: true
    note?: true
    importId?: true
    importRowId?: true
    createdAt?: true
  }

  export type WatchLogMaxAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    watchedAt?: true
    rewatch?: true
    tags?: true
    note?: true
    importId?: true
    importRowId?: true
    createdAt?: true
  }

  export type WatchLogCountAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    watchedAt?: true
    rewatch?: true
    tags?: true
    note?: true
    importId?: true
    importRowId?: true
    createdAt?: true
    _all?: true
  }

  export type WatchLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchLog to aggregate.
     */
    where?: WatchLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchLogs to fetch.
     */
    orderBy?: WatchLogOrderByWithRelationInput | WatchLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchLogs
    **/
    _count?: true | WatchLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchLogMaxAggregateInputType
  }

  export type GetWatchLogAggregateType<T extends WatchLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchLog[P]>
      : GetScalarType<T[P], AggregateWatchLog[P]>
  }




  export type WatchLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchLogWhereInput
    orderBy?: WatchLogOrderByWithAggregationInput | WatchLogOrderByWithAggregationInput[]
    by: WatchLogScalarFieldEnum[] | WatchLogScalarFieldEnum
    having?: WatchLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchLogCountAggregateInputType | true
    _avg?: WatchLogAvgAggregateInputType
    _sum?: WatchLogSumAggregateInputType
    _min?: WatchLogMinAggregateInputType
    _max?: WatchLogMaxAggregateInputType
  }

  export type WatchLogGroupByOutputType = {
    id: string
    userId: string
    movieId: number
    watchedAt: Date
    rewatch: boolean
    tags: string | null
    note: string | null
    importId: string | null
    importRowId: string | null
    createdAt: Date
    _count: WatchLogCountAggregateOutputType | null
    _avg: WatchLogAvgAggregateOutputType | null
    _sum: WatchLogSumAggregateOutputType | null
    _min: WatchLogMinAggregateOutputType | null
    _max: WatchLogMaxAggregateOutputType | null
  }

  type GetWatchLogGroupByPayload<T extends WatchLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchLogGroupByOutputType[P]>
            : GetScalarType<T[P], WatchLogGroupByOutputType[P]>
        }
      >
    >


  export type WatchLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    movieId?: boolean
    watchedAt?: boolean
    rewatch?: boolean
    tags?: boolean
    note?: boolean
    importId?: boolean
    importRowId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    importRun?: boolean | WatchLog$importRunArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    review?: boolean | WatchLog$reviewArgs<ExtArgs>
  }, ExtArgs["result"]["watchLog"]>

  export type WatchLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    movieId?: boolean
    watchedAt?: boolean
    rewatch?: boolean
    tags?: boolean
    note?: boolean
    importId?: boolean
    importRowId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    importRun?: boolean | WatchLog$importRunArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchLog"]>

  export type WatchLogSelectScalar = {
    id?: boolean
    userId?: boolean
    movieId?: boolean
    watchedAt?: boolean
    rewatch?: boolean
    tags?: boolean
    note?: boolean
    importId?: boolean
    importRowId?: boolean
    createdAt?: boolean
  }

  export type WatchLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    importRun?: boolean | WatchLog$importRunArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
    review?: boolean | WatchLog$reviewArgs<ExtArgs>
  }
  export type WatchLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    importRun?: boolean | WatchLog$importRunArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $WatchLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      importRun: Prisma.$ImportRunPayload<ExtArgs> | null
      movie: Prisma.$MoviePayload<ExtArgs>
      review: Prisma.$ReviewPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      movieId: number
      watchedAt: Date
      rewatch: boolean
      tags: string | null
      note: string | null
      importId: string | null
      importRowId: string | null
      createdAt: Date
    }, ExtArgs["result"]["watchLog"]>
    composites: {}
  }

  type WatchLogGetPayload<S extends boolean | null | undefined | WatchLogDefaultArgs> = $Result.GetResult<Prisma.$WatchLogPayload, S>

  type WatchLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WatchLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WatchLogCountAggregateInputType | true
    }

  export interface WatchLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchLog'], meta: { name: 'WatchLog' } }
    /**
     * Find zero or one WatchLog that matches the filter.
     * @param {WatchLogFindUniqueArgs} args - Arguments to find a WatchLog
     * @example
     * // Get one WatchLog
     * const watchLog = await prisma.watchLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchLogFindUniqueArgs>(args: SelectSubset<T, WatchLogFindUniqueArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WatchLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WatchLogFindUniqueOrThrowArgs} args - Arguments to find a WatchLog
     * @example
     * // Get one WatchLog
     * const watchLog = await prisma.watchLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WatchLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchLogFindFirstArgs} args - Arguments to find a WatchLog
     * @example
     * // Get one WatchLog
     * const watchLog = await prisma.watchLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchLogFindFirstArgs>(args?: SelectSubset<T, WatchLogFindFirstArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WatchLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchLogFindFirstOrThrowArgs} args - Arguments to find a WatchLog
     * @example
     * // Get one WatchLog
     * const watchLog = await prisma.watchLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WatchLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchLogs
     * const watchLogs = await prisma.watchLog.findMany()
     * 
     * // Get first 10 WatchLogs
     * const watchLogs = await prisma.watchLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchLogWithIdOnly = await prisma.watchLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchLogFindManyArgs>(args?: SelectSubset<T, WatchLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WatchLog.
     * @param {WatchLogCreateArgs} args - Arguments to create a WatchLog.
     * @example
     * // Create one WatchLog
     * const WatchLog = await prisma.watchLog.create({
     *   data: {
     *     // ... data to create a WatchLog
     *   }
     * })
     * 
     */
    create<T extends WatchLogCreateArgs>(args: SelectSubset<T, WatchLogCreateArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WatchLogs.
     * @param {WatchLogCreateManyArgs} args - Arguments to create many WatchLogs.
     * @example
     * // Create many WatchLogs
     * const watchLog = await prisma.watchLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchLogCreateManyArgs>(args?: SelectSubset<T, WatchLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchLogs and returns the data saved in the database.
     * @param {WatchLogCreateManyAndReturnArgs} args - Arguments to create many WatchLogs.
     * @example
     * // Create many WatchLogs
     * const watchLog = await prisma.watchLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchLogs and only return the `id`
     * const watchLogWithIdOnly = await prisma.watchLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WatchLog.
     * @param {WatchLogDeleteArgs} args - Arguments to delete one WatchLog.
     * @example
     * // Delete one WatchLog
     * const WatchLog = await prisma.watchLog.delete({
     *   where: {
     *     // ... filter to delete one WatchLog
     *   }
     * })
     * 
     */
    delete<T extends WatchLogDeleteArgs>(args: SelectSubset<T, WatchLogDeleteArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WatchLog.
     * @param {WatchLogUpdateArgs} args - Arguments to update one WatchLog.
     * @example
     * // Update one WatchLog
     * const watchLog = await prisma.watchLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchLogUpdateArgs>(args: SelectSubset<T, WatchLogUpdateArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WatchLogs.
     * @param {WatchLogDeleteManyArgs} args - Arguments to filter WatchLogs to delete.
     * @example
     * // Delete a few WatchLogs
     * const { count } = await prisma.watchLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchLogDeleteManyArgs>(args?: SelectSubset<T, WatchLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchLogs
     * const watchLog = await prisma.watchLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchLogUpdateManyArgs>(args: SelectSubset<T, WatchLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WatchLog.
     * @param {WatchLogUpsertArgs} args - Arguments to update or create a WatchLog.
     * @example
     * // Update or create a WatchLog
     * const watchLog = await prisma.watchLog.upsert({
     *   create: {
     *     // ... data to create a WatchLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchLog we want to update
     *   }
     * })
     */
    upsert<T extends WatchLogUpsertArgs>(args: SelectSubset<T, WatchLogUpsertArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WatchLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchLogCountArgs} args - Arguments to filter WatchLogs to count.
     * @example
     * // Count the number of WatchLogs
     * const count = await prisma.watchLog.count({
     *   where: {
     *     // ... the filter for the WatchLogs we want to count
     *   }
     * })
    **/
    count<T extends WatchLogCountArgs>(
      args?: Subset<T, WatchLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchLogAggregateArgs>(args: Subset<T, WatchLogAggregateArgs>): Prisma.PrismaPromise<GetWatchLogAggregateType<T>>

    /**
     * Group by WatchLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchLogGroupByArgs['orderBy'] }
        : { orderBy?: WatchLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchLog model
   */
  readonly fields: WatchLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    importRun<T extends WatchLog$importRunArgs<ExtArgs> = {}>(args?: Subset<T, WatchLog$importRunArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    review<T extends WatchLog$reviewArgs<ExtArgs> = {}>(args?: Subset<T, WatchLog$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchLog model
   */ 
  interface WatchLogFieldRefs {
    readonly id: FieldRef<"WatchLog", 'String'>
    readonly userId: FieldRef<"WatchLog", 'String'>
    readonly movieId: FieldRef<"WatchLog", 'Int'>
    readonly watchedAt: FieldRef<"WatchLog", 'DateTime'>
    readonly rewatch: FieldRef<"WatchLog", 'Boolean'>
    readonly tags: FieldRef<"WatchLog", 'String'>
    readonly note: FieldRef<"WatchLog", 'String'>
    readonly importId: FieldRef<"WatchLog", 'String'>
    readonly importRowId: FieldRef<"WatchLog", 'String'>
    readonly createdAt: FieldRef<"WatchLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchLog findUnique
   */
  export type WatchLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * Filter, which WatchLog to fetch.
     */
    where: WatchLogWhereUniqueInput
  }

  /**
   * WatchLog findUniqueOrThrow
   */
  export type WatchLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * Filter, which WatchLog to fetch.
     */
    where: WatchLogWhereUniqueInput
  }

  /**
   * WatchLog findFirst
   */
  export type WatchLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * Filter, which WatchLog to fetch.
     */
    where?: WatchLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchLogs to fetch.
     */
    orderBy?: WatchLogOrderByWithRelationInput | WatchLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchLogs.
     */
    cursor?: WatchLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchLogs.
     */
    distinct?: WatchLogScalarFieldEnum | WatchLogScalarFieldEnum[]
  }

  /**
   * WatchLog findFirstOrThrow
   */
  export type WatchLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * Filter, which WatchLog to fetch.
     */
    where?: WatchLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchLogs to fetch.
     */
    orderBy?: WatchLogOrderByWithRelationInput | WatchLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchLogs.
     */
    cursor?: WatchLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchLogs.
     */
    distinct?: WatchLogScalarFieldEnum | WatchLogScalarFieldEnum[]
  }

  /**
   * WatchLog findMany
   */
  export type WatchLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * Filter, which WatchLogs to fetch.
     */
    where?: WatchLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchLogs to fetch.
     */
    orderBy?: WatchLogOrderByWithRelationInput | WatchLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchLogs.
     */
    cursor?: WatchLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchLogs.
     */
    skip?: number
    distinct?: WatchLogScalarFieldEnum | WatchLogScalarFieldEnum[]
  }

  /**
   * WatchLog create
   */
  export type WatchLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchLog.
     */
    data: XOR<WatchLogCreateInput, WatchLogUncheckedCreateInput>
  }

  /**
   * WatchLog createMany
   */
  export type WatchLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchLogs.
     */
    data: WatchLogCreateManyInput | WatchLogCreateManyInput[]
  }

  /**
   * WatchLog createManyAndReturn
   */
  export type WatchLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WatchLogs.
     */
    data: WatchLogCreateManyInput | WatchLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchLog update
   */
  export type WatchLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchLog.
     */
    data: XOR<WatchLogUpdateInput, WatchLogUncheckedUpdateInput>
    /**
     * Choose, which WatchLog to update.
     */
    where: WatchLogWhereUniqueInput
  }

  /**
   * WatchLog updateMany
   */
  export type WatchLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchLogs.
     */
    data: XOR<WatchLogUpdateManyMutationInput, WatchLogUncheckedUpdateManyInput>
    /**
     * Filter which WatchLogs to update
     */
    where?: WatchLogWhereInput
  }

  /**
   * WatchLog upsert
   */
  export type WatchLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchLog to update in case it exists.
     */
    where: WatchLogWhereUniqueInput
    /**
     * In case the WatchLog found by the `where` argument doesn't exist, create a new WatchLog with this data.
     */
    create: XOR<WatchLogCreateInput, WatchLogUncheckedCreateInput>
    /**
     * In case the WatchLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchLogUpdateInput, WatchLogUncheckedUpdateInput>
  }

  /**
   * WatchLog delete
   */
  export type WatchLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    /**
     * Filter which WatchLog to delete.
     */
    where: WatchLogWhereUniqueInput
  }

  /**
   * WatchLog deleteMany
   */
  export type WatchLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchLogs to delete
     */
    where?: WatchLogWhereInput
  }

  /**
   * WatchLog.importRun
   */
  export type WatchLog$importRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    where?: ImportRunWhereInput
  }

  /**
   * WatchLog.review
   */
  export type WatchLog$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }

  /**
   * WatchLog without action
   */
  export type WatchLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    movieId: number | null
    ratingHalf: number | null
  }

  export type ReviewSumAggregateOutputType = {
    movieId: number | null
    ratingHalf: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    movieId: number | null
    watchLogId: string | null
    bodyRaw: string | null
    bodyFormat: string | null
    ratingHalf: number | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    movieId: number | null
    watchLogId: string | null
    bodyRaw: string | null
    bodyFormat: string | null
    ratingHalf: number | null
    tags: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    movieId: number
    watchLogId: number
    bodyRaw: number
    bodyFormat: number
    ratingHalf: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    movieId?: true
    ratingHalf?: true
  }

  export type ReviewSumAggregateInputType = {
    movieId?: true
    ratingHalf?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    watchLogId?: true
    bodyRaw?: true
    bodyFormat?: true
    ratingHalf?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    watchLogId?: true
    bodyRaw?: true
    bodyFormat?: true
    ratingHalf?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    movieId?: true
    watchLogId?: true
    bodyRaw?: true
    bodyFormat?: true
    ratingHalf?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    movieId: number
    watchLogId: string | null
    bodyRaw: string
    bodyFormat: string
    ratingHalf: number | null
    tags: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    movieId?: boolean
    watchLogId?: boolean
    bodyRaw?: boolean
    bodyFormat?: boolean
    ratingHalf?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    watchLog?: boolean | Review$watchLogArgs<ExtArgs>
    comments?: boolean | Review$commentsArgs<ExtArgs>
    favorites?: boolean | Review$favoritesArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    movieId?: boolean
    watchLogId?: boolean
    bodyRaw?: boolean
    bodyFormat?: boolean
    ratingHalf?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    watchLog?: boolean | Review$watchLogArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    movieId?: boolean
    watchLogId?: boolean
    bodyRaw?: boolean
    bodyFormat?: boolean
    ratingHalf?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    watchLog?: boolean | Review$watchLogArgs<ExtArgs>
    comments?: boolean | Review$commentsArgs<ExtArgs>
    favorites?: boolean | Review$favoritesArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    watchLog?: boolean | Review$watchLogArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      watchLog: Prisma.$WatchLogPayload<ExtArgs> | null
      comments: Prisma.$ReviewCommentPayload<ExtArgs>[]
      favorites: Prisma.$ReviewFavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      movieId: number
      watchLogId: string | null
      bodyRaw: string
      bodyFormat: string
      ratingHalf: number | null
      tags: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    watchLog<T extends Review$watchLogArgs<ExtArgs> = {}>(args?: Subset<T, Review$watchLogArgs<ExtArgs>>): Prisma__WatchLogClient<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends Review$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Review$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findMany"> | Null>
    favorites<T extends Review$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Review$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly movieId: FieldRef<"Review", 'Int'>
    readonly watchLogId: FieldRef<"Review", 'String'>
    readonly bodyRaw: FieldRef<"Review", 'String'>
    readonly bodyFormat: FieldRef<"Review", 'String'>
    readonly ratingHalf: FieldRef<"Review", 'Int'>
    readonly tags: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review.watchLog
   */
  export type Review$watchLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    where?: WatchLogWhereInput
  }

  /**
   * Review.comments
   */
  export type Review$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    where?: ReviewCommentWhereInput
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    cursor?: ReviewCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * Review.favorites
   */
  export type Review$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    where?: ReviewFavoriteWhereInput
    orderBy?: ReviewFavoriteOrderByWithRelationInput | ReviewFavoriteOrderByWithRelationInput[]
    cursor?: ReviewFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewFavoriteScalarFieldEnum | ReviewFavoriteScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ReviewComment
   */

  export type AggregateReviewComment = {
    _count: ReviewCommentCountAggregateOutputType | null
    _min: ReviewCommentMinAggregateOutputType | null
    _max: ReviewCommentMaxAggregateOutputType | null
  }

  export type ReviewCommentMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    body: string | null
    createdAt: Date | null
  }

  export type ReviewCommentMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    body: string | null
    createdAt: Date | null
  }

  export type ReviewCommentCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    body: number
    createdAt: number
    _all: number
  }


  export type ReviewCommentMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    body?: true
    createdAt?: true
  }

  export type ReviewCommentMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    body?: true
    createdAt?: true
  }

  export type ReviewCommentCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    body?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewComment to aggregate.
     */
    where?: ReviewCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewComments to fetch.
     */
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewComments
    **/
    _count?: true | ReviewCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewCommentMaxAggregateInputType
  }

  export type GetReviewCommentAggregateType<T extends ReviewCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewComment[P]>
      : GetScalarType<T[P], AggregateReviewComment[P]>
  }




  export type ReviewCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewCommentWhereInput
    orderBy?: ReviewCommentOrderByWithAggregationInput | ReviewCommentOrderByWithAggregationInput[]
    by: ReviewCommentScalarFieldEnum[] | ReviewCommentScalarFieldEnum
    having?: ReviewCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCommentCountAggregateInputType | true
    _min?: ReviewCommentMinAggregateInputType
    _max?: ReviewCommentMaxAggregateInputType
  }

  export type ReviewCommentGroupByOutputType = {
    id: string
    reviewId: string
    userId: string
    body: string
    createdAt: Date
    _count: ReviewCommentCountAggregateOutputType | null
    _min: ReviewCommentMinAggregateOutputType | null
    _max: ReviewCommentMaxAggregateOutputType | null
  }

  type GetReviewCommentGroupByPayload<T extends ReviewCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewCommentGroupByOutputType[P]>
        }
      >
    >


  export type ReviewCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewComment"]>

  export type ReviewCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewComment"]>

  export type ReviewCommentSelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    body?: boolean
    createdAt?: boolean
  }

  export type ReviewCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewComment"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string
      body: string
      createdAt: Date
    }, ExtArgs["result"]["reviewComment"]>
    composites: {}
  }

  type ReviewCommentGetPayload<S extends boolean | null | undefined | ReviewCommentDefaultArgs> = $Result.GetResult<Prisma.$ReviewCommentPayload, S>

  type ReviewCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCommentCountAggregateInputType | true
    }

  export interface ReviewCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewComment'], meta: { name: 'ReviewComment' } }
    /**
     * Find zero or one ReviewComment that matches the filter.
     * @param {ReviewCommentFindUniqueArgs} args - Arguments to find a ReviewComment
     * @example
     * // Get one ReviewComment
     * const reviewComment = await prisma.reviewComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewCommentFindUniqueArgs>(args: SelectSubset<T, ReviewCommentFindUniqueArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReviewComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewCommentFindUniqueOrThrowArgs} args - Arguments to find a ReviewComment
     * @example
     * // Get one ReviewComment
     * const reviewComment = await prisma.reviewComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReviewComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentFindFirstArgs} args - Arguments to find a ReviewComment
     * @example
     * // Get one ReviewComment
     * const reviewComment = await prisma.reviewComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewCommentFindFirstArgs>(args?: SelectSubset<T, ReviewCommentFindFirstArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReviewComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentFindFirstOrThrowArgs} args - Arguments to find a ReviewComment
     * @example
     * // Get one ReviewComment
     * const reviewComment = await prisma.reviewComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReviewComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewComments
     * const reviewComments = await prisma.reviewComment.findMany()
     * 
     * // Get first 10 ReviewComments
     * const reviewComments = await prisma.reviewComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewCommentWithIdOnly = await prisma.reviewComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewCommentFindManyArgs>(args?: SelectSubset<T, ReviewCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReviewComment.
     * @param {ReviewCommentCreateArgs} args - Arguments to create a ReviewComment.
     * @example
     * // Create one ReviewComment
     * const ReviewComment = await prisma.reviewComment.create({
     *   data: {
     *     // ... data to create a ReviewComment
     *   }
     * })
     * 
     */
    create<T extends ReviewCommentCreateArgs>(args: SelectSubset<T, ReviewCommentCreateArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReviewComments.
     * @param {ReviewCommentCreateManyArgs} args - Arguments to create many ReviewComments.
     * @example
     * // Create many ReviewComments
     * const reviewComment = await prisma.reviewComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCommentCreateManyArgs>(args?: SelectSubset<T, ReviewCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewComments and returns the data saved in the database.
     * @param {ReviewCommentCreateManyAndReturnArgs} args - Arguments to create many ReviewComments.
     * @example
     * // Create many ReviewComments
     * const reviewComment = await prisma.reviewComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewComments and only return the `id`
     * const reviewCommentWithIdOnly = await prisma.reviewComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReviewComment.
     * @param {ReviewCommentDeleteArgs} args - Arguments to delete one ReviewComment.
     * @example
     * // Delete one ReviewComment
     * const ReviewComment = await prisma.reviewComment.delete({
     *   where: {
     *     // ... filter to delete one ReviewComment
     *   }
     * })
     * 
     */
    delete<T extends ReviewCommentDeleteArgs>(args: SelectSubset<T, ReviewCommentDeleteArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReviewComment.
     * @param {ReviewCommentUpdateArgs} args - Arguments to update one ReviewComment.
     * @example
     * // Update one ReviewComment
     * const reviewComment = await prisma.reviewComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewCommentUpdateArgs>(args: SelectSubset<T, ReviewCommentUpdateArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReviewComments.
     * @param {ReviewCommentDeleteManyArgs} args - Arguments to filter ReviewComments to delete.
     * @example
     * // Delete a few ReviewComments
     * const { count } = await prisma.reviewComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewCommentDeleteManyArgs>(args?: SelectSubset<T, ReviewCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewComments
     * const reviewComment = await prisma.reviewComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewCommentUpdateManyArgs>(args: SelectSubset<T, ReviewCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReviewComment.
     * @param {ReviewCommentUpsertArgs} args - Arguments to update or create a ReviewComment.
     * @example
     * // Update or create a ReviewComment
     * const reviewComment = await prisma.reviewComment.upsert({
     *   create: {
     *     // ... data to create a ReviewComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewComment we want to update
     *   }
     * })
     */
    upsert<T extends ReviewCommentUpsertArgs>(args: SelectSubset<T, ReviewCommentUpsertArgs<ExtArgs>>): Prisma__ReviewCommentClient<$Result.GetResult<Prisma.$ReviewCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReviewComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentCountArgs} args - Arguments to filter ReviewComments to count.
     * @example
     * // Count the number of ReviewComments
     * const count = await prisma.reviewComment.count({
     *   where: {
     *     // ... the filter for the ReviewComments we want to count
     *   }
     * })
    **/
    count<T extends ReviewCommentCountArgs>(
      args?: Subset<T, ReviewCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewCommentAggregateArgs>(args: Subset<T, ReviewCommentAggregateArgs>): Prisma.PrismaPromise<GetReviewCommentAggregateType<T>>

    /**
     * Group by ReviewComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewCommentGroupByArgs['orderBy'] }
        : { orderBy?: ReviewCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewComment model
   */
  readonly fields: ReviewCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewComment model
   */ 
  interface ReviewCommentFieldRefs {
    readonly id: FieldRef<"ReviewComment", 'String'>
    readonly reviewId: FieldRef<"ReviewComment", 'String'>
    readonly userId: FieldRef<"ReviewComment", 'String'>
    readonly body: FieldRef<"ReviewComment", 'String'>
    readonly createdAt: FieldRef<"ReviewComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewComment findUnique
   */
  export type ReviewCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComment to fetch.
     */
    where: ReviewCommentWhereUniqueInput
  }

  /**
   * ReviewComment findUniqueOrThrow
   */
  export type ReviewCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComment to fetch.
     */
    where: ReviewCommentWhereUniqueInput
  }

  /**
   * ReviewComment findFirst
   */
  export type ReviewCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComment to fetch.
     */
    where?: ReviewCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewComments to fetch.
     */
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewComments.
     */
    cursor?: ReviewCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewComments.
     */
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * ReviewComment findFirstOrThrow
   */
  export type ReviewCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComment to fetch.
     */
    where?: ReviewCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewComments to fetch.
     */
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewComments.
     */
    cursor?: ReviewCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewComments.
     */
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * ReviewComment findMany
   */
  export type ReviewCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReviewComments to fetch.
     */
    where?: ReviewCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewComments to fetch.
     */
    orderBy?: ReviewCommentOrderByWithRelationInput | ReviewCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewComments.
     */
    cursor?: ReviewCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewComments.
     */
    skip?: number
    distinct?: ReviewCommentScalarFieldEnum | ReviewCommentScalarFieldEnum[]
  }

  /**
   * ReviewComment create
   */
  export type ReviewCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewComment.
     */
    data: XOR<ReviewCommentCreateInput, ReviewCommentUncheckedCreateInput>
  }

  /**
   * ReviewComment createMany
   */
  export type ReviewCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewComments.
     */
    data: ReviewCommentCreateManyInput | ReviewCommentCreateManyInput[]
  }

  /**
   * ReviewComment createManyAndReturn
   */
  export type ReviewCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReviewComments.
     */
    data: ReviewCommentCreateManyInput | ReviewCommentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewComment update
   */
  export type ReviewCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewComment.
     */
    data: XOR<ReviewCommentUpdateInput, ReviewCommentUncheckedUpdateInput>
    /**
     * Choose, which ReviewComment to update.
     */
    where: ReviewCommentWhereUniqueInput
  }

  /**
   * ReviewComment updateMany
   */
  export type ReviewCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewComments.
     */
    data: XOR<ReviewCommentUpdateManyMutationInput, ReviewCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReviewComments to update
     */
    where?: ReviewCommentWhereInput
  }

  /**
   * ReviewComment upsert
   */
  export type ReviewCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewComment to update in case it exists.
     */
    where: ReviewCommentWhereUniqueInput
    /**
     * In case the ReviewComment found by the `where` argument doesn't exist, create a new ReviewComment with this data.
     */
    create: XOR<ReviewCommentCreateInput, ReviewCommentUncheckedCreateInput>
    /**
     * In case the ReviewComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewCommentUpdateInput, ReviewCommentUncheckedUpdateInput>
  }

  /**
   * ReviewComment delete
   */
  export type ReviewCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
    /**
     * Filter which ReviewComment to delete.
     */
    where: ReviewCommentWhereUniqueInput
  }

  /**
   * ReviewComment deleteMany
   */
  export type ReviewCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewComments to delete
     */
    where?: ReviewCommentWhereInput
  }

  /**
   * ReviewComment without action
   */
  export type ReviewCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewComment
     */
    select?: ReviewCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewCommentInclude<ExtArgs> | null
  }


  /**
   * Model ReviewFavorite
   */

  export type AggregateReviewFavorite = {
    _count: ReviewFavoriteCountAggregateOutputType | null
    _min: ReviewFavoriteMinAggregateOutputType | null
    _max: ReviewFavoriteMaxAggregateOutputType | null
  }

  export type ReviewFavoriteMinAggregateOutputType = {
    reviewId: string | null
    userId: string | null
  }

  export type ReviewFavoriteMaxAggregateOutputType = {
    reviewId: string | null
    userId: string | null
  }

  export type ReviewFavoriteCountAggregateOutputType = {
    reviewId: number
    userId: number
    _all: number
  }


  export type ReviewFavoriteMinAggregateInputType = {
    reviewId?: true
    userId?: true
  }

  export type ReviewFavoriteMaxAggregateInputType = {
    reviewId?: true
    userId?: true
  }

  export type ReviewFavoriteCountAggregateInputType = {
    reviewId?: true
    userId?: true
    _all?: true
  }

  export type ReviewFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewFavorite to aggregate.
     */
    where?: ReviewFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewFavorites to fetch.
     */
    orderBy?: ReviewFavoriteOrderByWithRelationInput | ReviewFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewFavorites
    **/
    _count?: true | ReviewFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewFavoriteMaxAggregateInputType
  }

  export type GetReviewFavoriteAggregateType<T extends ReviewFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewFavorite[P]>
      : GetScalarType<T[P], AggregateReviewFavorite[P]>
  }




  export type ReviewFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewFavoriteWhereInput
    orderBy?: ReviewFavoriteOrderByWithAggregationInput | ReviewFavoriteOrderByWithAggregationInput[]
    by: ReviewFavoriteScalarFieldEnum[] | ReviewFavoriteScalarFieldEnum
    having?: ReviewFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewFavoriteCountAggregateInputType | true
    _min?: ReviewFavoriteMinAggregateInputType
    _max?: ReviewFavoriteMaxAggregateInputType
  }

  export type ReviewFavoriteGroupByOutputType = {
    reviewId: string
    userId: string
    _count: ReviewFavoriteCountAggregateOutputType | null
    _min: ReviewFavoriteMinAggregateOutputType | null
    _max: ReviewFavoriteMaxAggregateOutputType | null
  }

  type GetReviewFavoriteGroupByPayload<T extends ReviewFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type ReviewFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reviewId?: boolean
    userId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewFavorite"]>

  export type ReviewFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reviewId?: boolean
    userId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewFavorite"]>

  export type ReviewFavoriteSelectScalar = {
    reviewId?: boolean
    userId?: boolean
  }

  export type ReviewFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewFavorite"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      reviewId: string
      userId: string
    }, ExtArgs["result"]["reviewFavorite"]>
    composites: {}
  }

  type ReviewFavoriteGetPayload<S extends boolean | null | undefined | ReviewFavoriteDefaultArgs> = $Result.GetResult<Prisma.$ReviewFavoritePayload, S>

  type ReviewFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFavoriteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewFavoriteCountAggregateInputType | true
    }

  export interface ReviewFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewFavorite'], meta: { name: 'ReviewFavorite' } }
    /**
     * Find zero or one ReviewFavorite that matches the filter.
     * @param {ReviewFavoriteFindUniqueArgs} args - Arguments to find a ReviewFavorite
     * @example
     * // Get one ReviewFavorite
     * const reviewFavorite = await prisma.reviewFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFavoriteFindUniqueArgs>(args: SelectSubset<T, ReviewFavoriteFindUniqueArgs<ExtArgs>>): Prisma__ReviewFavoriteClient<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReviewFavorite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFavoriteFindUniqueOrThrowArgs} args - Arguments to find a ReviewFavorite
     * @example
     * // Get one ReviewFavorite
     * const reviewFavorite = await prisma.reviewFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewFavoriteClient<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReviewFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFavoriteFindFirstArgs} args - Arguments to find a ReviewFavorite
     * @example
     * // Get one ReviewFavorite
     * const reviewFavorite = await prisma.reviewFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFavoriteFindFirstArgs>(args?: SelectSubset<T, ReviewFavoriteFindFirstArgs<ExtArgs>>): Prisma__ReviewFavoriteClient<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReviewFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFavoriteFindFirstOrThrowArgs} args - Arguments to find a ReviewFavorite
     * @example
     * // Get one ReviewFavorite
     * const reviewFavorite = await prisma.reviewFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewFavoriteClient<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReviewFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewFavorites
     * const reviewFavorites = await prisma.reviewFavorite.findMany()
     * 
     * // Get first 10 ReviewFavorites
     * const reviewFavorites = await prisma.reviewFavorite.findMany({ take: 10 })
     * 
     * // Only select the `reviewId`
     * const reviewFavoriteWithReviewIdOnly = await prisma.reviewFavorite.findMany({ select: { reviewId: true } })
     * 
     */
    findMany<T extends ReviewFavoriteFindManyArgs>(args?: SelectSubset<T, ReviewFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReviewFavorite.
     * @param {ReviewFavoriteCreateArgs} args - Arguments to create a ReviewFavorite.
     * @example
     * // Create one ReviewFavorite
     * const ReviewFavorite = await prisma.reviewFavorite.create({
     *   data: {
     *     // ... data to create a ReviewFavorite
     *   }
     * })
     * 
     */
    create<T extends ReviewFavoriteCreateArgs>(args: SelectSubset<T, ReviewFavoriteCreateArgs<ExtArgs>>): Prisma__ReviewFavoriteClient<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReviewFavorites.
     * @param {ReviewFavoriteCreateManyArgs} args - Arguments to create many ReviewFavorites.
     * @example
     * // Create many ReviewFavorites
     * const reviewFavorite = await prisma.reviewFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewFavoriteCreateManyArgs>(args?: SelectSubset<T, ReviewFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewFavorites and returns the data saved in the database.
     * @param {ReviewFavoriteCreateManyAndReturnArgs} args - Arguments to create many ReviewFavorites.
     * @example
     * // Create many ReviewFavorites
     * const reviewFavorite = await prisma.reviewFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewFavorites and only return the `reviewId`
     * const reviewFavoriteWithReviewIdOnly = await prisma.reviewFavorite.createManyAndReturn({ 
     *   select: { reviewId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReviewFavorite.
     * @param {ReviewFavoriteDeleteArgs} args - Arguments to delete one ReviewFavorite.
     * @example
     * // Delete one ReviewFavorite
     * const ReviewFavorite = await prisma.reviewFavorite.delete({
     *   where: {
     *     // ... filter to delete one ReviewFavorite
     *   }
     * })
     * 
     */
    delete<T extends ReviewFavoriteDeleteArgs>(args: SelectSubset<T, ReviewFavoriteDeleteArgs<ExtArgs>>): Prisma__ReviewFavoriteClient<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReviewFavorite.
     * @param {ReviewFavoriteUpdateArgs} args - Arguments to update one ReviewFavorite.
     * @example
     * // Update one ReviewFavorite
     * const reviewFavorite = await prisma.reviewFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewFavoriteUpdateArgs>(args: SelectSubset<T, ReviewFavoriteUpdateArgs<ExtArgs>>): Prisma__ReviewFavoriteClient<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReviewFavorites.
     * @param {ReviewFavoriteDeleteManyArgs} args - Arguments to filter ReviewFavorites to delete.
     * @example
     * // Delete a few ReviewFavorites
     * const { count } = await prisma.reviewFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewFavoriteDeleteManyArgs>(args?: SelectSubset<T, ReviewFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewFavorites
     * const reviewFavorite = await prisma.reviewFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewFavoriteUpdateManyArgs>(args: SelectSubset<T, ReviewFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReviewFavorite.
     * @param {ReviewFavoriteUpsertArgs} args - Arguments to update or create a ReviewFavorite.
     * @example
     * // Update or create a ReviewFavorite
     * const reviewFavorite = await prisma.reviewFavorite.upsert({
     *   create: {
     *     // ... data to create a ReviewFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewFavorite we want to update
     *   }
     * })
     */
    upsert<T extends ReviewFavoriteUpsertArgs>(args: SelectSubset<T, ReviewFavoriteUpsertArgs<ExtArgs>>): Prisma__ReviewFavoriteClient<$Result.GetResult<Prisma.$ReviewFavoritePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReviewFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFavoriteCountArgs} args - Arguments to filter ReviewFavorites to count.
     * @example
     * // Count the number of ReviewFavorites
     * const count = await prisma.reviewFavorite.count({
     *   where: {
     *     // ... the filter for the ReviewFavorites we want to count
     *   }
     * })
    **/
    count<T extends ReviewFavoriteCountArgs>(
      args?: Subset<T, ReviewFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewFavoriteAggregateArgs>(args: Subset<T, ReviewFavoriteAggregateArgs>): Prisma.PrismaPromise<GetReviewFavoriteAggregateType<T>>

    /**
     * Group by ReviewFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: ReviewFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewFavorite model
   */
  readonly fields: ReviewFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewFavorite model
   */ 
  interface ReviewFavoriteFieldRefs {
    readonly reviewId: FieldRef<"ReviewFavorite", 'String'>
    readonly userId: FieldRef<"ReviewFavorite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReviewFavorite findUnique
   */
  export type ReviewFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewFavorite to fetch.
     */
    where: ReviewFavoriteWhereUniqueInput
  }

  /**
   * ReviewFavorite findUniqueOrThrow
   */
  export type ReviewFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewFavorite to fetch.
     */
    where: ReviewFavoriteWhereUniqueInput
  }

  /**
   * ReviewFavorite findFirst
   */
  export type ReviewFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewFavorite to fetch.
     */
    where?: ReviewFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewFavorites to fetch.
     */
    orderBy?: ReviewFavoriteOrderByWithRelationInput | ReviewFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewFavorites.
     */
    cursor?: ReviewFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewFavorites.
     */
    distinct?: ReviewFavoriteScalarFieldEnum | ReviewFavoriteScalarFieldEnum[]
  }

  /**
   * ReviewFavorite findFirstOrThrow
   */
  export type ReviewFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewFavorite to fetch.
     */
    where?: ReviewFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewFavorites to fetch.
     */
    orderBy?: ReviewFavoriteOrderByWithRelationInput | ReviewFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewFavorites.
     */
    cursor?: ReviewFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewFavorites.
     */
    distinct?: ReviewFavoriteScalarFieldEnum | ReviewFavoriteScalarFieldEnum[]
  }

  /**
   * ReviewFavorite findMany
   */
  export type ReviewFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewFavorites to fetch.
     */
    where?: ReviewFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewFavorites to fetch.
     */
    orderBy?: ReviewFavoriteOrderByWithRelationInput | ReviewFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewFavorites.
     */
    cursor?: ReviewFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewFavorites.
     */
    skip?: number
    distinct?: ReviewFavoriteScalarFieldEnum | ReviewFavoriteScalarFieldEnum[]
  }

  /**
   * ReviewFavorite create
   */
  export type ReviewFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewFavorite.
     */
    data: XOR<ReviewFavoriteCreateInput, ReviewFavoriteUncheckedCreateInput>
  }

  /**
   * ReviewFavorite createMany
   */
  export type ReviewFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewFavorites.
     */
    data: ReviewFavoriteCreateManyInput | ReviewFavoriteCreateManyInput[]
  }

  /**
   * ReviewFavorite createManyAndReturn
   */
  export type ReviewFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReviewFavorites.
     */
    data: ReviewFavoriteCreateManyInput | ReviewFavoriteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewFavorite update
   */
  export type ReviewFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewFavorite.
     */
    data: XOR<ReviewFavoriteUpdateInput, ReviewFavoriteUncheckedUpdateInput>
    /**
     * Choose, which ReviewFavorite to update.
     */
    where: ReviewFavoriteWhereUniqueInput
  }

  /**
   * ReviewFavorite updateMany
   */
  export type ReviewFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewFavorites.
     */
    data: XOR<ReviewFavoriteUpdateManyMutationInput, ReviewFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewFavorites to update
     */
    where?: ReviewFavoriteWhereInput
  }

  /**
   * ReviewFavorite upsert
   */
  export type ReviewFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewFavorite to update in case it exists.
     */
    where: ReviewFavoriteWhereUniqueInput
    /**
     * In case the ReviewFavorite found by the `where` argument doesn't exist, create a new ReviewFavorite with this data.
     */
    create: XOR<ReviewFavoriteCreateInput, ReviewFavoriteUncheckedCreateInput>
    /**
     * In case the ReviewFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewFavoriteUpdateInput, ReviewFavoriteUncheckedUpdateInput>
  }

  /**
   * ReviewFavorite delete
   */
  export type ReviewFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
    /**
     * Filter which ReviewFavorite to delete.
     */
    where: ReviewFavoriteWhereUniqueInput
  }

  /**
   * ReviewFavorite deleteMany
   */
  export type ReviewFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewFavorites to delete
     */
    where?: ReviewFavoriteWhereInput
  }

  /**
   * ReviewFavorite without action
   */
  export type ReviewFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewFavorite
     */
    select?: ReviewFavoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model MovieList
   */

  export type AggregateMovieList = {
    _count: MovieListCountAggregateOutputType | null
    _min: MovieListMinAggregateOutputType | null
    _max: MovieListMaxAggregateOutputType | null
  }

  export type MovieListMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    tags: string | null
    isRanked: boolean | null
    isSystem: boolean | null
    systemKey: string | null
    isPublic: boolean | null
    sourceListId: string | null
    sourceType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieListMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    tags: string | null
    isRanked: boolean | null
    isSystem: boolean | null
    systemKey: string | null
    isPublic: boolean | null
    sourceListId: string | null
    sourceType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MovieListCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    tags: number
    isRanked: number
    isSystem: number
    systemKey: number
    isPublic: number
    sourceListId: number
    sourceType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MovieListMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    tags?: true
    isRanked?: true
    isSystem?: true
    systemKey?: true
    isPublic?: true
    sourceListId?: true
    sourceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieListMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    tags?: true
    isRanked?: true
    isSystem?: true
    systemKey?: true
    isPublic?: true
    sourceListId?: true
    sourceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MovieListCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    tags?: true
    isRanked?: true
    isSystem?: true
    systemKey?: true
    isPublic?: true
    sourceListId?: true
    sourceType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MovieListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieList to aggregate.
     */
    where?: MovieListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieLists to fetch.
     */
    orderBy?: MovieListOrderByWithRelationInput | MovieListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieLists
    **/
    _count?: true | MovieListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieListMaxAggregateInputType
  }

  export type GetMovieListAggregateType<T extends MovieListAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieList[P]>
      : GetScalarType<T[P], AggregateMovieList[P]>
  }




  export type MovieListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieListWhereInput
    orderBy?: MovieListOrderByWithAggregationInput | MovieListOrderByWithAggregationInput[]
    by: MovieListScalarFieldEnum[] | MovieListScalarFieldEnum
    having?: MovieListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieListCountAggregateInputType | true
    _min?: MovieListMinAggregateInputType
    _max?: MovieListMaxAggregateInputType
  }

  export type MovieListGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    tags: string | null
    isRanked: boolean
    isSystem: boolean
    systemKey: string | null
    isPublic: boolean
    sourceListId: string | null
    sourceType: string | null
    createdAt: Date
    updatedAt: Date
    _count: MovieListCountAggregateOutputType | null
    _min: MovieListMinAggregateOutputType | null
    _max: MovieListMaxAggregateOutputType | null
  }

  type GetMovieListGroupByPayload<T extends MovieListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieListGroupByOutputType[P]>
            : GetScalarType<T[P], MovieListGroupByOutputType[P]>
        }
      >
    >


  export type MovieListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: boolean
    isPublic?: boolean
    sourceListId?: boolean
    sourceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | MovieList$itemsArgs<ExtArgs>
    _count?: boolean | MovieListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieList"]>

  export type MovieListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: boolean
    isPublic?: boolean
    sourceListId?: boolean
    sourceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movieList"]>

  export type MovieListSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: boolean
    isPublic?: boolean
    sourceListId?: boolean
    sourceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MovieListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | MovieList$itemsArgs<ExtArgs>
    _count?: boolean | MovieListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MovieListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MovieListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieList"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$MovieListItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      tags: string | null
      isRanked: boolean
      isSystem: boolean
      systemKey: string | null
      isPublic: boolean
      sourceListId: string | null
      sourceType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["movieList"]>
    composites: {}
  }

  type MovieListGetPayload<S extends boolean | null | undefined | MovieListDefaultArgs> = $Result.GetResult<Prisma.$MovieListPayload, S>

  type MovieListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieListCountAggregateInputType | true
    }

  export interface MovieListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieList'], meta: { name: 'MovieList' } }
    /**
     * Find zero or one MovieList that matches the filter.
     * @param {MovieListFindUniqueArgs} args - Arguments to find a MovieList
     * @example
     * // Get one MovieList
     * const movieList = await prisma.movieList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieListFindUniqueArgs>(args: SelectSubset<T, MovieListFindUniqueArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieListFindUniqueOrThrowArgs} args - Arguments to find a MovieList
     * @example
     * // Get one MovieList
     * const movieList = await prisma.movieList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieListFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListFindFirstArgs} args - Arguments to find a MovieList
     * @example
     * // Get one MovieList
     * const movieList = await prisma.movieList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieListFindFirstArgs>(args?: SelectSubset<T, MovieListFindFirstArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListFindFirstOrThrowArgs} args - Arguments to find a MovieList
     * @example
     * // Get one MovieList
     * const movieList = await prisma.movieList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieListFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieListFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieLists
     * const movieLists = await prisma.movieList.findMany()
     * 
     * // Get first 10 MovieLists
     * const movieLists = await prisma.movieList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieListWithIdOnly = await prisma.movieList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovieListFindManyArgs>(args?: SelectSubset<T, MovieListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieList.
     * @param {MovieListCreateArgs} args - Arguments to create a MovieList.
     * @example
     * // Create one MovieList
     * const MovieList = await prisma.movieList.create({
     *   data: {
     *     // ... data to create a MovieList
     *   }
     * })
     * 
     */
    create<T extends MovieListCreateArgs>(args: SelectSubset<T, MovieListCreateArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieLists.
     * @param {MovieListCreateManyArgs} args - Arguments to create many MovieLists.
     * @example
     * // Create many MovieLists
     * const movieList = await prisma.movieList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieListCreateManyArgs>(args?: SelectSubset<T, MovieListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieLists and returns the data saved in the database.
     * @param {MovieListCreateManyAndReturnArgs} args - Arguments to create many MovieLists.
     * @example
     * // Create many MovieLists
     * const movieList = await prisma.movieList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieLists and only return the `id`
     * const movieListWithIdOnly = await prisma.movieList.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieListCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovieList.
     * @param {MovieListDeleteArgs} args - Arguments to delete one MovieList.
     * @example
     * // Delete one MovieList
     * const MovieList = await prisma.movieList.delete({
     *   where: {
     *     // ... filter to delete one MovieList
     *   }
     * })
     * 
     */
    delete<T extends MovieListDeleteArgs>(args: SelectSubset<T, MovieListDeleteArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieList.
     * @param {MovieListUpdateArgs} args - Arguments to update one MovieList.
     * @example
     * // Update one MovieList
     * const movieList = await prisma.movieList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieListUpdateArgs>(args: SelectSubset<T, MovieListUpdateArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieLists.
     * @param {MovieListDeleteManyArgs} args - Arguments to filter MovieLists to delete.
     * @example
     * // Delete a few MovieLists
     * const { count } = await prisma.movieList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieListDeleteManyArgs>(args?: SelectSubset<T, MovieListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieLists
     * const movieList = await prisma.movieList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieListUpdateManyArgs>(args: SelectSubset<T, MovieListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieList.
     * @param {MovieListUpsertArgs} args - Arguments to update or create a MovieList.
     * @example
     * // Update or create a MovieList
     * const movieList = await prisma.movieList.upsert({
     *   create: {
     *     // ... data to create a MovieList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieList we want to update
     *   }
     * })
     */
    upsert<T extends MovieListUpsertArgs>(args: SelectSubset<T, MovieListUpsertArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListCountArgs} args - Arguments to filter MovieLists to count.
     * @example
     * // Count the number of MovieLists
     * const count = await prisma.movieList.count({
     *   where: {
     *     // ... the filter for the MovieLists we want to count
     *   }
     * })
    **/
    count<T extends MovieListCountArgs>(
      args?: Subset<T, MovieListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieListAggregateArgs>(args: Subset<T, MovieListAggregateArgs>): Prisma.PrismaPromise<GetMovieListAggregateType<T>>

    /**
     * Group by MovieList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieListGroupByArgs['orderBy'] }
        : { orderBy?: MovieListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieList model
   */
  readonly fields: MovieListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends MovieList$itemsArgs<ExtArgs> = {}>(args?: Subset<T, MovieList$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieList model
   */ 
  interface MovieListFieldRefs {
    readonly id: FieldRef<"MovieList", 'String'>
    readonly userId: FieldRef<"MovieList", 'String'>
    readonly title: FieldRef<"MovieList", 'String'>
    readonly description: FieldRef<"MovieList", 'String'>
    readonly tags: FieldRef<"MovieList", 'String'>
    readonly isRanked: FieldRef<"MovieList", 'Boolean'>
    readonly isSystem: FieldRef<"MovieList", 'Boolean'>
    readonly systemKey: FieldRef<"MovieList", 'String'>
    readonly isPublic: FieldRef<"MovieList", 'Boolean'>
    readonly sourceListId: FieldRef<"MovieList", 'String'>
    readonly sourceType: FieldRef<"MovieList", 'String'>
    readonly createdAt: FieldRef<"MovieList", 'DateTime'>
    readonly updatedAt: FieldRef<"MovieList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieList findUnique
   */
  export type MovieListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * Filter, which MovieList to fetch.
     */
    where: MovieListWhereUniqueInput
  }

  /**
   * MovieList findUniqueOrThrow
   */
  export type MovieListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * Filter, which MovieList to fetch.
     */
    where: MovieListWhereUniqueInput
  }

  /**
   * MovieList findFirst
   */
  export type MovieListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * Filter, which MovieList to fetch.
     */
    where?: MovieListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieLists to fetch.
     */
    orderBy?: MovieListOrderByWithRelationInput | MovieListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieLists.
     */
    cursor?: MovieListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieLists.
     */
    distinct?: MovieListScalarFieldEnum | MovieListScalarFieldEnum[]
  }

  /**
   * MovieList findFirstOrThrow
   */
  export type MovieListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * Filter, which MovieList to fetch.
     */
    where?: MovieListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieLists to fetch.
     */
    orderBy?: MovieListOrderByWithRelationInput | MovieListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieLists.
     */
    cursor?: MovieListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieLists.
     */
    distinct?: MovieListScalarFieldEnum | MovieListScalarFieldEnum[]
  }

  /**
   * MovieList findMany
   */
  export type MovieListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * Filter, which MovieLists to fetch.
     */
    where?: MovieListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieLists to fetch.
     */
    orderBy?: MovieListOrderByWithRelationInput | MovieListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieLists.
     */
    cursor?: MovieListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieLists.
     */
    skip?: number
    distinct?: MovieListScalarFieldEnum | MovieListScalarFieldEnum[]
  }

  /**
   * MovieList create
   */
  export type MovieListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieList.
     */
    data: XOR<MovieListCreateInput, MovieListUncheckedCreateInput>
  }

  /**
   * MovieList createMany
   */
  export type MovieListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieLists.
     */
    data: MovieListCreateManyInput | MovieListCreateManyInput[]
  }

  /**
   * MovieList createManyAndReturn
   */
  export type MovieListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovieLists.
     */
    data: MovieListCreateManyInput | MovieListCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieList update
   */
  export type MovieListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieList.
     */
    data: XOR<MovieListUpdateInput, MovieListUncheckedUpdateInput>
    /**
     * Choose, which MovieList to update.
     */
    where: MovieListWhereUniqueInput
  }

  /**
   * MovieList updateMany
   */
  export type MovieListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieLists.
     */
    data: XOR<MovieListUpdateManyMutationInput, MovieListUncheckedUpdateManyInput>
    /**
     * Filter which MovieLists to update
     */
    where?: MovieListWhereInput
  }

  /**
   * MovieList upsert
   */
  export type MovieListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieList to update in case it exists.
     */
    where: MovieListWhereUniqueInput
    /**
     * In case the MovieList found by the `where` argument doesn't exist, create a new MovieList with this data.
     */
    create: XOR<MovieListCreateInput, MovieListUncheckedCreateInput>
    /**
     * In case the MovieList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieListUpdateInput, MovieListUncheckedUpdateInput>
  }

  /**
   * MovieList delete
   */
  export type MovieListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
    /**
     * Filter which MovieList to delete.
     */
    where: MovieListWhereUniqueInput
  }

  /**
   * MovieList deleteMany
   */
  export type MovieListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieLists to delete
     */
    where?: MovieListWhereInput
  }

  /**
   * MovieList.items
   */
  export type MovieList$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    where?: MovieListItemWhereInput
    orderBy?: MovieListItemOrderByWithRelationInput | MovieListItemOrderByWithRelationInput[]
    cursor?: MovieListItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieListItemScalarFieldEnum | MovieListItemScalarFieldEnum[]
  }

  /**
   * MovieList without action
   */
  export type MovieListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieList
     */
    select?: MovieListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListInclude<ExtArgs> | null
  }


  /**
   * Model MovieListItem
   */

  export type AggregateMovieListItem = {
    _count: MovieListItemCountAggregateOutputType | null
    _avg: MovieListItemAvgAggregateOutputType | null
    _sum: MovieListItemSumAggregateOutputType | null
    _min: MovieListItemMinAggregateOutputType | null
    _max: MovieListItemMaxAggregateOutputType | null
  }

  export type MovieListItemAvgAggregateOutputType = {
    movieId: number | null
    position: number | null
  }

  export type MovieListItemSumAggregateOutputType = {
    movieId: number | null
    position: number | null
  }

  export type MovieListItemMinAggregateOutputType = {
    listId: string | null
    movieId: number | null
    position: number | null
    note: string | null
    addedAt: Date | null
  }

  export type MovieListItemMaxAggregateOutputType = {
    listId: string | null
    movieId: number | null
    position: number | null
    note: string | null
    addedAt: Date | null
  }

  export type MovieListItemCountAggregateOutputType = {
    listId: number
    movieId: number
    position: number
    note: number
    addedAt: number
    _all: number
  }


  export type MovieListItemAvgAggregateInputType = {
    movieId?: true
    position?: true
  }

  export type MovieListItemSumAggregateInputType = {
    movieId?: true
    position?: true
  }

  export type MovieListItemMinAggregateInputType = {
    listId?: true
    movieId?: true
    position?: true
    note?: true
    addedAt?: true
  }

  export type MovieListItemMaxAggregateInputType = {
    listId?: true
    movieId?: true
    position?: true
    note?: true
    addedAt?: true
  }

  export type MovieListItemCountAggregateInputType = {
    listId?: true
    movieId?: true
    position?: true
    note?: true
    addedAt?: true
    _all?: true
  }

  export type MovieListItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieListItem to aggregate.
     */
    where?: MovieListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieListItems to fetch.
     */
    orderBy?: MovieListItemOrderByWithRelationInput | MovieListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MovieListItems
    **/
    _count?: true | MovieListItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieListItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieListItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieListItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieListItemMaxAggregateInputType
  }

  export type GetMovieListItemAggregateType<T extends MovieListItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMovieListItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovieListItem[P]>
      : GetScalarType<T[P], AggregateMovieListItem[P]>
  }




  export type MovieListItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieListItemWhereInput
    orderBy?: MovieListItemOrderByWithAggregationInput | MovieListItemOrderByWithAggregationInput[]
    by: MovieListItemScalarFieldEnum[] | MovieListItemScalarFieldEnum
    having?: MovieListItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieListItemCountAggregateInputType | true
    _avg?: MovieListItemAvgAggregateInputType
    _sum?: MovieListItemSumAggregateInputType
    _min?: MovieListItemMinAggregateInputType
    _max?: MovieListItemMaxAggregateInputType
  }

  export type MovieListItemGroupByOutputType = {
    listId: string
    movieId: number
    position: number | null
    note: string | null
    addedAt: Date
    _count: MovieListItemCountAggregateOutputType | null
    _avg: MovieListItemAvgAggregateOutputType | null
    _sum: MovieListItemSumAggregateOutputType | null
    _min: MovieListItemMinAggregateOutputType | null
    _max: MovieListItemMaxAggregateOutputType | null
  }

  type GetMovieListItemGroupByPayload<T extends MovieListItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieListItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieListItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieListItemGroupByOutputType[P]>
            : GetScalarType<T[P], MovieListItemGroupByOutputType[P]>
        }
      >
    >


  export type MovieListItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    listId?: boolean
    movieId?: boolean
    position?: boolean
    note?: boolean
    addedAt?: boolean
    list?: boolean | MovieListDefaultArgs<ExtArgs>
    movie?: boolean | MovieListItem$movieArgs<ExtArgs>
  }, ExtArgs["result"]["movieListItem"]>

  export type MovieListItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    listId?: boolean
    movieId?: boolean
    position?: boolean
    note?: boolean
    addedAt?: boolean
    list?: boolean | MovieListDefaultArgs<ExtArgs>
    movie?: boolean | MovieListItem$movieArgs<ExtArgs>
  }, ExtArgs["result"]["movieListItem"]>

  export type MovieListItemSelectScalar = {
    listId?: boolean
    movieId?: boolean
    position?: boolean
    note?: boolean
    addedAt?: boolean
  }

  export type MovieListItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | MovieListDefaultArgs<ExtArgs>
    movie?: boolean | MovieListItem$movieArgs<ExtArgs>
  }
  export type MovieListItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    list?: boolean | MovieListDefaultArgs<ExtArgs>
    movie?: boolean | MovieListItem$movieArgs<ExtArgs>
  }

  export type $MovieListItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MovieListItem"
    objects: {
      list: Prisma.$MovieListPayload<ExtArgs>
      movie: Prisma.$MoviePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      listId: string
      movieId: number
      position: number | null
      note: string | null
      addedAt: Date
    }, ExtArgs["result"]["movieListItem"]>
    composites: {}
  }

  type MovieListItemGetPayload<S extends boolean | null | undefined | MovieListItemDefaultArgs> = $Result.GetResult<Prisma.$MovieListItemPayload, S>

  type MovieListItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieListItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieListItemCountAggregateInputType | true
    }

  export interface MovieListItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MovieListItem'], meta: { name: 'MovieListItem' } }
    /**
     * Find zero or one MovieListItem that matches the filter.
     * @param {MovieListItemFindUniqueArgs} args - Arguments to find a MovieListItem
     * @example
     * // Get one MovieListItem
     * const movieListItem = await prisma.movieListItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieListItemFindUniqueArgs>(args: SelectSubset<T, MovieListItemFindUniqueArgs<ExtArgs>>): Prisma__MovieListItemClient<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MovieListItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieListItemFindUniqueOrThrowArgs} args - Arguments to find a MovieListItem
     * @example
     * // Get one MovieListItem
     * const movieListItem = await prisma.movieListItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieListItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieListItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieListItemClient<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MovieListItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListItemFindFirstArgs} args - Arguments to find a MovieListItem
     * @example
     * // Get one MovieListItem
     * const movieListItem = await prisma.movieListItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieListItemFindFirstArgs>(args?: SelectSubset<T, MovieListItemFindFirstArgs<ExtArgs>>): Prisma__MovieListItemClient<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MovieListItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListItemFindFirstOrThrowArgs} args - Arguments to find a MovieListItem
     * @example
     * // Get one MovieListItem
     * const movieListItem = await prisma.movieListItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieListItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieListItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieListItemClient<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MovieListItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MovieListItems
     * const movieListItems = await prisma.movieListItem.findMany()
     * 
     * // Get first 10 MovieListItems
     * const movieListItems = await prisma.movieListItem.findMany({ take: 10 })
     * 
     * // Only select the `listId`
     * const movieListItemWithListIdOnly = await prisma.movieListItem.findMany({ select: { listId: true } })
     * 
     */
    findMany<T extends MovieListItemFindManyArgs>(args?: SelectSubset<T, MovieListItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MovieListItem.
     * @param {MovieListItemCreateArgs} args - Arguments to create a MovieListItem.
     * @example
     * // Create one MovieListItem
     * const MovieListItem = await prisma.movieListItem.create({
     *   data: {
     *     // ... data to create a MovieListItem
     *   }
     * })
     * 
     */
    create<T extends MovieListItemCreateArgs>(args: SelectSubset<T, MovieListItemCreateArgs<ExtArgs>>): Prisma__MovieListItemClient<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MovieListItems.
     * @param {MovieListItemCreateManyArgs} args - Arguments to create many MovieListItems.
     * @example
     * // Create many MovieListItems
     * const movieListItem = await prisma.movieListItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieListItemCreateManyArgs>(args?: SelectSubset<T, MovieListItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MovieListItems and returns the data saved in the database.
     * @param {MovieListItemCreateManyAndReturnArgs} args - Arguments to create many MovieListItems.
     * @example
     * // Create many MovieListItems
     * const movieListItem = await prisma.movieListItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MovieListItems and only return the `listId`
     * const movieListItemWithListIdOnly = await prisma.movieListItem.createManyAndReturn({ 
     *   select: { listId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieListItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieListItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MovieListItem.
     * @param {MovieListItemDeleteArgs} args - Arguments to delete one MovieListItem.
     * @example
     * // Delete one MovieListItem
     * const MovieListItem = await prisma.movieListItem.delete({
     *   where: {
     *     // ... filter to delete one MovieListItem
     *   }
     * })
     * 
     */
    delete<T extends MovieListItemDeleteArgs>(args: SelectSubset<T, MovieListItemDeleteArgs<ExtArgs>>): Prisma__MovieListItemClient<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MovieListItem.
     * @param {MovieListItemUpdateArgs} args - Arguments to update one MovieListItem.
     * @example
     * // Update one MovieListItem
     * const movieListItem = await prisma.movieListItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieListItemUpdateArgs>(args: SelectSubset<T, MovieListItemUpdateArgs<ExtArgs>>): Prisma__MovieListItemClient<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MovieListItems.
     * @param {MovieListItemDeleteManyArgs} args - Arguments to filter MovieListItems to delete.
     * @example
     * // Delete a few MovieListItems
     * const { count } = await prisma.movieListItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieListItemDeleteManyArgs>(args?: SelectSubset<T, MovieListItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MovieListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MovieListItems
     * const movieListItem = await prisma.movieListItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieListItemUpdateManyArgs>(args: SelectSubset<T, MovieListItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MovieListItem.
     * @param {MovieListItemUpsertArgs} args - Arguments to update or create a MovieListItem.
     * @example
     * // Update or create a MovieListItem
     * const movieListItem = await prisma.movieListItem.upsert({
     *   create: {
     *     // ... data to create a MovieListItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MovieListItem we want to update
     *   }
     * })
     */
    upsert<T extends MovieListItemUpsertArgs>(args: SelectSubset<T, MovieListItemUpsertArgs<ExtArgs>>): Prisma__MovieListItemClient<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MovieListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListItemCountArgs} args - Arguments to filter MovieListItems to count.
     * @example
     * // Count the number of MovieListItems
     * const count = await prisma.movieListItem.count({
     *   where: {
     *     // ... the filter for the MovieListItems we want to count
     *   }
     * })
    **/
    count<T extends MovieListItemCountArgs>(
      args?: Subset<T, MovieListItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieListItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MovieListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieListItemAggregateArgs>(args: Subset<T, MovieListItemAggregateArgs>): Prisma.PrismaPromise<GetMovieListItemAggregateType<T>>

    /**
     * Group by MovieListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieListItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieListItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieListItemGroupByArgs['orderBy'] }
        : { orderBy?: MovieListItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieListItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieListItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MovieListItem model
   */
  readonly fields: MovieListItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MovieListItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieListItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    list<T extends MovieListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieListDefaultArgs<ExtArgs>>): Prisma__MovieListClient<$Result.GetResult<Prisma.$MovieListPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movie<T extends MovieListItem$movieArgs<ExtArgs> = {}>(args?: Subset<T, MovieListItem$movieArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MovieListItem model
   */ 
  interface MovieListItemFieldRefs {
    readonly listId: FieldRef<"MovieListItem", 'String'>
    readonly movieId: FieldRef<"MovieListItem", 'Int'>
    readonly position: FieldRef<"MovieListItem", 'Int'>
    readonly note: FieldRef<"MovieListItem", 'String'>
    readonly addedAt: FieldRef<"MovieListItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MovieListItem findUnique
   */
  export type MovieListItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * Filter, which MovieListItem to fetch.
     */
    where: MovieListItemWhereUniqueInput
  }

  /**
   * MovieListItem findUniqueOrThrow
   */
  export type MovieListItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * Filter, which MovieListItem to fetch.
     */
    where: MovieListItemWhereUniqueInput
  }

  /**
   * MovieListItem findFirst
   */
  export type MovieListItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * Filter, which MovieListItem to fetch.
     */
    where?: MovieListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieListItems to fetch.
     */
    orderBy?: MovieListItemOrderByWithRelationInput | MovieListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieListItems.
     */
    cursor?: MovieListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieListItems.
     */
    distinct?: MovieListItemScalarFieldEnum | MovieListItemScalarFieldEnum[]
  }

  /**
   * MovieListItem findFirstOrThrow
   */
  export type MovieListItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * Filter, which MovieListItem to fetch.
     */
    where?: MovieListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieListItems to fetch.
     */
    orderBy?: MovieListItemOrderByWithRelationInput | MovieListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MovieListItems.
     */
    cursor?: MovieListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MovieListItems.
     */
    distinct?: MovieListItemScalarFieldEnum | MovieListItemScalarFieldEnum[]
  }

  /**
   * MovieListItem findMany
   */
  export type MovieListItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * Filter, which MovieListItems to fetch.
     */
    where?: MovieListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MovieListItems to fetch.
     */
    orderBy?: MovieListItemOrderByWithRelationInput | MovieListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MovieListItems.
     */
    cursor?: MovieListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MovieListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MovieListItems.
     */
    skip?: number
    distinct?: MovieListItemScalarFieldEnum | MovieListItemScalarFieldEnum[]
  }

  /**
   * MovieListItem create
   */
  export type MovieListItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MovieListItem.
     */
    data: XOR<MovieListItemCreateInput, MovieListItemUncheckedCreateInput>
  }

  /**
   * MovieListItem createMany
   */
  export type MovieListItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MovieListItems.
     */
    data: MovieListItemCreateManyInput | MovieListItemCreateManyInput[]
  }

  /**
   * MovieListItem createManyAndReturn
   */
  export type MovieListItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MovieListItems.
     */
    data: MovieListItemCreateManyInput | MovieListItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MovieListItem update
   */
  export type MovieListItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MovieListItem.
     */
    data: XOR<MovieListItemUpdateInput, MovieListItemUncheckedUpdateInput>
    /**
     * Choose, which MovieListItem to update.
     */
    where: MovieListItemWhereUniqueInput
  }

  /**
   * MovieListItem updateMany
   */
  export type MovieListItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MovieListItems.
     */
    data: XOR<MovieListItemUpdateManyMutationInput, MovieListItemUncheckedUpdateManyInput>
    /**
     * Filter which MovieListItems to update
     */
    where?: MovieListItemWhereInput
  }

  /**
   * MovieListItem upsert
   */
  export type MovieListItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MovieListItem to update in case it exists.
     */
    where: MovieListItemWhereUniqueInput
    /**
     * In case the MovieListItem found by the `where` argument doesn't exist, create a new MovieListItem with this data.
     */
    create: XOR<MovieListItemCreateInput, MovieListItemUncheckedCreateInput>
    /**
     * In case the MovieListItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieListItemUpdateInput, MovieListItemUncheckedUpdateInput>
  }

  /**
   * MovieListItem delete
   */
  export type MovieListItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    /**
     * Filter which MovieListItem to delete.
     */
    where: MovieListItemWhereUniqueInput
  }

  /**
   * MovieListItem deleteMany
   */
  export type MovieListItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MovieListItems to delete
     */
    where?: MovieListItemWhereInput
  }

  /**
   * MovieListItem.movie
   */
  export type MovieListItem$movieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    where?: MovieWhereInput
  }

  /**
   * MovieListItem without action
   */
  export type MovieListItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
  }


  /**
   * Model ImportRun
   */

  export type AggregateImportRun = {
    _count: ImportRunCountAggregateOutputType | null
    _min: ImportRunMinAggregateOutputType | null
    _max: ImportRunMaxAggregateOutputType | null
  }

  export type ImportRunMinAggregateOutputType = {
    id: string | null
    userId: string | null
    source: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportRunMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    source: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportRunCountAggregateOutputType = {
    id: number
    userId: number
    source: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImportRunMinAggregateInputType = {
    id?: true
    userId?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportRunMaxAggregateInputType = {
    id?: true
    userId?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportRunCountAggregateInputType = {
    id?: true
    userId?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImportRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportRun to aggregate.
     */
    where?: ImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportRuns to fetch.
     */
    orderBy?: ImportRunOrderByWithRelationInput | ImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportRuns
    **/
    _count?: true | ImportRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportRunMaxAggregateInputType
  }

  export type GetImportRunAggregateType<T extends ImportRunAggregateArgs> = {
        [P in keyof T & keyof AggregateImportRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportRun[P]>
      : GetScalarType<T[P], AggregateImportRun[P]>
  }




  export type ImportRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportRunWhereInput
    orderBy?: ImportRunOrderByWithAggregationInput | ImportRunOrderByWithAggregationInput[]
    by: ImportRunScalarFieldEnum[] | ImportRunScalarFieldEnum
    having?: ImportRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportRunCountAggregateInputType | true
    _min?: ImportRunMinAggregateInputType
    _max?: ImportRunMaxAggregateInputType
  }

  export type ImportRunGroupByOutputType = {
    id: string
    userId: string
    source: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ImportRunCountAggregateOutputType | null
    _min: ImportRunMinAggregateOutputType | null
    _max: ImportRunMaxAggregateOutputType | null
  }

  type GetImportRunGroupByPayload<T extends ImportRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportRunGroupByOutputType[P]>
            : GetScalarType<T[P], ImportRunGroupByOutputType[P]>
        }
      >
    >


  export type ImportRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    auditRows?: boolean | ImportRun$auditRowsArgs<ExtArgs>
    watchLogs?: boolean | ImportRun$watchLogsArgs<ExtArgs>
    _count?: boolean | ImportRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importRun"]>

  export type ImportRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importRun"]>

  export type ImportRunSelectScalar = {
    id?: boolean
    userId?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImportRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    auditRows?: boolean | ImportRun$auditRowsArgs<ExtArgs>
    watchLogs?: boolean | ImportRun$watchLogsArgs<ExtArgs>
    _count?: boolean | ImportRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImportRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ImportRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportRun"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      auditRows: Prisma.$ImportAuditRowPayload<ExtArgs>[]
      watchLogs: Prisma.$WatchLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      source: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["importRun"]>
    composites: {}
  }

  type ImportRunGetPayload<S extends boolean | null | undefined | ImportRunDefaultArgs> = $Result.GetResult<Prisma.$ImportRunPayload, S>

  type ImportRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportRunFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportRunCountAggregateInputType | true
    }

  export interface ImportRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportRun'], meta: { name: 'ImportRun' } }
    /**
     * Find zero or one ImportRun that matches the filter.
     * @param {ImportRunFindUniqueArgs} args - Arguments to find a ImportRun
     * @example
     * // Get one ImportRun
     * const importRun = await prisma.importRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportRunFindUniqueArgs>(args: SelectSubset<T, ImportRunFindUniqueArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportRun that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportRunFindUniqueOrThrowArgs} args - Arguments to find a ImportRun
     * @example
     * // Get one ImportRun
     * const importRun = await prisma.importRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportRunFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportRunFindFirstArgs} args - Arguments to find a ImportRun
     * @example
     * // Get one ImportRun
     * const importRun = await prisma.importRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportRunFindFirstArgs>(args?: SelectSubset<T, ImportRunFindFirstArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportRunFindFirstOrThrowArgs} args - Arguments to find a ImportRun
     * @example
     * // Get one ImportRun
     * const importRun = await prisma.importRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportRunFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportRuns
     * const importRuns = await prisma.importRun.findMany()
     * 
     * // Get first 10 ImportRuns
     * const importRuns = await prisma.importRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importRunWithIdOnly = await prisma.importRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportRunFindManyArgs>(args?: SelectSubset<T, ImportRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportRun.
     * @param {ImportRunCreateArgs} args - Arguments to create a ImportRun.
     * @example
     * // Create one ImportRun
     * const ImportRun = await prisma.importRun.create({
     *   data: {
     *     // ... data to create a ImportRun
     *   }
     * })
     * 
     */
    create<T extends ImportRunCreateArgs>(args: SelectSubset<T, ImportRunCreateArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportRuns.
     * @param {ImportRunCreateManyArgs} args - Arguments to create many ImportRuns.
     * @example
     * // Create many ImportRuns
     * const importRun = await prisma.importRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportRunCreateManyArgs>(args?: SelectSubset<T, ImportRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportRuns and returns the data saved in the database.
     * @param {ImportRunCreateManyAndReturnArgs} args - Arguments to create many ImportRuns.
     * @example
     * // Create many ImportRuns
     * const importRun = await prisma.importRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportRuns and only return the `id`
     * const importRunWithIdOnly = await prisma.importRun.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportRunCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportRun.
     * @param {ImportRunDeleteArgs} args - Arguments to delete one ImportRun.
     * @example
     * // Delete one ImportRun
     * const ImportRun = await prisma.importRun.delete({
     *   where: {
     *     // ... filter to delete one ImportRun
     *   }
     * })
     * 
     */
    delete<T extends ImportRunDeleteArgs>(args: SelectSubset<T, ImportRunDeleteArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportRun.
     * @param {ImportRunUpdateArgs} args - Arguments to update one ImportRun.
     * @example
     * // Update one ImportRun
     * const importRun = await prisma.importRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportRunUpdateArgs>(args: SelectSubset<T, ImportRunUpdateArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportRuns.
     * @param {ImportRunDeleteManyArgs} args - Arguments to filter ImportRuns to delete.
     * @example
     * // Delete a few ImportRuns
     * const { count } = await prisma.importRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportRunDeleteManyArgs>(args?: SelectSubset<T, ImportRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportRuns
     * const importRun = await prisma.importRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportRunUpdateManyArgs>(args: SelectSubset<T, ImportRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportRun.
     * @param {ImportRunUpsertArgs} args - Arguments to update or create a ImportRun.
     * @example
     * // Update or create a ImportRun
     * const importRun = await prisma.importRun.upsert({
     *   create: {
     *     // ... data to create a ImportRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportRun we want to update
     *   }
     * })
     */
    upsert<T extends ImportRunUpsertArgs>(args: SelectSubset<T, ImportRunUpsertArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportRunCountArgs} args - Arguments to filter ImportRuns to count.
     * @example
     * // Count the number of ImportRuns
     * const count = await prisma.importRun.count({
     *   where: {
     *     // ... the filter for the ImportRuns we want to count
     *   }
     * })
    **/
    count<T extends ImportRunCountArgs>(
      args?: Subset<T, ImportRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportRunAggregateArgs>(args: Subset<T, ImportRunAggregateArgs>): Prisma.PrismaPromise<GetImportRunAggregateType<T>>

    /**
     * Group by ImportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportRunGroupByArgs['orderBy'] }
        : { orderBy?: ImportRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportRun model
   */
  readonly fields: ImportRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    auditRows<T extends ImportRun$auditRowsArgs<ExtArgs> = {}>(args?: Subset<T, ImportRun$auditRowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "findMany"> | Null>
    watchLogs<T extends ImportRun$watchLogsArgs<ExtArgs> = {}>(args?: Subset<T, ImportRun$watchLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportRun model
   */ 
  interface ImportRunFieldRefs {
    readonly id: FieldRef<"ImportRun", 'String'>
    readonly userId: FieldRef<"ImportRun", 'String'>
    readonly source: FieldRef<"ImportRun", 'String'>
    readonly status: FieldRef<"ImportRun", 'String'>
    readonly createdAt: FieldRef<"ImportRun", 'DateTime'>
    readonly updatedAt: FieldRef<"ImportRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportRun findUnique
   */
  export type ImportRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * Filter, which ImportRun to fetch.
     */
    where: ImportRunWhereUniqueInput
  }

  /**
   * ImportRun findUniqueOrThrow
   */
  export type ImportRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * Filter, which ImportRun to fetch.
     */
    where: ImportRunWhereUniqueInput
  }

  /**
   * ImportRun findFirst
   */
  export type ImportRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * Filter, which ImportRun to fetch.
     */
    where?: ImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportRuns to fetch.
     */
    orderBy?: ImportRunOrderByWithRelationInput | ImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportRuns.
     */
    cursor?: ImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportRuns.
     */
    distinct?: ImportRunScalarFieldEnum | ImportRunScalarFieldEnum[]
  }

  /**
   * ImportRun findFirstOrThrow
   */
  export type ImportRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * Filter, which ImportRun to fetch.
     */
    where?: ImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportRuns to fetch.
     */
    orderBy?: ImportRunOrderByWithRelationInput | ImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportRuns.
     */
    cursor?: ImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportRuns.
     */
    distinct?: ImportRunScalarFieldEnum | ImportRunScalarFieldEnum[]
  }

  /**
   * ImportRun findMany
   */
  export type ImportRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * Filter, which ImportRuns to fetch.
     */
    where?: ImportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportRuns to fetch.
     */
    orderBy?: ImportRunOrderByWithRelationInput | ImportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportRuns.
     */
    cursor?: ImportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportRuns.
     */
    skip?: number
    distinct?: ImportRunScalarFieldEnum | ImportRunScalarFieldEnum[]
  }

  /**
   * ImportRun create
   */
  export type ImportRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportRun.
     */
    data: XOR<ImportRunCreateInput, ImportRunUncheckedCreateInput>
  }

  /**
   * ImportRun createMany
   */
  export type ImportRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportRuns.
     */
    data: ImportRunCreateManyInput | ImportRunCreateManyInput[]
  }

  /**
   * ImportRun createManyAndReturn
   */
  export type ImportRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportRuns.
     */
    data: ImportRunCreateManyInput | ImportRunCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportRun update
   */
  export type ImportRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportRun.
     */
    data: XOR<ImportRunUpdateInput, ImportRunUncheckedUpdateInput>
    /**
     * Choose, which ImportRun to update.
     */
    where: ImportRunWhereUniqueInput
  }

  /**
   * ImportRun updateMany
   */
  export type ImportRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportRuns.
     */
    data: XOR<ImportRunUpdateManyMutationInput, ImportRunUncheckedUpdateManyInput>
    /**
     * Filter which ImportRuns to update
     */
    where?: ImportRunWhereInput
  }

  /**
   * ImportRun upsert
   */
  export type ImportRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportRun to update in case it exists.
     */
    where: ImportRunWhereUniqueInput
    /**
     * In case the ImportRun found by the `where` argument doesn't exist, create a new ImportRun with this data.
     */
    create: XOR<ImportRunCreateInput, ImportRunUncheckedCreateInput>
    /**
     * In case the ImportRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportRunUpdateInput, ImportRunUncheckedUpdateInput>
  }

  /**
   * ImportRun delete
   */
  export type ImportRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
    /**
     * Filter which ImportRun to delete.
     */
    where: ImportRunWhereUniqueInput
  }

  /**
   * ImportRun deleteMany
   */
  export type ImportRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportRuns to delete
     */
    where?: ImportRunWhereInput
  }

  /**
   * ImportRun.auditRows
   */
  export type ImportRun$auditRowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    where?: ImportAuditRowWhereInput
    orderBy?: ImportAuditRowOrderByWithRelationInput | ImportAuditRowOrderByWithRelationInput[]
    cursor?: ImportAuditRowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportAuditRowScalarFieldEnum | ImportAuditRowScalarFieldEnum[]
  }

  /**
   * ImportRun.watchLogs
   */
  export type ImportRun$watchLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    where?: WatchLogWhereInput
    orderBy?: WatchLogOrderByWithRelationInput | WatchLogOrderByWithRelationInput[]
    cursor?: WatchLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchLogScalarFieldEnum | WatchLogScalarFieldEnum[]
  }

  /**
   * ImportRun without action
   */
  export type ImportRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportRun
     */
    select?: ImportRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportRunInclude<ExtArgs> | null
  }


  /**
   * Model ImportAuditRow
   */

  export type AggregateImportAuditRow = {
    _count: ImportAuditRowCountAggregateOutputType | null
    _avg: ImportAuditRowAvgAggregateOutputType | null
    _sum: ImportAuditRowSumAggregateOutputType | null
    _min: ImportAuditRowMinAggregateOutputType | null
    _max: ImportAuditRowMaxAggregateOutputType | null
  }

  export type ImportAuditRowAvgAggregateOutputType = {
    rowNumber: number | null
    year: number | null
    tmdbMovieId: number | null
  }

  export type ImportAuditRowSumAggregateOutputType = {
    rowNumber: number | null
    year: number | null
    tmdbMovieId: number | null
  }

  export type ImportAuditRowMinAggregateOutputType = {
    id: string | null
    importId: string | null
    fileName: string | null
    rowNumber: number | null
    title: string | null
    year: number | null
    letterboxdUrl: string | null
    tmdbMovieId: number | null
    status: string | null
    message: string | null
    rawJson: string | null
  }

  export type ImportAuditRowMaxAggregateOutputType = {
    id: string | null
    importId: string | null
    fileName: string | null
    rowNumber: number | null
    title: string | null
    year: number | null
    letterboxdUrl: string | null
    tmdbMovieId: number | null
    status: string | null
    message: string | null
    rawJson: string | null
  }

  export type ImportAuditRowCountAggregateOutputType = {
    id: number
    importId: number
    fileName: number
    rowNumber: number
    title: number
    year: number
    letterboxdUrl: number
    tmdbMovieId: number
    status: number
    message: number
    rawJson: number
    _all: number
  }


  export type ImportAuditRowAvgAggregateInputType = {
    rowNumber?: true
    year?: true
    tmdbMovieId?: true
  }

  export type ImportAuditRowSumAggregateInputType = {
    rowNumber?: true
    year?: true
    tmdbMovieId?: true
  }

  export type ImportAuditRowMinAggregateInputType = {
    id?: true
    importId?: true
    fileName?: true
    rowNumber?: true
    title?: true
    year?: true
    letterboxdUrl?: true
    tmdbMovieId?: true
    status?: true
    message?: true
    rawJson?: true
  }

  export type ImportAuditRowMaxAggregateInputType = {
    id?: true
    importId?: true
    fileName?: true
    rowNumber?: true
    title?: true
    year?: true
    letterboxdUrl?: true
    tmdbMovieId?: true
    status?: true
    message?: true
    rawJson?: true
  }

  export type ImportAuditRowCountAggregateInputType = {
    id?: true
    importId?: true
    fileName?: true
    rowNumber?: true
    title?: true
    year?: true
    letterboxdUrl?: true
    tmdbMovieId?: true
    status?: true
    message?: true
    rawJson?: true
    _all?: true
  }

  export type ImportAuditRowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportAuditRow to aggregate.
     */
    where?: ImportAuditRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportAuditRows to fetch.
     */
    orderBy?: ImportAuditRowOrderByWithRelationInput | ImportAuditRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportAuditRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportAuditRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportAuditRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportAuditRows
    **/
    _count?: true | ImportAuditRowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportAuditRowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportAuditRowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportAuditRowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportAuditRowMaxAggregateInputType
  }

  export type GetImportAuditRowAggregateType<T extends ImportAuditRowAggregateArgs> = {
        [P in keyof T & keyof AggregateImportAuditRow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportAuditRow[P]>
      : GetScalarType<T[P], AggregateImportAuditRow[P]>
  }




  export type ImportAuditRowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportAuditRowWhereInput
    orderBy?: ImportAuditRowOrderByWithAggregationInput | ImportAuditRowOrderByWithAggregationInput[]
    by: ImportAuditRowScalarFieldEnum[] | ImportAuditRowScalarFieldEnum
    having?: ImportAuditRowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportAuditRowCountAggregateInputType | true
    _avg?: ImportAuditRowAvgAggregateInputType
    _sum?: ImportAuditRowSumAggregateInputType
    _min?: ImportAuditRowMinAggregateInputType
    _max?: ImportAuditRowMaxAggregateInputType
  }

  export type ImportAuditRowGroupByOutputType = {
    id: string
    importId: string
    fileName: string
    rowNumber: number
    title: string
    year: number | null
    letterboxdUrl: string | null
    tmdbMovieId: number | null
    status: string
    message: string | null
    rawJson: string | null
    _count: ImportAuditRowCountAggregateOutputType | null
    _avg: ImportAuditRowAvgAggregateOutputType | null
    _sum: ImportAuditRowSumAggregateOutputType | null
    _min: ImportAuditRowMinAggregateOutputType | null
    _max: ImportAuditRowMaxAggregateOutputType | null
  }

  type GetImportAuditRowGroupByPayload<T extends ImportAuditRowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportAuditRowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportAuditRowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportAuditRowGroupByOutputType[P]>
            : GetScalarType<T[P], ImportAuditRowGroupByOutputType[P]>
        }
      >
    >


  export type ImportAuditRowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    importId?: boolean
    fileName?: boolean
    rowNumber?: boolean
    title?: boolean
    year?: boolean
    letterboxdUrl?: boolean
    tmdbMovieId?: boolean
    status?: boolean
    message?: boolean
    rawJson?: boolean
    importRun?: boolean | ImportRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importAuditRow"]>

  export type ImportAuditRowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    importId?: boolean
    fileName?: boolean
    rowNumber?: boolean
    title?: boolean
    year?: boolean
    letterboxdUrl?: boolean
    tmdbMovieId?: boolean
    status?: boolean
    message?: boolean
    rawJson?: boolean
    importRun?: boolean | ImportRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importAuditRow"]>

  export type ImportAuditRowSelectScalar = {
    id?: boolean
    importId?: boolean
    fileName?: boolean
    rowNumber?: boolean
    title?: boolean
    year?: boolean
    letterboxdUrl?: boolean
    tmdbMovieId?: boolean
    status?: boolean
    message?: boolean
    rawJson?: boolean
  }

  export type ImportAuditRowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importRun?: boolean | ImportRunDefaultArgs<ExtArgs>
  }
  export type ImportAuditRowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importRun?: boolean | ImportRunDefaultArgs<ExtArgs>
  }

  export type $ImportAuditRowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportAuditRow"
    objects: {
      importRun: Prisma.$ImportRunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      importId: string
      fileName: string
      rowNumber: number
      title: string
      year: number | null
      letterboxdUrl: string | null
      tmdbMovieId: number | null
      status: string
      message: string | null
      rawJson: string | null
    }, ExtArgs["result"]["importAuditRow"]>
    composites: {}
  }

  type ImportAuditRowGetPayload<S extends boolean | null | undefined | ImportAuditRowDefaultArgs> = $Result.GetResult<Prisma.$ImportAuditRowPayload, S>

  type ImportAuditRowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportAuditRowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportAuditRowCountAggregateInputType | true
    }

  export interface ImportAuditRowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportAuditRow'], meta: { name: 'ImportAuditRow' } }
    /**
     * Find zero or one ImportAuditRow that matches the filter.
     * @param {ImportAuditRowFindUniqueArgs} args - Arguments to find a ImportAuditRow
     * @example
     * // Get one ImportAuditRow
     * const importAuditRow = await prisma.importAuditRow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportAuditRowFindUniqueArgs>(args: SelectSubset<T, ImportAuditRowFindUniqueArgs<ExtArgs>>): Prisma__ImportAuditRowClient<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportAuditRow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportAuditRowFindUniqueOrThrowArgs} args - Arguments to find a ImportAuditRow
     * @example
     * // Get one ImportAuditRow
     * const importAuditRow = await prisma.importAuditRow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportAuditRowFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportAuditRowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportAuditRowClient<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportAuditRow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportAuditRowFindFirstArgs} args - Arguments to find a ImportAuditRow
     * @example
     * // Get one ImportAuditRow
     * const importAuditRow = await prisma.importAuditRow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportAuditRowFindFirstArgs>(args?: SelectSubset<T, ImportAuditRowFindFirstArgs<ExtArgs>>): Prisma__ImportAuditRowClient<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportAuditRow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportAuditRowFindFirstOrThrowArgs} args - Arguments to find a ImportAuditRow
     * @example
     * // Get one ImportAuditRow
     * const importAuditRow = await prisma.importAuditRow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportAuditRowFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportAuditRowFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportAuditRowClient<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportAuditRows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportAuditRowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportAuditRows
     * const importAuditRows = await prisma.importAuditRow.findMany()
     * 
     * // Get first 10 ImportAuditRows
     * const importAuditRows = await prisma.importAuditRow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importAuditRowWithIdOnly = await prisma.importAuditRow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportAuditRowFindManyArgs>(args?: SelectSubset<T, ImportAuditRowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportAuditRow.
     * @param {ImportAuditRowCreateArgs} args - Arguments to create a ImportAuditRow.
     * @example
     * // Create one ImportAuditRow
     * const ImportAuditRow = await prisma.importAuditRow.create({
     *   data: {
     *     // ... data to create a ImportAuditRow
     *   }
     * })
     * 
     */
    create<T extends ImportAuditRowCreateArgs>(args: SelectSubset<T, ImportAuditRowCreateArgs<ExtArgs>>): Prisma__ImportAuditRowClient<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportAuditRows.
     * @param {ImportAuditRowCreateManyArgs} args - Arguments to create many ImportAuditRows.
     * @example
     * // Create many ImportAuditRows
     * const importAuditRow = await prisma.importAuditRow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportAuditRowCreateManyArgs>(args?: SelectSubset<T, ImportAuditRowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportAuditRows and returns the data saved in the database.
     * @param {ImportAuditRowCreateManyAndReturnArgs} args - Arguments to create many ImportAuditRows.
     * @example
     * // Create many ImportAuditRows
     * const importAuditRow = await prisma.importAuditRow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportAuditRows and only return the `id`
     * const importAuditRowWithIdOnly = await prisma.importAuditRow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportAuditRowCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportAuditRowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportAuditRow.
     * @param {ImportAuditRowDeleteArgs} args - Arguments to delete one ImportAuditRow.
     * @example
     * // Delete one ImportAuditRow
     * const ImportAuditRow = await prisma.importAuditRow.delete({
     *   where: {
     *     // ... filter to delete one ImportAuditRow
     *   }
     * })
     * 
     */
    delete<T extends ImportAuditRowDeleteArgs>(args: SelectSubset<T, ImportAuditRowDeleteArgs<ExtArgs>>): Prisma__ImportAuditRowClient<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportAuditRow.
     * @param {ImportAuditRowUpdateArgs} args - Arguments to update one ImportAuditRow.
     * @example
     * // Update one ImportAuditRow
     * const importAuditRow = await prisma.importAuditRow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportAuditRowUpdateArgs>(args: SelectSubset<T, ImportAuditRowUpdateArgs<ExtArgs>>): Prisma__ImportAuditRowClient<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportAuditRows.
     * @param {ImportAuditRowDeleteManyArgs} args - Arguments to filter ImportAuditRows to delete.
     * @example
     * // Delete a few ImportAuditRows
     * const { count } = await prisma.importAuditRow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportAuditRowDeleteManyArgs>(args?: SelectSubset<T, ImportAuditRowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportAuditRows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportAuditRowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportAuditRows
     * const importAuditRow = await prisma.importAuditRow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportAuditRowUpdateManyArgs>(args: SelectSubset<T, ImportAuditRowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportAuditRow.
     * @param {ImportAuditRowUpsertArgs} args - Arguments to update or create a ImportAuditRow.
     * @example
     * // Update or create a ImportAuditRow
     * const importAuditRow = await prisma.importAuditRow.upsert({
     *   create: {
     *     // ... data to create a ImportAuditRow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportAuditRow we want to update
     *   }
     * })
     */
    upsert<T extends ImportAuditRowUpsertArgs>(args: SelectSubset<T, ImportAuditRowUpsertArgs<ExtArgs>>): Prisma__ImportAuditRowClient<$Result.GetResult<Prisma.$ImportAuditRowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportAuditRows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportAuditRowCountArgs} args - Arguments to filter ImportAuditRows to count.
     * @example
     * // Count the number of ImportAuditRows
     * const count = await prisma.importAuditRow.count({
     *   where: {
     *     // ... the filter for the ImportAuditRows we want to count
     *   }
     * })
    **/
    count<T extends ImportAuditRowCountArgs>(
      args?: Subset<T, ImportAuditRowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportAuditRowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportAuditRow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportAuditRowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportAuditRowAggregateArgs>(args: Subset<T, ImportAuditRowAggregateArgs>): Prisma.PrismaPromise<GetImportAuditRowAggregateType<T>>

    /**
     * Group by ImportAuditRow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportAuditRowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportAuditRowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportAuditRowGroupByArgs['orderBy'] }
        : { orderBy?: ImportAuditRowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportAuditRowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportAuditRowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportAuditRow model
   */
  readonly fields: ImportAuditRowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportAuditRow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportAuditRowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    importRun<T extends ImportRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImportRunDefaultArgs<ExtArgs>>): Prisma__ImportRunClient<$Result.GetResult<Prisma.$ImportRunPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportAuditRow model
   */ 
  interface ImportAuditRowFieldRefs {
    readonly id: FieldRef<"ImportAuditRow", 'String'>
    readonly importId: FieldRef<"ImportAuditRow", 'String'>
    readonly fileName: FieldRef<"ImportAuditRow", 'String'>
    readonly rowNumber: FieldRef<"ImportAuditRow", 'Int'>
    readonly title: FieldRef<"ImportAuditRow", 'String'>
    readonly year: FieldRef<"ImportAuditRow", 'Int'>
    readonly letterboxdUrl: FieldRef<"ImportAuditRow", 'String'>
    readonly tmdbMovieId: FieldRef<"ImportAuditRow", 'Int'>
    readonly status: FieldRef<"ImportAuditRow", 'String'>
    readonly message: FieldRef<"ImportAuditRow", 'String'>
    readonly rawJson: FieldRef<"ImportAuditRow", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImportAuditRow findUnique
   */
  export type ImportAuditRowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * Filter, which ImportAuditRow to fetch.
     */
    where: ImportAuditRowWhereUniqueInput
  }

  /**
   * ImportAuditRow findUniqueOrThrow
   */
  export type ImportAuditRowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * Filter, which ImportAuditRow to fetch.
     */
    where: ImportAuditRowWhereUniqueInput
  }

  /**
   * ImportAuditRow findFirst
   */
  export type ImportAuditRowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * Filter, which ImportAuditRow to fetch.
     */
    where?: ImportAuditRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportAuditRows to fetch.
     */
    orderBy?: ImportAuditRowOrderByWithRelationInput | ImportAuditRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportAuditRows.
     */
    cursor?: ImportAuditRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportAuditRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportAuditRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportAuditRows.
     */
    distinct?: ImportAuditRowScalarFieldEnum | ImportAuditRowScalarFieldEnum[]
  }

  /**
   * ImportAuditRow findFirstOrThrow
   */
  export type ImportAuditRowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * Filter, which ImportAuditRow to fetch.
     */
    where?: ImportAuditRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportAuditRows to fetch.
     */
    orderBy?: ImportAuditRowOrderByWithRelationInput | ImportAuditRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportAuditRows.
     */
    cursor?: ImportAuditRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportAuditRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportAuditRows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportAuditRows.
     */
    distinct?: ImportAuditRowScalarFieldEnum | ImportAuditRowScalarFieldEnum[]
  }

  /**
   * ImportAuditRow findMany
   */
  export type ImportAuditRowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * Filter, which ImportAuditRows to fetch.
     */
    where?: ImportAuditRowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportAuditRows to fetch.
     */
    orderBy?: ImportAuditRowOrderByWithRelationInput | ImportAuditRowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportAuditRows.
     */
    cursor?: ImportAuditRowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportAuditRows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportAuditRows.
     */
    skip?: number
    distinct?: ImportAuditRowScalarFieldEnum | ImportAuditRowScalarFieldEnum[]
  }

  /**
   * ImportAuditRow create
   */
  export type ImportAuditRowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportAuditRow.
     */
    data: XOR<ImportAuditRowCreateInput, ImportAuditRowUncheckedCreateInput>
  }

  /**
   * ImportAuditRow createMany
   */
  export type ImportAuditRowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportAuditRows.
     */
    data: ImportAuditRowCreateManyInput | ImportAuditRowCreateManyInput[]
  }

  /**
   * ImportAuditRow createManyAndReturn
   */
  export type ImportAuditRowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportAuditRows.
     */
    data: ImportAuditRowCreateManyInput | ImportAuditRowCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportAuditRow update
   */
  export type ImportAuditRowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportAuditRow.
     */
    data: XOR<ImportAuditRowUpdateInput, ImportAuditRowUncheckedUpdateInput>
    /**
     * Choose, which ImportAuditRow to update.
     */
    where: ImportAuditRowWhereUniqueInput
  }

  /**
   * ImportAuditRow updateMany
   */
  export type ImportAuditRowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportAuditRows.
     */
    data: XOR<ImportAuditRowUpdateManyMutationInput, ImportAuditRowUncheckedUpdateManyInput>
    /**
     * Filter which ImportAuditRows to update
     */
    where?: ImportAuditRowWhereInput
  }

  /**
   * ImportAuditRow upsert
   */
  export type ImportAuditRowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportAuditRow to update in case it exists.
     */
    where: ImportAuditRowWhereUniqueInput
    /**
     * In case the ImportAuditRow found by the `where` argument doesn't exist, create a new ImportAuditRow with this data.
     */
    create: XOR<ImportAuditRowCreateInput, ImportAuditRowUncheckedCreateInput>
    /**
     * In case the ImportAuditRow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportAuditRowUpdateInput, ImportAuditRowUncheckedUpdateInput>
  }

  /**
   * ImportAuditRow delete
   */
  export type ImportAuditRowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
    /**
     * Filter which ImportAuditRow to delete.
     */
    where: ImportAuditRowWhereUniqueInput
  }

  /**
   * ImportAuditRow deleteMany
   */
  export type ImportAuditRowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportAuditRows to delete
     */
    where?: ImportAuditRowWhereInput
  }

  /**
   * ImportAuditRow without action
   */
  export type ImportAuditRowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportAuditRow
     */
    select?: ImportAuditRowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportAuditRowInclude<ExtArgs> | null
  }


  /**
   * Model Ballot
   */

  export type AggregateBallot = {
    _count: BallotCountAggregateOutputType | null
    _avg: BallotAvgAggregateOutputType | null
    _sum: BallotSumAggregateOutputType | null
    _min: BallotMinAggregateOutputType | null
    _max: BallotMaxAggregateOutputType | null
  }

  export type BallotAvgAggregateOutputType = {
    eventYear: number | null
  }

  export type BallotSumAggregateOutputType = {
    eventYear: number | null
  }

  export type BallotMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventYear: number | null
    category: string | null
    nomineeId: string | null
    nomineeName: string | null
    isWinner: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BallotMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventYear: number | null
    category: string | null
    nomineeId: string | null
    nomineeName: string | null
    isWinner: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BallotCountAggregateOutputType = {
    id: number
    userId: number
    eventYear: number
    category: number
    nomineeId: number
    nomineeName: number
    isWinner: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BallotAvgAggregateInputType = {
    eventYear?: true
  }

  export type BallotSumAggregateInputType = {
    eventYear?: true
  }

  export type BallotMinAggregateInputType = {
    id?: true
    userId?: true
    eventYear?: true
    category?: true
    nomineeId?: true
    nomineeName?: true
    isWinner?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BallotMaxAggregateInputType = {
    id?: true
    userId?: true
    eventYear?: true
    category?: true
    nomineeId?: true
    nomineeName?: true
    isWinner?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BallotCountAggregateInputType = {
    id?: true
    userId?: true
    eventYear?: true
    category?: true
    nomineeId?: true
    nomineeName?: true
    isWinner?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BallotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ballot to aggregate.
     */
    where?: BallotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ballots to fetch.
     */
    orderBy?: BallotOrderByWithRelationInput | BallotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BallotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ballots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ballots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ballots
    **/
    _count?: true | BallotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BallotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BallotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BallotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BallotMaxAggregateInputType
  }

  export type GetBallotAggregateType<T extends BallotAggregateArgs> = {
        [P in keyof T & keyof AggregateBallot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBallot[P]>
      : GetScalarType<T[P], AggregateBallot[P]>
  }




  export type BallotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BallotWhereInput
    orderBy?: BallotOrderByWithAggregationInput | BallotOrderByWithAggregationInput[]
    by: BallotScalarFieldEnum[] | BallotScalarFieldEnum
    having?: BallotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BallotCountAggregateInputType | true
    _avg?: BallotAvgAggregateInputType
    _sum?: BallotSumAggregateInputType
    _min?: BallotMinAggregateInputType
    _max?: BallotMaxAggregateInputType
  }

  export type BallotGroupByOutputType = {
    id: string
    userId: string
    eventYear: number
    category: string
    nomineeId: string
    nomineeName: string
    isWinner: boolean
    createdAt: Date
    updatedAt: Date
    _count: BallotCountAggregateOutputType | null
    _avg: BallotAvgAggregateOutputType | null
    _sum: BallotSumAggregateOutputType | null
    _min: BallotMinAggregateOutputType | null
    _max: BallotMaxAggregateOutputType | null
  }

  type GetBallotGroupByPayload<T extends BallotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BallotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BallotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BallotGroupByOutputType[P]>
            : GetScalarType<T[P], BallotGroupByOutputType[P]>
        }
      >
    >


  export type BallotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventYear?: boolean
    category?: boolean
    nomineeId?: boolean
    nomineeName?: boolean
    isWinner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ballot"]>

  export type BallotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventYear?: boolean
    category?: boolean
    nomineeId?: boolean
    nomineeName?: boolean
    isWinner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ballot"]>

  export type BallotSelectScalar = {
    id?: boolean
    userId?: boolean
    eventYear?: boolean
    category?: boolean
    nomineeId?: boolean
    nomineeName?: boolean
    isWinner?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BallotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BallotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BallotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ballot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      eventYear: number
      category: string
      nomineeId: string
      nomineeName: string
      isWinner: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ballot"]>
    composites: {}
  }

  type BallotGetPayload<S extends boolean | null | undefined | BallotDefaultArgs> = $Result.GetResult<Prisma.$BallotPayload, S>

  type BallotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BallotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BallotCountAggregateInputType | true
    }

  export interface BallotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ballot'], meta: { name: 'Ballot' } }
    /**
     * Find zero or one Ballot that matches the filter.
     * @param {BallotFindUniqueArgs} args - Arguments to find a Ballot
     * @example
     * // Get one Ballot
     * const ballot = await prisma.ballot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BallotFindUniqueArgs>(args: SelectSubset<T, BallotFindUniqueArgs<ExtArgs>>): Prisma__BallotClient<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ballot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BallotFindUniqueOrThrowArgs} args - Arguments to find a Ballot
     * @example
     * // Get one Ballot
     * const ballot = await prisma.ballot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BallotFindUniqueOrThrowArgs>(args: SelectSubset<T, BallotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BallotClient<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ballot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallotFindFirstArgs} args - Arguments to find a Ballot
     * @example
     * // Get one Ballot
     * const ballot = await prisma.ballot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BallotFindFirstArgs>(args?: SelectSubset<T, BallotFindFirstArgs<ExtArgs>>): Prisma__BallotClient<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ballot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallotFindFirstOrThrowArgs} args - Arguments to find a Ballot
     * @example
     * // Get one Ballot
     * const ballot = await prisma.ballot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BallotFindFirstOrThrowArgs>(args?: SelectSubset<T, BallotFindFirstOrThrowArgs<ExtArgs>>): Prisma__BallotClient<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ballots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ballots
     * const ballots = await prisma.ballot.findMany()
     * 
     * // Get first 10 Ballots
     * const ballots = await prisma.ballot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ballotWithIdOnly = await prisma.ballot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BallotFindManyArgs>(args?: SelectSubset<T, BallotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ballot.
     * @param {BallotCreateArgs} args - Arguments to create a Ballot.
     * @example
     * // Create one Ballot
     * const Ballot = await prisma.ballot.create({
     *   data: {
     *     // ... data to create a Ballot
     *   }
     * })
     * 
     */
    create<T extends BallotCreateArgs>(args: SelectSubset<T, BallotCreateArgs<ExtArgs>>): Prisma__BallotClient<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ballots.
     * @param {BallotCreateManyArgs} args - Arguments to create many Ballots.
     * @example
     * // Create many Ballots
     * const ballot = await prisma.ballot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BallotCreateManyArgs>(args?: SelectSubset<T, BallotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ballots and returns the data saved in the database.
     * @param {BallotCreateManyAndReturnArgs} args - Arguments to create many Ballots.
     * @example
     * // Create many Ballots
     * const ballot = await prisma.ballot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ballots and only return the `id`
     * const ballotWithIdOnly = await prisma.ballot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BallotCreateManyAndReturnArgs>(args?: SelectSubset<T, BallotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ballot.
     * @param {BallotDeleteArgs} args - Arguments to delete one Ballot.
     * @example
     * // Delete one Ballot
     * const Ballot = await prisma.ballot.delete({
     *   where: {
     *     // ... filter to delete one Ballot
     *   }
     * })
     * 
     */
    delete<T extends BallotDeleteArgs>(args: SelectSubset<T, BallotDeleteArgs<ExtArgs>>): Prisma__BallotClient<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ballot.
     * @param {BallotUpdateArgs} args - Arguments to update one Ballot.
     * @example
     * // Update one Ballot
     * const ballot = await prisma.ballot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BallotUpdateArgs>(args: SelectSubset<T, BallotUpdateArgs<ExtArgs>>): Prisma__BallotClient<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ballots.
     * @param {BallotDeleteManyArgs} args - Arguments to filter Ballots to delete.
     * @example
     * // Delete a few Ballots
     * const { count } = await prisma.ballot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BallotDeleteManyArgs>(args?: SelectSubset<T, BallotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ballots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ballots
     * const ballot = await prisma.ballot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BallotUpdateManyArgs>(args: SelectSubset<T, BallotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ballot.
     * @param {BallotUpsertArgs} args - Arguments to update or create a Ballot.
     * @example
     * // Update or create a Ballot
     * const ballot = await prisma.ballot.upsert({
     *   create: {
     *     // ... data to create a Ballot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ballot we want to update
     *   }
     * })
     */
    upsert<T extends BallotUpsertArgs>(args: SelectSubset<T, BallotUpsertArgs<ExtArgs>>): Prisma__BallotClient<$Result.GetResult<Prisma.$BallotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ballots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallotCountArgs} args - Arguments to filter Ballots to count.
     * @example
     * // Count the number of Ballots
     * const count = await prisma.ballot.count({
     *   where: {
     *     // ... the filter for the Ballots we want to count
     *   }
     * })
    **/
    count<T extends BallotCountArgs>(
      args?: Subset<T, BallotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BallotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ballot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BallotAggregateArgs>(args: Subset<T, BallotAggregateArgs>): Prisma.PrismaPromise<GetBallotAggregateType<T>>

    /**
     * Group by Ballot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BallotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BallotGroupByArgs['orderBy'] }
        : { orderBy?: BallotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BallotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBallotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ballot model
   */
  readonly fields: BallotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ballot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BallotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ballot model
   */ 
  interface BallotFieldRefs {
    readonly id: FieldRef<"Ballot", 'String'>
    readonly userId: FieldRef<"Ballot", 'String'>
    readonly eventYear: FieldRef<"Ballot", 'Int'>
    readonly category: FieldRef<"Ballot", 'String'>
    readonly nomineeId: FieldRef<"Ballot", 'String'>
    readonly nomineeName: FieldRef<"Ballot", 'String'>
    readonly isWinner: FieldRef<"Ballot", 'Boolean'>
    readonly createdAt: FieldRef<"Ballot", 'DateTime'>
    readonly updatedAt: FieldRef<"Ballot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ballot findUnique
   */
  export type BallotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * Filter, which Ballot to fetch.
     */
    where: BallotWhereUniqueInput
  }

  /**
   * Ballot findUniqueOrThrow
   */
  export type BallotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * Filter, which Ballot to fetch.
     */
    where: BallotWhereUniqueInput
  }

  /**
   * Ballot findFirst
   */
  export type BallotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * Filter, which Ballot to fetch.
     */
    where?: BallotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ballots to fetch.
     */
    orderBy?: BallotOrderByWithRelationInput | BallotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ballots.
     */
    cursor?: BallotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ballots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ballots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ballots.
     */
    distinct?: BallotScalarFieldEnum | BallotScalarFieldEnum[]
  }

  /**
   * Ballot findFirstOrThrow
   */
  export type BallotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * Filter, which Ballot to fetch.
     */
    where?: BallotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ballots to fetch.
     */
    orderBy?: BallotOrderByWithRelationInput | BallotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ballots.
     */
    cursor?: BallotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ballots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ballots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ballots.
     */
    distinct?: BallotScalarFieldEnum | BallotScalarFieldEnum[]
  }

  /**
   * Ballot findMany
   */
  export type BallotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * Filter, which Ballots to fetch.
     */
    where?: BallotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ballots to fetch.
     */
    orderBy?: BallotOrderByWithRelationInput | BallotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ballots.
     */
    cursor?: BallotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ballots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ballots.
     */
    skip?: number
    distinct?: BallotScalarFieldEnum | BallotScalarFieldEnum[]
  }

  /**
   * Ballot create
   */
  export type BallotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * The data needed to create a Ballot.
     */
    data: XOR<BallotCreateInput, BallotUncheckedCreateInput>
  }

  /**
   * Ballot createMany
   */
  export type BallotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ballots.
     */
    data: BallotCreateManyInput | BallotCreateManyInput[]
  }

  /**
   * Ballot createManyAndReturn
   */
  export type BallotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ballots.
     */
    data: BallotCreateManyInput | BallotCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ballot update
   */
  export type BallotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * The data needed to update a Ballot.
     */
    data: XOR<BallotUpdateInput, BallotUncheckedUpdateInput>
    /**
     * Choose, which Ballot to update.
     */
    where: BallotWhereUniqueInput
  }

  /**
   * Ballot updateMany
   */
  export type BallotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ballots.
     */
    data: XOR<BallotUpdateManyMutationInput, BallotUncheckedUpdateManyInput>
    /**
     * Filter which Ballots to update
     */
    where?: BallotWhereInput
  }

  /**
   * Ballot upsert
   */
  export type BallotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * The filter to search for the Ballot to update in case it exists.
     */
    where: BallotWhereUniqueInput
    /**
     * In case the Ballot found by the `where` argument doesn't exist, create a new Ballot with this data.
     */
    create: XOR<BallotCreateInput, BallotUncheckedCreateInput>
    /**
     * In case the Ballot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BallotUpdateInput, BallotUncheckedUpdateInput>
  }

  /**
   * Ballot delete
   */
  export type BallotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
    /**
     * Filter which Ballot to delete.
     */
    where: BallotWhereUniqueInput
  }

  /**
   * Ballot deleteMany
   */
  export type BallotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ballots to delete
     */
    where?: BallotWhereInput
  }

  /**
   * Ballot without action
   */
  export type BallotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ballot
     */
    select?: BallotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BallotInclude<ExtArgs> | null
  }


  /**
   * Model AwardEvent
   */

  export type AggregateAwardEvent = {
    _count: AwardEventCountAggregateOutputType | null
    _min: AwardEventMinAggregateOutputType | null
    _max: AwardEventMaxAggregateOutputType | null
  }

  export type AwardEventMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    type: string | null
  }

  export type AwardEventMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    type: string | null
  }

  export type AwardEventCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    type: number
    _all: number
  }


  export type AwardEventMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
  }

  export type AwardEventMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
  }

  export type AwardEventCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
    _all?: true
  }

  export type AwardEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AwardEvent to aggregate.
     */
    where?: AwardEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardEvents to fetch.
     */
    orderBy?: AwardEventOrderByWithRelationInput | AwardEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AwardEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AwardEvents
    **/
    _count?: true | AwardEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AwardEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AwardEventMaxAggregateInputType
  }

  export type GetAwardEventAggregateType<T extends AwardEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAwardEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAwardEvent[P]>
      : GetScalarType<T[P], AggregateAwardEvent[P]>
  }




  export type AwardEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardEventWhereInput
    orderBy?: AwardEventOrderByWithAggregationInput | AwardEventOrderByWithAggregationInput[]
    by: AwardEventScalarFieldEnum[] | AwardEventScalarFieldEnum
    having?: AwardEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AwardEventCountAggregateInputType | true
    _min?: AwardEventMinAggregateInputType
    _max?: AwardEventMaxAggregateInputType
  }

  export type AwardEventGroupByOutputType = {
    id: string
    name: string
    slug: string
    type: string
    _count: AwardEventCountAggregateOutputType | null
    _min: AwardEventMinAggregateOutputType | null
    _max: AwardEventMaxAggregateOutputType | null
  }

  type GetAwardEventGroupByPayload<T extends AwardEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AwardEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AwardEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AwardEventGroupByOutputType[P]>
            : GetScalarType<T[P], AwardEventGroupByOutputType[P]>
        }
      >
    >


  export type AwardEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
    seasons?: boolean | AwardEvent$seasonsArgs<ExtArgs>
    _count?: boolean | AwardEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awardEvent"]>

  export type AwardEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
  }, ExtArgs["result"]["awardEvent"]>

  export type AwardEventSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
  }

  export type AwardEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasons?: boolean | AwardEvent$seasonsArgs<ExtArgs>
    _count?: boolean | AwardEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AwardEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AwardEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AwardEvent"
    objects: {
      seasons: Prisma.$AwardSeasonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      type: string
    }, ExtArgs["result"]["awardEvent"]>
    composites: {}
  }

  type AwardEventGetPayload<S extends boolean | null | undefined | AwardEventDefaultArgs> = $Result.GetResult<Prisma.$AwardEventPayload, S>

  type AwardEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AwardEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AwardEventCountAggregateInputType | true
    }

  export interface AwardEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AwardEvent'], meta: { name: 'AwardEvent' } }
    /**
     * Find zero or one AwardEvent that matches the filter.
     * @param {AwardEventFindUniqueArgs} args - Arguments to find a AwardEvent
     * @example
     * // Get one AwardEvent
     * const awardEvent = await prisma.awardEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AwardEventFindUniqueArgs>(args: SelectSubset<T, AwardEventFindUniqueArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AwardEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AwardEventFindUniqueOrThrowArgs} args - Arguments to find a AwardEvent
     * @example
     * // Get one AwardEvent
     * const awardEvent = await prisma.awardEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AwardEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AwardEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AwardEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardEventFindFirstArgs} args - Arguments to find a AwardEvent
     * @example
     * // Get one AwardEvent
     * const awardEvent = await prisma.awardEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AwardEventFindFirstArgs>(args?: SelectSubset<T, AwardEventFindFirstArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AwardEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardEventFindFirstOrThrowArgs} args - Arguments to find a AwardEvent
     * @example
     * // Get one AwardEvent
     * const awardEvent = await prisma.awardEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AwardEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AwardEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AwardEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AwardEvents
     * const awardEvents = await prisma.awardEvent.findMany()
     * 
     * // Get first 10 AwardEvents
     * const awardEvents = await prisma.awardEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const awardEventWithIdOnly = await prisma.awardEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AwardEventFindManyArgs>(args?: SelectSubset<T, AwardEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AwardEvent.
     * @param {AwardEventCreateArgs} args - Arguments to create a AwardEvent.
     * @example
     * // Create one AwardEvent
     * const AwardEvent = await prisma.awardEvent.create({
     *   data: {
     *     // ... data to create a AwardEvent
     *   }
     * })
     * 
     */
    create<T extends AwardEventCreateArgs>(args: SelectSubset<T, AwardEventCreateArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AwardEvents.
     * @param {AwardEventCreateManyArgs} args - Arguments to create many AwardEvents.
     * @example
     * // Create many AwardEvents
     * const awardEvent = await prisma.awardEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AwardEventCreateManyArgs>(args?: SelectSubset<T, AwardEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AwardEvents and returns the data saved in the database.
     * @param {AwardEventCreateManyAndReturnArgs} args - Arguments to create many AwardEvents.
     * @example
     * // Create many AwardEvents
     * const awardEvent = await prisma.awardEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AwardEvents and only return the `id`
     * const awardEventWithIdOnly = await prisma.awardEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AwardEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AwardEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AwardEvent.
     * @param {AwardEventDeleteArgs} args - Arguments to delete one AwardEvent.
     * @example
     * // Delete one AwardEvent
     * const AwardEvent = await prisma.awardEvent.delete({
     *   where: {
     *     // ... filter to delete one AwardEvent
     *   }
     * })
     * 
     */
    delete<T extends AwardEventDeleteArgs>(args: SelectSubset<T, AwardEventDeleteArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AwardEvent.
     * @param {AwardEventUpdateArgs} args - Arguments to update one AwardEvent.
     * @example
     * // Update one AwardEvent
     * const awardEvent = await prisma.awardEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AwardEventUpdateArgs>(args: SelectSubset<T, AwardEventUpdateArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AwardEvents.
     * @param {AwardEventDeleteManyArgs} args - Arguments to filter AwardEvents to delete.
     * @example
     * // Delete a few AwardEvents
     * const { count } = await prisma.awardEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AwardEventDeleteManyArgs>(args?: SelectSubset<T, AwardEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AwardEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AwardEvents
     * const awardEvent = await prisma.awardEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AwardEventUpdateManyArgs>(args: SelectSubset<T, AwardEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AwardEvent.
     * @param {AwardEventUpsertArgs} args - Arguments to update or create a AwardEvent.
     * @example
     * // Update or create a AwardEvent
     * const awardEvent = await prisma.awardEvent.upsert({
     *   create: {
     *     // ... data to create a AwardEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AwardEvent we want to update
     *   }
     * })
     */
    upsert<T extends AwardEventUpsertArgs>(args: SelectSubset<T, AwardEventUpsertArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AwardEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardEventCountArgs} args - Arguments to filter AwardEvents to count.
     * @example
     * // Count the number of AwardEvents
     * const count = await prisma.awardEvent.count({
     *   where: {
     *     // ... the filter for the AwardEvents we want to count
     *   }
     * })
    **/
    count<T extends AwardEventCountArgs>(
      args?: Subset<T, AwardEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AwardEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AwardEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AwardEventAggregateArgs>(args: Subset<T, AwardEventAggregateArgs>): Prisma.PrismaPromise<GetAwardEventAggregateType<T>>

    /**
     * Group by AwardEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AwardEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AwardEventGroupByArgs['orderBy'] }
        : { orderBy?: AwardEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AwardEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAwardEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AwardEvent model
   */
  readonly fields: AwardEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AwardEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AwardEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seasons<T extends AwardEvent$seasonsArgs<ExtArgs> = {}>(args?: Subset<T, AwardEvent$seasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AwardEvent model
   */ 
  interface AwardEventFieldRefs {
    readonly id: FieldRef<"AwardEvent", 'String'>
    readonly name: FieldRef<"AwardEvent", 'String'>
    readonly slug: FieldRef<"AwardEvent", 'String'>
    readonly type: FieldRef<"AwardEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AwardEvent findUnique
   */
  export type AwardEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * Filter, which AwardEvent to fetch.
     */
    where: AwardEventWhereUniqueInput
  }

  /**
   * AwardEvent findUniqueOrThrow
   */
  export type AwardEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * Filter, which AwardEvent to fetch.
     */
    where: AwardEventWhereUniqueInput
  }

  /**
   * AwardEvent findFirst
   */
  export type AwardEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * Filter, which AwardEvent to fetch.
     */
    where?: AwardEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardEvents to fetch.
     */
    orderBy?: AwardEventOrderByWithRelationInput | AwardEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AwardEvents.
     */
    cursor?: AwardEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AwardEvents.
     */
    distinct?: AwardEventScalarFieldEnum | AwardEventScalarFieldEnum[]
  }

  /**
   * AwardEvent findFirstOrThrow
   */
  export type AwardEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * Filter, which AwardEvent to fetch.
     */
    where?: AwardEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardEvents to fetch.
     */
    orderBy?: AwardEventOrderByWithRelationInput | AwardEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AwardEvents.
     */
    cursor?: AwardEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AwardEvents.
     */
    distinct?: AwardEventScalarFieldEnum | AwardEventScalarFieldEnum[]
  }

  /**
   * AwardEvent findMany
   */
  export type AwardEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * Filter, which AwardEvents to fetch.
     */
    where?: AwardEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardEvents to fetch.
     */
    orderBy?: AwardEventOrderByWithRelationInput | AwardEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AwardEvents.
     */
    cursor?: AwardEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardEvents.
     */
    skip?: number
    distinct?: AwardEventScalarFieldEnum | AwardEventScalarFieldEnum[]
  }

  /**
   * AwardEvent create
   */
  export type AwardEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AwardEvent.
     */
    data: XOR<AwardEventCreateInput, AwardEventUncheckedCreateInput>
  }

  /**
   * AwardEvent createMany
   */
  export type AwardEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AwardEvents.
     */
    data: AwardEventCreateManyInput | AwardEventCreateManyInput[]
  }

  /**
   * AwardEvent createManyAndReturn
   */
  export type AwardEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AwardEvents.
     */
    data: AwardEventCreateManyInput | AwardEventCreateManyInput[]
  }

  /**
   * AwardEvent update
   */
  export type AwardEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AwardEvent.
     */
    data: XOR<AwardEventUpdateInput, AwardEventUncheckedUpdateInput>
    /**
     * Choose, which AwardEvent to update.
     */
    where: AwardEventWhereUniqueInput
  }

  /**
   * AwardEvent updateMany
   */
  export type AwardEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AwardEvents.
     */
    data: XOR<AwardEventUpdateManyMutationInput, AwardEventUncheckedUpdateManyInput>
    /**
     * Filter which AwardEvents to update
     */
    where?: AwardEventWhereInput
  }

  /**
   * AwardEvent upsert
   */
  export type AwardEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AwardEvent to update in case it exists.
     */
    where: AwardEventWhereUniqueInput
    /**
     * In case the AwardEvent found by the `where` argument doesn't exist, create a new AwardEvent with this data.
     */
    create: XOR<AwardEventCreateInput, AwardEventUncheckedCreateInput>
    /**
     * In case the AwardEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AwardEventUpdateInput, AwardEventUncheckedUpdateInput>
  }

  /**
   * AwardEvent delete
   */
  export type AwardEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
    /**
     * Filter which AwardEvent to delete.
     */
    where: AwardEventWhereUniqueInput
  }

  /**
   * AwardEvent deleteMany
   */
  export type AwardEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AwardEvents to delete
     */
    where?: AwardEventWhereInput
  }

  /**
   * AwardEvent.seasons
   */
  export type AwardEvent$seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    where?: AwardSeasonWhereInput
    orderBy?: AwardSeasonOrderByWithRelationInput | AwardSeasonOrderByWithRelationInput[]
    cursor?: AwardSeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AwardSeasonScalarFieldEnum | AwardSeasonScalarFieldEnum[]
  }

  /**
   * AwardEvent without action
   */
  export type AwardEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardEvent
     */
    select?: AwardEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardEventInclude<ExtArgs> | null
  }


  /**
   * Model AwardSeason
   */

  export type AggregateAwardSeason = {
    _count: AwardSeasonCountAggregateOutputType | null
    _avg: AwardSeasonAvgAggregateOutputType | null
    _sum: AwardSeasonSumAggregateOutputType | null
    _min: AwardSeasonMinAggregateOutputType | null
    _max: AwardSeasonMaxAggregateOutputType | null
  }

  export type AwardSeasonAvgAggregateOutputType = {
    year: number | null
  }

  export type AwardSeasonSumAggregateOutputType = {
    year: number | null
  }

  export type AwardSeasonMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    year: number | null
    season: string | null
    phase: string | null
    date: Date | null
  }

  export type AwardSeasonMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    year: number | null
    season: string | null
    phase: string | null
    date: Date | null
  }

  export type AwardSeasonCountAggregateOutputType = {
    id: number
    eventId: number
    year: number
    season: number
    phase: number
    date: number
    _all: number
  }


  export type AwardSeasonAvgAggregateInputType = {
    year?: true
  }

  export type AwardSeasonSumAggregateInputType = {
    year?: true
  }

  export type AwardSeasonMinAggregateInputType = {
    id?: true
    eventId?: true
    year?: true
    season?: true
    phase?: true
    date?: true
  }

  export type AwardSeasonMaxAggregateInputType = {
    id?: true
    eventId?: true
    year?: true
    season?: true
    phase?: true
    date?: true
  }

  export type AwardSeasonCountAggregateInputType = {
    id?: true
    eventId?: true
    year?: true
    season?: true
    phase?: true
    date?: true
    _all?: true
  }

  export type AwardSeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AwardSeason to aggregate.
     */
    where?: AwardSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardSeasons to fetch.
     */
    orderBy?: AwardSeasonOrderByWithRelationInput | AwardSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AwardSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AwardSeasons
    **/
    _count?: true | AwardSeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AwardSeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AwardSeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AwardSeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AwardSeasonMaxAggregateInputType
  }

  export type GetAwardSeasonAggregateType<T extends AwardSeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateAwardSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAwardSeason[P]>
      : GetScalarType<T[P], AggregateAwardSeason[P]>
  }




  export type AwardSeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardSeasonWhereInput
    orderBy?: AwardSeasonOrderByWithAggregationInput | AwardSeasonOrderByWithAggregationInput[]
    by: AwardSeasonScalarFieldEnum[] | AwardSeasonScalarFieldEnum
    having?: AwardSeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AwardSeasonCountAggregateInputType | true
    _avg?: AwardSeasonAvgAggregateInputType
    _sum?: AwardSeasonSumAggregateInputType
    _min?: AwardSeasonMinAggregateInputType
    _max?: AwardSeasonMaxAggregateInputType
  }

  export type AwardSeasonGroupByOutputType = {
    id: string
    eventId: string
    year: number
    season: string
    phase: string
    date: Date | null
    _count: AwardSeasonCountAggregateOutputType | null
    _avg: AwardSeasonAvgAggregateOutputType | null
    _sum: AwardSeasonSumAggregateOutputType | null
    _min: AwardSeasonMinAggregateOutputType | null
    _max: AwardSeasonMaxAggregateOutputType | null
  }

  type GetAwardSeasonGroupByPayload<T extends AwardSeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AwardSeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AwardSeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AwardSeasonGroupByOutputType[P]>
            : GetScalarType<T[P], AwardSeasonGroupByOutputType[P]>
        }
      >
    >


  export type AwardSeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    year?: boolean
    season?: boolean
    phase?: boolean
    date?: boolean
    event?: boolean | AwardEventDefaultArgs<ExtArgs>
    winners?: boolean | AwardSeason$winnersArgs<ExtArgs>
    _count?: boolean | AwardSeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awardSeason"]>

  export type AwardSeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    year?: boolean
    season?: boolean
    phase?: boolean
    date?: boolean
    event?: boolean | AwardEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awardSeason"]>

  export type AwardSeasonSelectScalar = {
    id?: boolean
    eventId?: boolean
    year?: boolean
    season?: boolean
    phase?: boolean
    date?: boolean
  }

  export type AwardSeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | AwardEventDefaultArgs<ExtArgs>
    winners?: boolean | AwardSeason$winnersArgs<ExtArgs>
    _count?: boolean | AwardSeasonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AwardSeasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | AwardEventDefaultArgs<ExtArgs>
  }

  export type $AwardSeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AwardSeason"
    objects: {
      event: Prisma.$AwardEventPayload<ExtArgs>
      winners: Prisma.$AwardWinnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      year: number
      season: string
      phase: string
      date: Date | null
    }, ExtArgs["result"]["awardSeason"]>
    composites: {}
  }

  type AwardSeasonGetPayload<S extends boolean | null | undefined | AwardSeasonDefaultArgs> = $Result.GetResult<Prisma.$AwardSeasonPayload, S>

  type AwardSeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AwardSeasonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AwardSeasonCountAggregateInputType | true
    }

  export interface AwardSeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AwardSeason'], meta: { name: 'AwardSeason' } }
    /**
     * Find zero or one AwardSeason that matches the filter.
     * @param {AwardSeasonFindUniqueArgs} args - Arguments to find a AwardSeason
     * @example
     * // Get one AwardSeason
     * const awardSeason = await prisma.awardSeason.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AwardSeasonFindUniqueArgs>(args: SelectSubset<T, AwardSeasonFindUniqueArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AwardSeason that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AwardSeasonFindUniqueOrThrowArgs} args - Arguments to find a AwardSeason
     * @example
     * // Get one AwardSeason
     * const awardSeason = await prisma.awardSeason.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AwardSeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, AwardSeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AwardSeason that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardSeasonFindFirstArgs} args - Arguments to find a AwardSeason
     * @example
     * // Get one AwardSeason
     * const awardSeason = await prisma.awardSeason.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AwardSeasonFindFirstArgs>(args?: SelectSubset<T, AwardSeasonFindFirstArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AwardSeason that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardSeasonFindFirstOrThrowArgs} args - Arguments to find a AwardSeason
     * @example
     * // Get one AwardSeason
     * const awardSeason = await prisma.awardSeason.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AwardSeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, AwardSeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AwardSeasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardSeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AwardSeasons
     * const awardSeasons = await prisma.awardSeason.findMany()
     * 
     * // Get first 10 AwardSeasons
     * const awardSeasons = await prisma.awardSeason.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const awardSeasonWithIdOnly = await prisma.awardSeason.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AwardSeasonFindManyArgs>(args?: SelectSubset<T, AwardSeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AwardSeason.
     * @param {AwardSeasonCreateArgs} args - Arguments to create a AwardSeason.
     * @example
     * // Create one AwardSeason
     * const AwardSeason = await prisma.awardSeason.create({
     *   data: {
     *     // ... data to create a AwardSeason
     *   }
     * })
     * 
     */
    create<T extends AwardSeasonCreateArgs>(args: SelectSubset<T, AwardSeasonCreateArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AwardSeasons.
     * @param {AwardSeasonCreateManyArgs} args - Arguments to create many AwardSeasons.
     * @example
     * // Create many AwardSeasons
     * const awardSeason = await prisma.awardSeason.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AwardSeasonCreateManyArgs>(args?: SelectSubset<T, AwardSeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AwardSeasons and returns the data saved in the database.
     * @param {AwardSeasonCreateManyAndReturnArgs} args - Arguments to create many AwardSeasons.
     * @example
     * // Create many AwardSeasons
     * const awardSeason = await prisma.awardSeason.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AwardSeasons and only return the `id`
     * const awardSeasonWithIdOnly = await prisma.awardSeason.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AwardSeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, AwardSeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AwardSeason.
     * @param {AwardSeasonDeleteArgs} args - Arguments to delete one AwardSeason.
     * @example
     * // Delete one AwardSeason
     * const AwardSeason = await prisma.awardSeason.delete({
     *   where: {
     *     // ... filter to delete one AwardSeason
     *   }
     * })
     * 
     */
    delete<T extends AwardSeasonDeleteArgs>(args: SelectSubset<T, AwardSeasonDeleteArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AwardSeason.
     * @param {AwardSeasonUpdateArgs} args - Arguments to update one AwardSeason.
     * @example
     * // Update one AwardSeason
     * const awardSeason = await prisma.awardSeason.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AwardSeasonUpdateArgs>(args: SelectSubset<T, AwardSeasonUpdateArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AwardSeasons.
     * @param {AwardSeasonDeleteManyArgs} args - Arguments to filter AwardSeasons to delete.
     * @example
     * // Delete a few AwardSeasons
     * const { count } = await prisma.awardSeason.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AwardSeasonDeleteManyArgs>(args?: SelectSubset<T, AwardSeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AwardSeasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardSeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AwardSeasons
     * const awardSeason = await prisma.awardSeason.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AwardSeasonUpdateManyArgs>(args: SelectSubset<T, AwardSeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AwardSeason.
     * @param {AwardSeasonUpsertArgs} args - Arguments to update or create a AwardSeason.
     * @example
     * // Update or create a AwardSeason
     * const awardSeason = await prisma.awardSeason.upsert({
     *   create: {
     *     // ... data to create a AwardSeason
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AwardSeason we want to update
     *   }
     * })
     */
    upsert<T extends AwardSeasonUpsertArgs>(args: SelectSubset<T, AwardSeasonUpsertArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AwardSeasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardSeasonCountArgs} args - Arguments to filter AwardSeasons to count.
     * @example
     * // Count the number of AwardSeasons
     * const count = await prisma.awardSeason.count({
     *   where: {
     *     // ... the filter for the AwardSeasons we want to count
     *   }
     * })
    **/
    count<T extends AwardSeasonCountArgs>(
      args?: Subset<T, AwardSeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AwardSeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AwardSeason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardSeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AwardSeasonAggregateArgs>(args: Subset<T, AwardSeasonAggregateArgs>): Prisma.PrismaPromise<GetAwardSeasonAggregateType<T>>

    /**
     * Group by AwardSeason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardSeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AwardSeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AwardSeasonGroupByArgs['orderBy'] }
        : { orderBy?: AwardSeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AwardSeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAwardSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AwardSeason model
   */
  readonly fields: AwardSeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AwardSeason.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AwardSeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends AwardEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AwardEventDefaultArgs<ExtArgs>>): Prisma__AwardEventClient<$Result.GetResult<Prisma.$AwardEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    winners<T extends AwardSeason$winnersArgs<ExtArgs> = {}>(args?: Subset<T, AwardSeason$winnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AwardSeason model
   */ 
  interface AwardSeasonFieldRefs {
    readonly id: FieldRef<"AwardSeason", 'String'>
    readonly eventId: FieldRef<"AwardSeason", 'String'>
    readonly year: FieldRef<"AwardSeason", 'Int'>
    readonly season: FieldRef<"AwardSeason", 'String'>
    readonly phase: FieldRef<"AwardSeason", 'String'>
    readonly date: FieldRef<"AwardSeason", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AwardSeason findUnique
   */
  export type AwardSeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AwardSeason to fetch.
     */
    where: AwardSeasonWhereUniqueInput
  }

  /**
   * AwardSeason findUniqueOrThrow
   */
  export type AwardSeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AwardSeason to fetch.
     */
    where: AwardSeasonWhereUniqueInput
  }

  /**
   * AwardSeason findFirst
   */
  export type AwardSeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AwardSeason to fetch.
     */
    where?: AwardSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardSeasons to fetch.
     */
    orderBy?: AwardSeasonOrderByWithRelationInput | AwardSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AwardSeasons.
     */
    cursor?: AwardSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AwardSeasons.
     */
    distinct?: AwardSeasonScalarFieldEnum | AwardSeasonScalarFieldEnum[]
  }

  /**
   * AwardSeason findFirstOrThrow
   */
  export type AwardSeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AwardSeason to fetch.
     */
    where?: AwardSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardSeasons to fetch.
     */
    orderBy?: AwardSeasonOrderByWithRelationInput | AwardSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AwardSeasons.
     */
    cursor?: AwardSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AwardSeasons.
     */
    distinct?: AwardSeasonScalarFieldEnum | AwardSeasonScalarFieldEnum[]
  }

  /**
   * AwardSeason findMany
   */
  export type AwardSeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AwardSeasons to fetch.
     */
    where?: AwardSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardSeasons to fetch.
     */
    orderBy?: AwardSeasonOrderByWithRelationInput | AwardSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AwardSeasons.
     */
    cursor?: AwardSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardSeasons.
     */
    skip?: number
    distinct?: AwardSeasonScalarFieldEnum | AwardSeasonScalarFieldEnum[]
  }

  /**
   * AwardSeason create
   */
  export type AwardSeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a AwardSeason.
     */
    data: XOR<AwardSeasonCreateInput, AwardSeasonUncheckedCreateInput>
  }

  /**
   * AwardSeason createMany
   */
  export type AwardSeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AwardSeasons.
     */
    data: AwardSeasonCreateManyInput | AwardSeasonCreateManyInput[]
  }

  /**
   * AwardSeason createManyAndReturn
   */
  export type AwardSeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AwardSeasons.
     */
    data: AwardSeasonCreateManyInput | AwardSeasonCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AwardSeason update
   */
  export type AwardSeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a AwardSeason.
     */
    data: XOR<AwardSeasonUpdateInput, AwardSeasonUncheckedUpdateInput>
    /**
     * Choose, which AwardSeason to update.
     */
    where: AwardSeasonWhereUniqueInput
  }

  /**
   * AwardSeason updateMany
   */
  export type AwardSeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AwardSeasons.
     */
    data: XOR<AwardSeasonUpdateManyMutationInput, AwardSeasonUncheckedUpdateManyInput>
    /**
     * Filter which AwardSeasons to update
     */
    where?: AwardSeasonWhereInput
  }

  /**
   * AwardSeason upsert
   */
  export type AwardSeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the AwardSeason to update in case it exists.
     */
    where: AwardSeasonWhereUniqueInput
    /**
     * In case the AwardSeason found by the `where` argument doesn't exist, create a new AwardSeason with this data.
     */
    create: XOR<AwardSeasonCreateInput, AwardSeasonUncheckedCreateInput>
    /**
     * In case the AwardSeason was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AwardSeasonUpdateInput, AwardSeasonUncheckedUpdateInput>
  }

  /**
   * AwardSeason delete
   */
  export type AwardSeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
    /**
     * Filter which AwardSeason to delete.
     */
    where: AwardSeasonWhereUniqueInput
  }

  /**
   * AwardSeason deleteMany
   */
  export type AwardSeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AwardSeasons to delete
     */
    where?: AwardSeasonWhereInput
  }

  /**
   * AwardSeason.winners
   */
  export type AwardSeason$winnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    where?: AwardWinnerWhereInput
    orderBy?: AwardWinnerOrderByWithRelationInput | AwardWinnerOrderByWithRelationInput[]
    cursor?: AwardWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AwardWinnerScalarFieldEnum | AwardWinnerScalarFieldEnum[]
  }

  /**
   * AwardSeason without action
   */
  export type AwardSeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardSeason
     */
    select?: AwardSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardSeasonInclude<ExtArgs> | null
  }


  /**
   * Model Movie
   */

  export type AggregateMovie = {
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  export type MovieAvgAggregateOutputType = {
    tmdbId: number | null
    eligibilityYear: number | null
  }

  export type MovieSumAggregateOutputType = {
    tmdbId: number | null
    eligibilityYear: number | null
  }

  export type MovieMinAggregateOutputType = {
    tmdbId: number | null
    title: string | null
    posterPath: string | null
    backdropPath: string | null
    eligibleDate: Date | null
    eligibilityYear: number | null
    seasonKey: string | null
  }

  export type MovieMaxAggregateOutputType = {
    tmdbId: number | null
    title: string | null
    posterPath: string | null
    backdropPath: string | null
    eligibleDate: Date | null
    eligibilityYear: number | null
    seasonKey: string | null
  }

  export type MovieCountAggregateOutputType = {
    tmdbId: number
    title: number
    posterPath: number
    backdropPath: number
    eligibleDate: number
    eligibilityYear: number
    seasonKey: number
    _all: number
  }


  export type MovieAvgAggregateInputType = {
    tmdbId?: true
    eligibilityYear?: true
  }

  export type MovieSumAggregateInputType = {
    tmdbId?: true
    eligibilityYear?: true
  }

  export type MovieMinAggregateInputType = {
    tmdbId?: true
    title?: true
    posterPath?: true
    backdropPath?: true
    eligibleDate?: true
    eligibilityYear?: true
    seasonKey?: true
  }

  export type MovieMaxAggregateInputType = {
    tmdbId?: true
    title?: true
    posterPath?: true
    backdropPath?: true
    eligibleDate?: true
    eligibilityYear?: true
    seasonKey?: true
  }

  export type MovieCountAggregateInputType = {
    tmdbId?: true
    title?: true
    posterPath?: true
    backdropPath?: true
    eligibleDate?: true
    eligibilityYear?: true
    seasonKey?: true
    _all?: true
  }

  export type MovieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movie to aggregate.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movies
    **/
    _count?: true | MovieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieMaxAggregateInputType
  }

  export type GetMovieAggregateType<T extends MovieAggregateArgs> = {
        [P in keyof T & keyof AggregateMovie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovie[P]>
      : GetScalarType<T[P], AggregateMovie[P]>
  }




  export type MovieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovieWhereInput
    orderBy?: MovieOrderByWithAggregationInput | MovieOrderByWithAggregationInput[]
    by: MovieScalarFieldEnum[] | MovieScalarFieldEnum
    having?: MovieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCountAggregateInputType | true
    _avg?: MovieAvgAggregateInputType
    _sum?: MovieSumAggregateInputType
    _min?: MovieMinAggregateInputType
    _max?: MovieMaxAggregateInputType
  }

  export type MovieGroupByOutputType = {
    tmdbId: number
    title: string
    posterPath: string | null
    backdropPath: string | null
    eligibleDate: Date | null
    eligibilityYear: number | null
    seasonKey: string | null
    _count: MovieCountAggregateOutputType | null
    _avg: MovieAvgAggregateOutputType | null
    _sum: MovieSumAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  type GetMovieGroupByPayload<T extends MovieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieGroupByOutputType[P]>
            : GetScalarType<T[P], MovieGroupByOutputType[P]>
        }
      >
    >


  export type MovieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tmdbId?: boolean
    title?: boolean
    posterPath?: boolean
    backdropPath?: boolean
    eligibleDate?: boolean
    eligibilityYear?: boolean
    seasonKey?: boolean
    winners?: boolean | Movie$winnersArgs<ExtArgs>
    interactions?: boolean | Movie$interactionsArgs<ExtArgs>
    watchLogs?: boolean | Movie$watchLogsArgs<ExtArgs>
    listItems?: boolean | Movie$listItemsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tmdbId?: boolean
    title?: boolean
    posterPath?: boolean
    backdropPath?: boolean
    eligibleDate?: boolean
    eligibilityYear?: boolean
    seasonKey?: boolean
  }, ExtArgs["result"]["movie"]>

  export type MovieSelectScalar = {
    tmdbId?: boolean
    title?: boolean
    posterPath?: boolean
    backdropPath?: boolean
    eligibleDate?: boolean
    eligibilityYear?: boolean
    seasonKey?: boolean
  }

  export type MovieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winners?: boolean | Movie$winnersArgs<ExtArgs>
    interactions?: boolean | Movie$interactionsArgs<ExtArgs>
    watchLogs?: boolean | Movie$watchLogsArgs<ExtArgs>
    listItems?: boolean | Movie$listItemsArgs<ExtArgs>
    _count?: boolean | MovieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MovieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MoviePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movie"
    objects: {
      winners: Prisma.$AwardWinnerPayload<ExtArgs>[]
      interactions: Prisma.$MovieInteractionPayload<ExtArgs>[]
      watchLogs: Prisma.$WatchLogPayload<ExtArgs>[]
      listItems: Prisma.$MovieListItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tmdbId: number
      title: string
      posterPath: string | null
      backdropPath: string | null
      eligibleDate: Date | null
      eligibilityYear: number | null
      seasonKey: string | null
    }, ExtArgs["result"]["movie"]>
    composites: {}
  }

  type MovieGetPayload<S extends boolean | null | undefined | MovieDefaultArgs> = $Result.GetResult<Prisma.$MoviePayload, S>

  type MovieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovieCountAggregateInputType | true
    }

  export interface MovieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movie'], meta: { name: 'Movie' } }
    /**
     * Find zero or one Movie that matches the filter.
     * @param {MovieFindUniqueArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovieFindUniqueArgs>(args: SelectSubset<T, MovieFindUniqueArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Movie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovieFindUniqueOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovieFindUniqueOrThrowArgs>(args: SelectSubset<T, MovieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovieFindFirstArgs>(args?: SelectSubset<T, MovieFindFirstArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Movie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindFirstOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovieFindFirstOrThrowArgs>(args?: SelectSubset<T, MovieFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movie.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movie.findMany({ take: 10 })
     * 
     * // Only select the `tmdbId`
     * const movieWithTmdbIdOnly = await prisma.movie.findMany({ select: { tmdbId: true } })
     * 
     */
    findMany<T extends MovieFindManyArgs>(args?: SelectSubset<T, MovieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Movie.
     * @param {MovieCreateArgs} args - Arguments to create a Movie.
     * @example
     * // Create one Movie
     * const Movie = await prisma.movie.create({
     *   data: {
     *     // ... data to create a Movie
     *   }
     * })
     * 
     */
    create<T extends MovieCreateArgs>(args: SelectSubset<T, MovieCreateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Movies.
     * @param {MovieCreateManyArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovieCreateManyArgs>(args?: SelectSubset<T, MovieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movies and returns the data saved in the database.
     * @param {MovieCreateManyAndReturnArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movie = await prisma.movie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movies and only return the `tmdbId`
     * const movieWithTmdbIdOnly = await prisma.movie.createManyAndReturn({ 
     *   select: { tmdbId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovieCreateManyAndReturnArgs>(args?: SelectSubset<T, MovieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Movie.
     * @param {MovieDeleteArgs} args - Arguments to delete one Movie.
     * @example
     * // Delete one Movie
     * const Movie = await prisma.movie.delete({
     *   where: {
     *     // ... filter to delete one Movie
     *   }
     * })
     * 
     */
    delete<T extends MovieDeleteArgs>(args: SelectSubset<T, MovieDeleteArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Movie.
     * @param {MovieUpdateArgs} args - Arguments to update one Movie.
     * @example
     * // Update one Movie
     * const movie = await prisma.movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovieUpdateArgs>(args: SelectSubset<T, MovieUpdateArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Movies.
     * @param {MovieDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovieDeleteManyArgs>(args?: SelectSubset<T, MovieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovieUpdateManyArgs>(args: SelectSubset<T, MovieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movie.
     * @param {MovieUpsertArgs} args - Arguments to update or create a Movie.
     * @example
     * // Update or create a Movie
     * const movie = await prisma.movie.upsert({
     *   create: {
     *     // ... data to create a Movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movie we want to update
     *   }
     * })
     */
    upsert<T extends MovieUpsertArgs>(args: SelectSubset<T, MovieUpsertArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movie.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends MovieCountArgs>(
      args?: Subset<T, MovieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieAggregateArgs>(args: Subset<T, MovieAggregateArgs>): Prisma.PrismaPromise<GetMovieAggregateType<T>>

    /**
     * Group by Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieGroupByArgs['orderBy'] }
        : { orderBy?: MovieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movie model
   */
  readonly fields: MovieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    winners<T extends Movie$winnersArgs<ExtArgs> = {}>(args?: Subset<T, Movie$winnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "findMany"> | Null>
    interactions<T extends Movie$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieInteractionPayload<ExtArgs>, T, "findMany"> | Null>
    watchLogs<T extends Movie$watchLogsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$watchLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchLogPayload<ExtArgs>, T, "findMany"> | Null>
    listItems<T extends Movie$listItemsArgs<ExtArgs> = {}>(args?: Subset<T, Movie$listItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovieListItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movie model
   */ 
  interface MovieFieldRefs {
    readonly tmdbId: FieldRef<"Movie", 'Int'>
    readonly title: FieldRef<"Movie", 'String'>
    readonly posterPath: FieldRef<"Movie", 'String'>
    readonly backdropPath: FieldRef<"Movie", 'String'>
    readonly eligibleDate: FieldRef<"Movie", 'DateTime'>
    readonly eligibilityYear: FieldRef<"Movie", 'Int'>
    readonly seasonKey: FieldRef<"Movie", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Movie findUnique
   */
  export type MovieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findUniqueOrThrow
   */
  export type MovieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie findFirst
   */
  export type MovieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findFirstOrThrow
   */
  export type MovieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movie to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movies.
     */
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie findMany
   */
  export type MovieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter, which Movies to fetch.
     */
    where?: MovieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movies to fetch.
     */
    orderBy?: MovieOrderByWithRelationInput | MovieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movies.
     */
    cursor?: MovieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movies.
     */
    skip?: number
    distinct?: MovieScalarFieldEnum | MovieScalarFieldEnum[]
  }

  /**
   * Movie create
   */
  export type MovieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to create a Movie.
     */
    data: XOR<MovieCreateInput, MovieUncheckedCreateInput>
  }

  /**
   * Movie createMany
   */
  export type MovieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
  }

  /**
   * Movie createManyAndReturn
   */
  export type MovieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Movies.
     */
    data: MovieCreateManyInput | MovieCreateManyInput[]
  }

  /**
   * Movie update
   */
  export type MovieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The data needed to update a Movie.
     */
    data: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
    /**
     * Choose, which Movie to update.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie updateMany
   */
  export type MovieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movies.
     */
    data: XOR<MovieUpdateManyMutationInput, MovieUncheckedUpdateManyInput>
    /**
     * Filter which Movies to update
     */
    where?: MovieWhereInput
  }

  /**
   * Movie upsert
   */
  export type MovieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * The filter to search for the Movie to update in case it exists.
     */
    where: MovieWhereUniqueInput
    /**
     * In case the Movie found by the `where` argument doesn't exist, create a new Movie with this data.
     */
    create: XOR<MovieCreateInput, MovieUncheckedCreateInput>
    /**
     * In case the Movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovieUpdateInput, MovieUncheckedUpdateInput>
  }

  /**
   * Movie delete
   */
  export type MovieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
    /**
     * Filter which Movie to delete.
     */
    where: MovieWhereUniqueInput
  }

  /**
   * Movie deleteMany
   */
  export type MovieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movies to delete
     */
    where?: MovieWhereInput
  }

  /**
   * Movie.winners
   */
  export type Movie$winnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    where?: AwardWinnerWhereInput
    orderBy?: AwardWinnerOrderByWithRelationInput | AwardWinnerOrderByWithRelationInput[]
    cursor?: AwardWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AwardWinnerScalarFieldEnum | AwardWinnerScalarFieldEnum[]
  }

  /**
   * Movie.interactions
   */
  export type Movie$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieInteraction
     */
    select?: MovieInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInteractionInclude<ExtArgs> | null
    where?: MovieInteractionWhereInput
    orderBy?: MovieInteractionOrderByWithRelationInput | MovieInteractionOrderByWithRelationInput[]
    cursor?: MovieInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieInteractionScalarFieldEnum | MovieInteractionScalarFieldEnum[]
  }

  /**
   * Movie.watchLogs
   */
  export type Movie$watchLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchLog
     */
    select?: WatchLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchLogInclude<ExtArgs> | null
    where?: WatchLogWhereInput
    orderBy?: WatchLogOrderByWithRelationInput | WatchLogOrderByWithRelationInput[]
    cursor?: WatchLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchLogScalarFieldEnum | WatchLogScalarFieldEnum[]
  }

  /**
   * Movie.listItems
   */
  export type Movie$listItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MovieListItem
     */
    select?: MovieListItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieListItemInclude<ExtArgs> | null
    where?: MovieListItemWhereInput
    orderBy?: MovieListItemOrderByWithRelationInput | MovieListItemOrderByWithRelationInput[]
    cursor?: MovieListItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovieListItemScalarFieldEnum | MovieListItemScalarFieldEnum[]
  }

  /**
   * Movie without action
   */
  export type MovieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movie
     */
    select?: MovieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovieInclude<ExtArgs> | null
  }


  /**
   * Model AwardWinner
   */

  export type AggregateAwardWinner = {
    _count: AwardWinnerCountAggregateOutputType | null
    _avg: AwardWinnerAvgAggregateOutputType | null
    _sum: AwardWinnerSumAggregateOutputType | null
    _min: AwardWinnerMinAggregateOutputType | null
    _max: AwardWinnerMaxAggregateOutputType | null
  }

  export type AwardWinnerAvgAggregateOutputType = {
    movieId: number | null
  }

  export type AwardWinnerSumAggregateOutputType = {
    movieId: number | null
  }

  export type AwardWinnerMinAggregateOutputType = {
    id: string | null
    seasonId: string | null
    prizeName: string | null
    movieId: number | null
    movieTitle: string | null
    posterPath: string | null
    personName: string | null
    personPath: string | null
    isWinner: boolean | null
    sourceUrl: string | null
    createdAt: Date | null
  }

  export type AwardWinnerMaxAggregateOutputType = {
    id: string | null
    seasonId: string | null
    prizeName: string | null
    movieId: number | null
    movieTitle: string | null
    posterPath: string | null
    personName: string | null
    personPath: string | null
    isWinner: boolean | null
    sourceUrl: string | null
    createdAt: Date | null
  }

  export type AwardWinnerCountAggregateOutputType = {
    id: number
    seasonId: number
    prizeName: number
    movieId: number
    movieTitle: number
    posterPath: number
    personName: number
    personPath: number
    isWinner: number
    sourceUrl: number
    createdAt: number
    _all: number
  }


  export type AwardWinnerAvgAggregateInputType = {
    movieId?: true
  }

  export type AwardWinnerSumAggregateInputType = {
    movieId?: true
  }

  export type AwardWinnerMinAggregateInputType = {
    id?: true
    seasonId?: true
    prizeName?: true
    movieId?: true
    movieTitle?: true
    posterPath?: true
    personName?: true
    personPath?: true
    isWinner?: true
    sourceUrl?: true
    createdAt?: true
  }

  export type AwardWinnerMaxAggregateInputType = {
    id?: true
    seasonId?: true
    prizeName?: true
    movieId?: true
    movieTitle?: true
    posterPath?: true
    personName?: true
    personPath?: true
    isWinner?: true
    sourceUrl?: true
    createdAt?: true
  }

  export type AwardWinnerCountAggregateInputType = {
    id?: true
    seasonId?: true
    prizeName?: true
    movieId?: true
    movieTitle?: true
    posterPath?: true
    personName?: true
    personPath?: true
    isWinner?: true
    sourceUrl?: true
    createdAt?: true
    _all?: true
  }

  export type AwardWinnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AwardWinner to aggregate.
     */
    where?: AwardWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardWinners to fetch.
     */
    orderBy?: AwardWinnerOrderByWithRelationInput | AwardWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AwardWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AwardWinners
    **/
    _count?: true | AwardWinnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AwardWinnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AwardWinnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AwardWinnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AwardWinnerMaxAggregateInputType
  }

  export type GetAwardWinnerAggregateType<T extends AwardWinnerAggregateArgs> = {
        [P in keyof T & keyof AggregateAwardWinner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAwardWinner[P]>
      : GetScalarType<T[P], AggregateAwardWinner[P]>
  }




  export type AwardWinnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardWinnerWhereInput
    orderBy?: AwardWinnerOrderByWithAggregationInput | AwardWinnerOrderByWithAggregationInput[]
    by: AwardWinnerScalarFieldEnum[] | AwardWinnerScalarFieldEnum
    having?: AwardWinnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AwardWinnerCountAggregateInputType | true
    _avg?: AwardWinnerAvgAggregateInputType
    _sum?: AwardWinnerSumAggregateInputType
    _min?: AwardWinnerMinAggregateInputType
    _max?: AwardWinnerMaxAggregateInputType
  }

  export type AwardWinnerGroupByOutputType = {
    id: string
    seasonId: string
    prizeName: string
    movieId: number
    movieTitle: string
    posterPath: string | null
    personName: string | null
    personPath: string | null
    isWinner: boolean
    sourceUrl: string | null
    createdAt: Date
    _count: AwardWinnerCountAggregateOutputType | null
    _avg: AwardWinnerAvgAggregateOutputType | null
    _sum: AwardWinnerSumAggregateOutputType | null
    _min: AwardWinnerMinAggregateOutputType | null
    _max: AwardWinnerMaxAggregateOutputType | null
  }

  type GetAwardWinnerGroupByPayload<T extends AwardWinnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AwardWinnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AwardWinnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AwardWinnerGroupByOutputType[P]>
            : GetScalarType<T[P], AwardWinnerGroupByOutputType[P]>
        }
      >
    >


  export type AwardWinnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    prizeName?: boolean
    movieId?: boolean
    movieTitle?: boolean
    posterPath?: boolean
    personName?: boolean
    personPath?: boolean
    isWinner?: boolean
    sourceUrl?: boolean
    createdAt?: boolean
    seasonRel?: boolean | AwardSeasonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awardWinner"]>

  export type AwardWinnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonId?: boolean
    prizeName?: boolean
    movieId?: boolean
    movieTitle?: boolean
    posterPath?: boolean
    personName?: boolean
    personPath?: boolean
    isWinner?: boolean
    sourceUrl?: boolean
    createdAt?: boolean
    seasonRel?: boolean | AwardSeasonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awardWinner"]>

  export type AwardWinnerSelectScalar = {
    id?: boolean
    seasonId?: boolean
    prizeName?: boolean
    movieId?: boolean
    movieTitle?: boolean
    posterPath?: boolean
    personName?: boolean
    personPath?: boolean
    isWinner?: boolean
    sourceUrl?: boolean
    createdAt?: boolean
  }

  export type AwardWinnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasonRel?: boolean | AwardSeasonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }
  export type AwardWinnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasonRel?: boolean | AwardSeasonDefaultArgs<ExtArgs>
    movie?: boolean | MovieDefaultArgs<ExtArgs>
  }

  export type $AwardWinnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AwardWinner"
    objects: {
      seasonRel: Prisma.$AwardSeasonPayload<ExtArgs>
      movie: Prisma.$MoviePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seasonId: string
      prizeName: string
      movieId: number
      movieTitle: string
      posterPath: string | null
      personName: string | null
      personPath: string | null
      isWinner: boolean
      sourceUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["awardWinner"]>
    composites: {}
  }

  type AwardWinnerGetPayload<S extends boolean | null | undefined | AwardWinnerDefaultArgs> = $Result.GetResult<Prisma.$AwardWinnerPayload, S>

  type AwardWinnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AwardWinnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AwardWinnerCountAggregateInputType | true
    }

  export interface AwardWinnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AwardWinner'], meta: { name: 'AwardWinner' } }
    /**
     * Find zero or one AwardWinner that matches the filter.
     * @param {AwardWinnerFindUniqueArgs} args - Arguments to find a AwardWinner
     * @example
     * // Get one AwardWinner
     * const awardWinner = await prisma.awardWinner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AwardWinnerFindUniqueArgs>(args: SelectSubset<T, AwardWinnerFindUniqueArgs<ExtArgs>>): Prisma__AwardWinnerClient<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AwardWinner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AwardWinnerFindUniqueOrThrowArgs} args - Arguments to find a AwardWinner
     * @example
     * // Get one AwardWinner
     * const awardWinner = await prisma.awardWinner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AwardWinnerFindUniqueOrThrowArgs>(args: SelectSubset<T, AwardWinnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AwardWinnerClient<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AwardWinner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardWinnerFindFirstArgs} args - Arguments to find a AwardWinner
     * @example
     * // Get one AwardWinner
     * const awardWinner = await prisma.awardWinner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AwardWinnerFindFirstArgs>(args?: SelectSubset<T, AwardWinnerFindFirstArgs<ExtArgs>>): Prisma__AwardWinnerClient<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AwardWinner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardWinnerFindFirstOrThrowArgs} args - Arguments to find a AwardWinner
     * @example
     * // Get one AwardWinner
     * const awardWinner = await prisma.awardWinner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AwardWinnerFindFirstOrThrowArgs>(args?: SelectSubset<T, AwardWinnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AwardWinnerClient<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AwardWinners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardWinnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AwardWinners
     * const awardWinners = await prisma.awardWinner.findMany()
     * 
     * // Get first 10 AwardWinners
     * const awardWinners = await prisma.awardWinner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const awardWinnerWithIdOnly = await prisma.awardWinner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AwardWinnerFindManyArgs>(args?: SelectSubset<T, AwardWinnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AwardWinner.
     * @param {AwardWinnerCreateArgs} args - Arguments to create a AwardWinner.
     * @example
     * // Create one AwardWinner
     * const AwardWinner = await prisma.awardWinner.create({
     *   data: {
     *     // ... data to create a AwardWinner
     *   }
     * })
     * 
     */
    create<T extends AwardWinnerCreateArgs>(args: SelectSubset<T, AwardWinnerCreateArgs<ExtArgs>>): Prisma__AwardWinnerClient<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AwardWinners.
     * @param {AwardWinnerCreateManyArgs} args - Arguments to create many AwardWinners.
     * @example
     * // Create many AwardWinners
     * const awardWinner = await prisma.awardWinner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AwardWinnerCreateManyArgs>(args?: SelectSubset<T, AwardWinnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AwardWinners and returns the data saved in the database.
     * @param {AwardWinnerCreateManyAndReturnArgs} args - Arguments to create many AwardWinners.
     * @example
     * // Create many AwardWinners
     * const awardWinner = await prisma.awardWinner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AwardWinners and only return the `id`
     * const awardWinnerWithIdOnly = await prisma.awardWinner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AwardWinnerCreateManyAndReturnArgs>(args?: SelectSubset<T, AwardWinnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AwardWinner.
     * @param {AwardWinnerDeleteArgs} args - Arguments to delete one AwardWinner.
     * @example
     * // Delete one AwardWinner
     * const AwardWinner = await prisma.awardWinner.delete({
     *   where: {
     *     // ... filter to delete one AwardWinner
     *   }
     * })
     * 
     */
    delete<T extends AwardWinnerDeleteArgs>(args: SelectSubset<T, AwardWinnerDeleteArgs<ExtArgs>>): Prisma__AwardWinnerClient<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AwardWinner.
     * @param {AwardWinnerUpdateArgs} args - Arguments to update one AwardWinner.
     * @example
     * // Update one AwardWinner
     * const awardWinner = await prisma.awardWinner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AwardWinnerUpdateArgs>(args: SelectSubset<T, AwardWinnerUpdateArgs<ExtArgs>>): Prisma__AwardWinnerClient<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AwardWinners.
     * @param {AwardWinnerDeleteManyArgs} args - Arguments to filter AwardWinners to delete.
     * @example
     * // Delete a few AwardWinners
     * const { count } = await prisma.awardWinner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AwardWinnerDeleteManyArgs>(args?: SelectSubset<T, AwardWinnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AwardWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardWinnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AwardWinners
     * const awardWinner = await prisma.awardWinner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AwardWinnerUpdateManyArgs>(args: SelectSubset<T, AwardWinnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AwardWinner.
     * @param {AwardWinnerUpsertArgs} args - Arguments to update or create a AwardWinner.
     * @example
     * // Update or create a AwardWinner
     * const awardWinner = await prisma.awardWinner.upsert({
     *   create: {
     *     // ... data to create a AwardWinner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AwardWinner we want to update
     *   }
     * })
     */
    upsert<T extends AwardWinnerUpsertArgs>(args: SelectSubset<T, AwardWinnerUpsertArgs<ExtArgs>>): Prisma__AwardWinnerClient<$Result.GetResult<Prisma.$AwardWinnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AwardWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardWinnerCountArgs} args - Arguments to filter AwardWinners to count.
     * @example
     * // Count the number of AwardWinners
     * const count = await prisma.awardWinner.count({
     *   where: {
     *     // ... the filter for the AwardWinners we want to count
     *   }
     * })
    **/
    count<T extends AwardWinnerCountArgs>(
      args?: Subset<T, AwardWinnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AwardWinnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AwardWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardWinnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AwardWinnerAggregateArgs>(args: Subset<T, AwardWinnerAggregateArgs>): Prisma.PrismaPromise<GetAwardWinnerAggregateType<T>>

    /**
     * Group by AwardWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardWinnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AwardWinnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AwardWinnerGroupByArgs['orderBy'] }
        : { orderBy?: AwardWinnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AwardWinnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAwardWinnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AwardWinner model
   */
  readonly fields: AwardWinnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AwardWinner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AwardWinnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seasonRel<T extends AwardSeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AwardSeasonDefaultArgs<ExtArgs>>): Prisma__AwardSeasonClient<$Result.GetResult<Prisma.$AwardSeasonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movie<T extends MovieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MovieDefaultArgs<ExtArgs>>): Prisma__MovieClient<$Result.GetResult<Prisma.$MoviePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AwardWinner model
   */ 
  interface AwardWinnerFieldRefs {
    readonly id: FieldRef<"AwardWinner", 'String'>
    readonly seasonId: FieldRef<"AwardWinner", 'String'>
    readonly prizeName: FieldRef<"AwardWinner", 'String'>
    readonly movieId: FieldRef<"AwardWinner", 'Int'>
    readonly movieTitle: FieldRef<"AwardWinner", 'String'>
    readonly posterPath: FieldRef<"AwardWinner", 'String'>
    readonly personName: FieldRef<"AwardWinner", 'String'>
    readonly personPath: FieldRef<"AwardWinner", 'String'>
    readonly isWinner: FieldRef<"AwardWinner", 'Boolean'>
    readonly sourceUrl: FieldRef<"AwardWinner", 'String'>
    readonly createdAt: FieldRef<"AwardWinner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AwardWinner findUnique
   */
  export type AwardWinnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * Filter, which AwardWinner to fetch.
     */
    where: AwardWinnerWhereUniqueInput
  }

  /**
   * AwardWinner findUniqueOrThrow
   */
  export type AwardWinnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * Filter, which AwardWinner to fetch.
     */
    where: AwardWinnerWhereUniqueInput
  }

  /**
   * AwardWinner findFirst
   */
  export type AwardWinnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * Filter, which AwardWinner to fetch.
     */
    where?: AwardWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardWinners to fetch.
     */
    orderBy?: AwardWinnerOrderByWithRelationInput | AwardWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AwardWinners.
     */
    cursor?: AwardWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AwardWinners.
     */
    distinct?: AwardWinnerScalarFieldEnum | AwardWinnerScalarFieldEnum[]
  }

  /**
   * AwardWinner findFirstOrThrow
   */
  export type AwardWinnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * Filter, which AwardWinner to fetch.
     */
    where?: AwardWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardWinners to fetch.
     */
    orderBy?: AwardWinnerOrderByWithRelationInput | AwardWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AwardWinners.
     */
    cursor?: AwardWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AwardWinners.
     */
    distinct?: AwardWinnerScalarFieldEnum | AwardWinnerScalarFieldEnum[]
  }

  /**
   * AwardWinner findMany
   */
  export type AwardWinnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * Filter, which AwardWinners to fetch.
     */
    where?: AwardWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AwardWinners to fetch.
     */
    orderBy?: AwardWinnerOrderByWithRelationInput | AwardWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AwardWinners.
     */
    cursor?: AwardWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AwardWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AwardWinners.
     */
    skip?: number
    distinct?: AwardWinnerScalarFieldEnum | AwardWinnerScalarFieldEnum[]
  }

  /**
   * AwardWinner create
   */
  export type AwardWinnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * The data needed to create a AwardWinner.
     */
    data: XOR<AwardWinnerCreateInput, AwardWinnerUncheckedCreateInput>
  }

  /**
   * AwardWinner createMany
   */
  export type AwardWinnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AwardWinners.
     */
    data: AwardWinnerCreateManyInput | AwardWinnerCreateManyInput[]
  }

  /**
   * AwardWinner createManyAndReturn
   */
  export type AwardWinnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AwardWinners.
     */
    data: AwardWinnerCreateManyInput | AwardWinnerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AwardWinner update
   */
  export type AwardWinnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * The data needed to update a AwardWinner.
     */
    data: XOR<AwardWinnerUpdateInput, AwardWinnerUncheckedUpdateInput>
    /**
     * Choose, which AwardWinner to update.
     */
    where: AwardWinnerWhereUniqueInput
  }

  /**
   * AwardWinner updateMany
   */
  export type AwardWinnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AwardWinners.
     */
    data: XOR<AwardWinnerUpdateManyMutationInput, AwardWinnerUncheckedUpdateManyInput>
    /**
     * Filter which AwardWinners to update
     */
    where?: AwardWinnerWhereInput
  }

  /**
   * AwardWinner upsert
   */
  export type AwardWinnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * The filter to search for the AwardWinner to update in case it exists.
     */
    where: AwardWinnerWhereUniqueInput
    /**
     * In case the AwardWinner found by the `where` argument doesn't exist, create a new AwardWinner with this data.
     */
    create: XOR<AwardWinnerCreateInput, AwardWinnerUncheckedCreateInput>
    /**
     * In case the AwardWinner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AwardWinnerUpdateInput, AwardWinnerUncheckedUpdateInput>
  }

  /**
   * AwardWinner delete
   */
  export type AwardWinnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
    /**
     * Filter which AwardWinner to delete.
     */
    where: AwardWinnerWhereUniqueInput
  }

  /**
   * AwardWinner deleteMany
   */
  export type AwardWinnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AwardWinners to delete
     */
    where?: AwardWinnerWhereInput
  }

  /**
   * AwardWinner without action
   */
  export type AwardWinnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AwardWinner
     */
    select?: AwardWinnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardWinnerInclude<ExtArgs> | null
  }


  /**
   * Model StreamingSubscription
   */

  export type AggregateStreamingSubscription = {
    _count: StreamingSubscriptionCountAggregateOutputType | null
    _avg: StreamingSubscriptionAvgAggregateOutputType | null
    _sum: StreamingSubscriptionSumAggregateOutputType | null
    _min: StreamingSubscriptionMinAggregateOutputType | null
    _max: StreamingSubscriptionMaxAggregateOutputType | null
  }

  export type StreamingSubscriptionAvgAggregateOutputType = {
    providerId: number | null
  }

  export type StreamingSubscriptionSumAggregateOutputType = {
    providerId: number | null
  }

  export type StreamingSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    providerId: number | null
    name: string | null
    logoPath: string | null
    createdAt: Date | null
  }

  export type StreamingSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    providerId: number | null
    name: string | null
    logoPath: string | null
    createdAt: Date | null
  }

  export type StreamingSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    providerId: number
    name: number
    logoPath: number
    createdAt: number
    _all: number
  }


  export type StreamingSubscriptionAvgAggregateInputType = {
    providerId?: true
  }

  export type StreamingSubscriptionSumAggregateInputType = {
    providerId?: true
  }

  export type StreamingSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    providerId?: true
    name?: true
    logoPath?: true
    createdAt?: true
  }

  export type StreamingSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    providerId?: true
    name?: true
    logoPath?: true
    createdAt?: true
  }

  export type StreamingSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    providerId?: true
    name?: true
    logoPath?: true
    createdAt?: true
    _all?: true
  }

  export type StreamingSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StreamingSubscription to aggregate.
     */
    where?: StreamingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreamingSubscriptions to fetch.
     */
    orderBy?: StreamingSubscriptionOrderByWithRelationInput | StreamingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreamingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreamingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreamingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StreamingSubscriptions
    **/
    _count?: true | StreamingSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StreamingSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StreamingSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreamingSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreamingSubscriptionMaxAggregateInputType
  }

  export type GetStreamingSubscriptionAggregateType<T extends StreamingSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateStreamingSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStreamingSubscription[P]>
      : GetScalarType<T[P], AggregateStreamingSubscription[P]>
  }




  export type StreamingSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreamingSubscriptionWhereInput
    orderBy?: StreamingSubscriptionOrderByWithAggregationInput | StreamingSubscriptionOrderByWithAggregationInput[]
    by: StreamingSubscriptionScalarFieldEnum[] | StreamingSubscriptionScalarFieldEnum
    having?: StreamingSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreamingSubscriptionCountAggregateInputType | true
    _avg?: StreamingSubscriptionAvgAggregateInputType
    _sum?: StreamingSubscriptionSumAggregateInputType
    _min?: StreamingSubscriptionMinAggregateInputType
    _max?: StreamingSubscriptionMaxAggregateInputType
  }

  export type StreamingSubscriptionGroupByOutputType = {
    id: string
    userId: string
    providerId: number
    name: string
    logoPath: string | null
    createdAt: Date
    _count: StreamingSubscriptionCountAggregateOutputType | null
    _avg: StreamingSubscriptionAvgAggregateOutputType | null
    _sum: StreamingSubscriptionSumAggregateOutputType | null
    _min: StreamingSubscriptionMinAggregateOutputType | null
    _max: StreamingSubscriptionMaxAggregateOutputType | null
  }

  type GetStreamingSubscriptionGroupByPayload<T extends StreamingSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreamingSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreamingSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreamingSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], StreamingSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type StreamingSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerId?: boolean
    name?: boolean
    logoPath?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streamingSubscription"]>

  export type StreamingSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    providerId?: boolean
    name?: boolean
    logoPath?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streamingSubscription"]>

  export type StreamingSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    providerId?: boolean
    name?: boolean
    logoPath?: boolean
    createdAt?: boolean
  }

  export type StreamingSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StreamingSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StreamingSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StreamingSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      providerId: number
      name: string
      logoPath: string | null
      createdAt: Date
    }, ExtArgs["result"]["streamingSubscription"]>
    composites: {}
  }

  type StreamingSubscriptionGetPayload<S extends boolean | null | undefined | StreamingSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$StreamingSubscriptionPayload, S>

  type StreamingSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StreamingSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StreamingSubscriptionCountAggregateInputType | true
    }

  export interface StreamingSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StreamingSubscription'], meta: { name: 'StreamingSubscription' } }
    /**
     * Find zero or one StreamingSubscription that matches the filter.
     * @param {StreamingSubscriptionFindUniqueArgs} args - Arguments to find a StreamingSubscription
     * @example
     * // Get one StreamingSubscription
     * const streamingSubscription = await prisma.streamingSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StreamingSubscriptionFindUniqueArgs>(args: SelectSubset<T, StreamingSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__StreamingSubscriptionClient<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StreamingSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StreamingSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a StreamingSubscription
     * @example
     * // Get one StreamingSubscription
     * const streamingSubscription = await prisma.streamingSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StreamingSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, StreamingSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StreamingSubscriptionClient<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StreamingSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamingSubscriptionFindFirstArgs} args - Arguments to find a StreamingSubscription
     * @example
     * // Get one StreamingSubscription
     * const streamingSubscription = await prisma.streamingSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StreamingSubscriptionFindFirstArgs>(args?: SelectSubset<T, StreamingSubscriptionFindFirstArgs<ExtArgs>>): Prisma__StreamingSubscriptionClient<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StreamingSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamingSubscriptionFindFirstOrThrowArgs} args - Arguments to find a StreamingSubscription
     * @example
     * // Get one StreamingSubscription
     * const streamingSubscription = await prisma.streamingSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StreamingSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, StreamingSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StreamingSubscriptionClient<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StreamingSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamingSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StreamingSubscriptions
     * const streamingSubscriptions = await prisma.streamingSubscription.findMany()
     * 
     * // Get first 10 StreamingSubscriptions
     * const streamingSubscriptions = await prisma.streamingSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const streamingSubscriptionWithIdOnly = await prisma.streamingSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StreamingSubscriptionFindManyArgs>(args?: SelectSubset<T, StreamingSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StreamingSubscription.
     * @param {StreamingSubscriptionCreateArgs} args - Arguments to create a StreamingSubscription.
     * @example
     * // Create one StreamingSubscription
     * const StreamingSubscription = await prisma.streamingSubscription.create({
     *   data: {
     *     // ... data to create a StreamingSubscription
     *   }
     * })
     * 
     */
    create<T extends StreamingSubscriptionCreateArgs>(args: SelectSubset<T, StreamingSubscriptionCreateArgs<ExtArgs>>): Prisma__StreamingSubscriptionClient<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StreamingSubscriptions.
     * @param {StreamingSubscriptionCreateManyArgs} args - Arguments to create many StreamingSubscriptions.
     * @example
     * // Create many StreamingSubscriptions
     * const streamingSubscription = await prisma.streamingSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StreamingSubscriptionCreateManyArgs>(args?: SelectSubset<T, StreamingSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StreamingSubscriptions and returns the data saved in the database.
     * @param {StreamingSubscriptionCreateManyAndReturnArgs} args - Arguments to create many StreamingSubscriptions.
     * @example
     * // Create many StreamingSubscriptions
     * const streamingSubscription = await prisma.streamingSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StreamingSubscriptions and only return the `id`
     * const streamingSubscriptionWithIdOnly = await prisma.streamingSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StreamingSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, StreamingSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StreamingSubscription.
     * @param {StreamingSubscriptionDeleteArgs} args - Arguments to delete one StreamingSubscription.
     * @example
     * // Delete one StreamingSubscription
     * const StreamingSubscription = await prisma.streamingSubscription.delete({
     *   where: {
     *     // ... filter to delete one StreamingSubscription
     *   }
     * })
     * 
     */
    delete<T extends StreamingSubscriptionDeleteArgs>(args: SelectSubset<T, StreamingSubscriptionDeleteArgs<ExtArgs>>): Prisma__StreamingSubscriptionClient<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StreamingSubscription.
     * @param {StreamingSubscriptionUpdateArgs} args - Arguments to update one StreamingSubscription.
     * @example
     * // Update one StreamingSubscription
     * const streamingSubscription = await prisma.streamingSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StreamingSubscriptionUpdateArgs>(args: SelectSubset<T, StreamingSubscriptionUpdateArgs<ExtArgs>>): Prisma__StreamingSubscriptionClient<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StreamingSubscriptions.
     * @param {StreamingSubscriptionDeleteManyArgs} args - Arguments to filter StreamingSubscriptions to delete.
     * @example
     * // Delete a few StreamingSubscriptions
     * const { count } = await prisma.streamingSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StreamingSubscriptionDeleteManyArgs>(args?: SelectSubset<T, StreamingSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StreamingSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamingSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StreamingSubscriptions
     * const streamingSubscription = await prisma.streamingSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StreamingSubscriptionUpdateManyArgs>(args: SelectSubset<T, StreamingSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StreamingSubscription.
     * @param {StreamingSubscriptionUpsertArgs} args - Arguments to update or create a StreamingSubscription.
     * @example
     * // Update or create a StreamingSubscription
     * const streamingSubscription = await prisma.streamingSubscription.upsert({
     *   create: {
     *     // ... data to create a StreamingSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StreamingSubscription we want to update
     *   }
     * })
     */
    upsert<T extends StreamingSubscriptionUpsertArgs>(args: SelectSubset<T, StreamingSubscriptionUpsertArgs<ExtArgs>>): Prisma__StreamingSubscriptionClient<$Result.GetResult<Prisma.$StreamingSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StreamingSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamingSubscriptionCountArgs} args - Arguments to filter StreamingSubscriptions to count.
     * @example
     * // Count the number of StreamingSubscriptions
     * const count = await prisma.streamingSubscription.count({
     *   where: {
     *     // ... the filter for the StreamingSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends StreamingSubscriptionCountArgs>(
      args?: Subset<T, StreamingSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreamingSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StreamingSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamingSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreamingSubscriptionAggregateArgs>(args: Subset<T, StreamingSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetStreamingSubscriptionAggregateType<T>>

    /**
     * Group by StreamingSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreamingSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreamingSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreamingSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: StreamingSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreamingSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreamingSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StreamingSubscription model
   */
  readonly fields: StreamingSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StreamingSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreamingSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StreamingSubscription model
   */ 
  interface StreamingSubscriptionFieldRefs {
    readonly id: FieldRef<"StreamingSubscription", 'String'>
    readonly userId: FieldRef<"StreamingSubscription", 'String'>
    readonly providerId: FieldRef<"StreamingSubscription", 'Int'>
    readonly name: FieldRef<"StreamingSubscription", 'String'>
    readonly logoPath: FieldRef<"StreamingSubscription", 'String'>
    readonly createdAt: FieldRef<"StreamingSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StreamingSubscription findUnique
   */
  export type StreamingSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StreamingSubscription to fetch.
     */
    where: StreamingSubscriptionWhereUniqueInput
  }

  /**
   * StreamingSubscription findUniqueOrThrow
   */
  export type StreamingSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StreamingSubscription to fetch.
     */
    where: StreamingSubscriptionWhereUniqueInput
  }

  /**
   * StreamingSubscription findFirst
   */
  export type StreamingSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StreamingSubscription to fetch.
     */
    where?: StreamingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreamingSubscriptions to fetch.
     */
    orderBy?: StreamingSubscriptionOrderByWithRelationInput | StreamingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StreamingSubscriptions.
     */
    cursor?: StreamingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreamingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreamingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StreamingSubscriptions.
     */
    distinct?: StreamingSubscriptionScalarFieldEnum | StreamingSubscriptionScalarFieldEnum[]
  }

  /**
   * StreamingSubscription findFirstOrThrow
   */
  export type StreamingSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StreamingSubscription to fetch.
     */
    where?: StreamingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreamingSubscriptions to fetch.
     */
    orderBy?: StreamingSubscriptionOrderByWithRelationInput | StreamingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StreamingSubscriptions.
     */
    cursor?: StreamingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreamingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreamingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StreamingSubscriptions.
     */
    distinct?: StreamingSubscriptionScalarFieldEnum | StreamingSubscriptionScalarFieldEnum[]
  }

  /**
   * StreamingSubscription findMany
   */
  export type StreamingSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StreamingSubscriptions to fetch.
     */
    where?: StreamingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StreamingSubscriptions to fetch.
     */
    orderBy?: StreamingSubscriptionOrderByWithRelationInput | StreamingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StreamingSubscriptions.
     */
    cursor?: StreamingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StreamingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StreamingSubscriptions.
     */
    skip?: number
    distinct?: StreamingSubscriptionScalarFieldEnum | StreamingSubscriptionScalarFieldEnum[]
  }

  /**
   * StreamingSubscription create
   */
  export type StreamingSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a StreamingSubscription.
     */
    data: XOR<StreamingSubscriptionCreateInput, StreamingSubscriptionUncheckedCreateInput>
  }

  /**
   * StreamingSubscription createMany
   */
  export type StreamingSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StreamingSubscriptions.
     */
    data: StreamingSubscriptionCreateManyInput | StreamingSubscriptionCreateManyInput[]
  }

  /**
   * StreamingSubscription createManyAndReturn
   */
  export type StreamingSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StreamingSubscriptions.
     */
    data: StreamingSubscriptionCreateManyInput | StreamingSubscriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StreamingSubscription update
   */
  export type StreamingSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a StreamingSubscription.
     */
    data: XOR<StreamingSubscriptionUpdateInput, StreamingSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which StreamingSubscription to update.
     */
    where: StreamingSubscriptionWhereUniqueInput
  }

  /**
   * StreamingSubscription updateMany
   */
  export type StreamingSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StreamingSubscriptions.
     */
    data: XOR<StreamingSubscriptionUpdateManyMutationInput, StreamingSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which StreamingSubscriptions to update
     */
    where?: StreamingSubscriptionWhereInput
  }

  /**
   * StreamingSubscription upsert
   */
  export type StreamingSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the StreamingSubscription to update in case it exists.
     */
    where: StreamingSubscriptionWhereUniqueInput
    /**
     * In case the StreamingSubscription found by the `where` argument doesn't exist, create a new StreamingSubscription with this data.
     */
    create: XOR<StreamingSubscriptionCreateInput, StreamingSubscriptionUncheckedCreateInput>
    /**
     * In case the StreamingSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreamingSubscriptionUpdateInput, StreamingSubscriptionUncheckedUpdateInput>
  }

  /**
   * StreamingSubscription delete
   */
  export type StreamingSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which StreamingSubscription to delete.
     */
    where: StreamingSubscriptionWhereUniqueInput
  }

  /**
   * StreamingSubscription deleteMany
   */
  export type StreamingSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StreamingSubscriptions to delete
     */
    where?: StreamingSubscriptionWhereInput
  }

  /**
   * StreamingSubscription without action
   */
  export type StreamingSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StreamingSubscription
     */
    select?: StreamingSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreamingSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsAvgAggregateOutputType = {
    runtimeMin: number | null
    runtimeMax: number | null
  }

  export type UserSettingsSumAggregateOutputType = {
    runtimeMin: number | null
    runtimeMax: number | null
  }

  export type UserSettingsMinAggregateOutputType = {
    userId: string | null
    providerMode: string | null
    region: string | null
    runtimeMin: number | null
    runtimeMax: number | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    userId: string | null
    providerMode: string | null
    region: string | null
    runtimeMin: number | null
    runtimeMax: number | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    userId: number
    providerMode: number
    region: number
    runtimeMin: number
    runtimeMax: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsAvgAggregateInputType = {
    runtimeMin?: true
    runtimeMax?: true
  }

  export type UserSettingsSumAggregateInputType = {
    runtimeMin?: true
    runtimeMax?: true
  }

  export type UserSettingsMinAggregateInputType = {
    userId?: true
    providerMode?: true
    region?: true
    runtimeMin?: true
    runtimeMax?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    userId?: true
    providerMode?: true
    region?: true
    runtimeMin?: true
    runtimeMax?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    userId?: true
    providerMode?: true
    region?: true
    runtimeMin?: true
    runtimeMax?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _avg?: UserSettingsAvgAggregateInputType
    _sum?: UserSettingsSumAggregateInputType
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    userId: string
    providerMode: string
    region: string | null
    runtimeMin: number | null
    runtimeMax: number | null
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    providerMode?: boolean
    region?: boolean
    runtimeMin?: boolean
    runtimeMax?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    providerMode?: boolean
    region?: boolean
    runtimeMin?: boolean
    runtimeMax?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    userId?: boolean
    providerMode?: boolean
    region?: boolean
    runtimeMin?: boolean
    runtimeMax?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      providerMode: string
      region: string | null
      runtimeMin: number | null
      runtimeMax: number | null
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */ 
  interface UserSettingsFieldRefs {
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly providerMode: FieldRef<"UserSettings", 'String'>
    readonly region: FieldRef<"UserSettings", 'String'>
    readonly runtimeMin: FieldRef<"UserSettings", 'Int'>
    readonly runtimeMax: FieldRef<"UserSettings", 'Int'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model OnboardingState
   */

  export type AggregateOnboardingState = {
    _count: OnboardingStateCountAggregateOutputType | null
    _min: OnboardingStateMinAggregateOutputType | null
    _max: OnboardingStateMaxAggregateOutputType | null
  }

  export type OnboardingStateMinAggregateOutputType = {
    userId: string | null
    isCompleted: boolean | null
    completedAt: Date | null
    lastNudgedAt: Date | null
    updatedAt: Date | null
  }

  export type OnboardingStateMaxAggregateOutputType = {
    userId: string | null
    isCompleted: boolean | null
    completedAt: Date | null
    lastNudgedAt: Date | null
    updatedAt: Date | null
  }

  export type OnboardingStateCountAggregateOutputType = {
    userId: number
    isCompleted: number
    completedAt: number
    lastNudgedAt: number
    updatedAt: number
    _all: number
  }


  export type OnboardingStateMinAggregateInputType = {
    userId?: true
    isCompleted?: true
    completedAt?: true
    lastNudgedAt?: true
    updatedAt?: true
  }

  export type OnboardingStateMaxAggregateInputType = {
    userId?: true
    isCompleted?: true
    completedAt?: true
    lastNudgedAt?: true
    updatedAt?: true
  }

  export type OnboardingStateCountAggregateInputType = {
    userId?: true
    isCompleted?: true
    completedAt?: true
    lastNudgedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OnboardingStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingState to aggregate.
     */
    where?: OnboardingStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingStates to fetch.
     */
    orderBy?: OnboardingStateOrderByWithRelationInput | OnboardingStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OnboardingStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OnboardingStates
    **/
    _count?: true | OnboardingStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OnboardingStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OnboardingStateMaxAggregateInputType
  }

  export type GetOnboardingStateAggregateType<T extends OnboardingStateAggregateArgs> = {
        [P in keyof T & keyof AggregateOnboardingState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOnboardingState[P]>
      : GetScalarType<T[P], AggregateOnboardingState[P]>
  }




  export type OnboardingStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OnboardingStateWhereInput
    orderBy?: OnboardingStateOrderByWithAggregationInput | OnboardingStateOrderByWithAggregationInput[]
    by: OnboardingStateScalarFieldEnum[] | OnboardingStateScalarFieldEnum
    having?: OnboardingStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OnboardingStateCountAggregateInputType | true
    _min?: OnboardingStateMinAggregateInputType
    _max?: OnboardingStateMaxAggregateInputType
  }

  export type OnboardingStateGroupByOutputType = {
    userId: string
    isCompleted: boolean
    completedAt: Date | null
    lastNudgedAt: Date | null
    updatedAt: Date
    _count: OnboardingStateCountAggregateOutputType | null
    _min: OnboardingStateMinAggregateOutputType | null
    _max: OnboardingStateMaxAggregateOutputType | null
  }

  type GetOnboardingStateGroupByPayload<T extends OnboardingStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OnboardingStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OnboardingStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OnboardingStateGroupByOutputType[P]>
            : GetScalarType<T[P], OnboardingStateGroupByOutputType[P]>
        }
      >
    >


  export type OnboardingStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    lastNudgedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingState"]>

  export type OnboardingStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    lastNudgedAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["onboardingState"]>

  export type OnboardingStateSelectScalar = {
    userId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    lastNudgedAt?: boolean
    updatedAt?: boolean
  }

  export type OnboardingStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OnboardingStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OnboardingStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OnboardingState"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      isCompleted: boolean
      completedAt: Date | null
      lastNudgedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["onboardingState"]>
    composites: {}
  }

  type OnboardingStateGetPayload<S extends boolean | null | undefined | OnboardingStateDefaultArgs> = $Result.GetResult<Prisma.$OnboardingStatePayload, S>

  type OnboardingStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OnboardingStateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OnboardingStateCountAggregateInputType | true
    }

  export interface OnboardingStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OnboardingState'], meta: { name: 'OnboardingState' } }
    /**
     * Find zero or one OnboardingState that matches the filter.
     * @param {OnboardingStateFindUniqueArgs} args - Arguments to find a OnboardingState
     * @example
     * // Get one OnboardingState
     * const onboardingState = await prisma.onboardingState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OnboardingStateFindUniqueArgs>(args: SelectSubset<T, OnboardingStateFindUniqueArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OnboardingState that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OnboardingStateFindUniqueOrThrowArgs} args - Arguments to find a OnboardingState
     * @example
     * // Get one OnboardingState
     * const onboardingState = await prisma.onboardingState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OnboardingStateFindUniqueOrThrowArgs>(args: SelectSubset<T, OnboardingStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OnboardingState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingStateFindFirstArgs} args - Arguments to find a OnboardingState
     * @example
     * // Get one OnboardingState
     * const onboardingState = await prisma.onboardingState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OnboardingStateFindFirstArgs>(args?: SelectSubset<T, OnboardingStateFindFirstArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OnboardingState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingStateFindFirstOrThrowArgs} args - Arguments to find a OnboardingState
     * @example
     * // Get one OnboardingState
     * const onboardingState = await prisma.onboardingState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OnboardingStateFindFirstOrThrowArgs>(args?: SelectSubset<T, OnboardingStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OnboardingStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OnboardingStates
     * const onboardingStates = await prisma.onboardingState.findMany()
     * 
     * // Get first 10 OnboardingStates
     * const onboardingStates = await prisma.onboardingState.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const onboardingStateWithUserIdOnly = await prisma.onboardingState.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends OnboardingStateFindManyArgs>(args?: SelectSubset<T, OnboardingStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OnboardingState.
     * @param {OnboardingStateCreateArgs} args - Arguments to create a OnboardingState.
     * @example
     * // Create one OnboardingState
     * const OnboardingState = await prisma.onboardingState.create({
     *   data: {
     *     // ... data to create a OnboardingState
     *   }
     * })
     * 
     */
    create<T extends OnboardingStateCreateArgs>(args: SelectSubset<T, OnboardingStateCreateArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OnboardingStates.
     * @param {OnboardingStateCreateManyArgs} args - Arguments to create many OnboardingStates.
     * @example
     * // Create many OnboardingStates
     * const onboardingState = await prisma.onboardingState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OnboardingStateCreateManyArgs>(args?: SelectSubset<T, OnboardingStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OnboardingStates and returns the data saved in the database.
     * @param {OnboardingStateCreateManyAndReturnArgs} args - Arguments to create many OnboardingStates.
     * @example
     * // Create many OnboardingStates
     * const onboardingState = await prisma.onboardingState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OnboardingStates and only return the `userId`
     * const onboardingStateWithUserIdOnly = await prisma.onboardingState.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OnboardingStateCreateManyAndReturnArgs>(args?: SelectSubset<T, OnboardingStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OnboardingState.
     * @param {OnboardingStateDeleteArgs} args - Arguments to delete one OnboardingState.
     * @example
     * // Delete one OnboardingState
     * const OnboardingState = await prisma.onboardingState.delete({
     *   where: {
     *     // ... filter to delete one OnboardingState
     *   }
     * })
     * 
     */
    delete<T extends OnboardingStateDeleteArgs>(args: SelectSubset<T, OnboardingStateDeleteArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OnboardingState.
     * @param {OnboardingStateUpdateArgs} args - Arguments to update one OnboardingState.
     * @example
     * // Update one OnboardingState
     * const onboardingState = await prisma.onboardingState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OnboardingStateUpdateArgs>(args: SelectSubset<T, OnboardingStateUpdateArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OnboardingStates.
     * @param {OnboardingStateDeleteManyArgs} args - Arguments to filter OnboardingStates to delete.
     * @example
     * // Delete a few OnboardingStates
     * const { count } = await prisma.onboardingState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OnboardingStateDeleteManyArgs>(args?: SelectSubset<T, OnboardingStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OnboardingStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OnboardingStates
     * const onboardingState = await prisma.onboardingState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OnboardingStateUpdateManyArgs>(args: SelectSubset<T, OnboardingStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OnboardingState.
     * @param {OnboardingStateUpsertArgs} args - Arguments to update or create a OnboardingState.
     * @example
     * // Update or create a OnboardingState
     * const onboardingState = await prisma.onboardingState.upsert({
     *   create: {
     *     // ... data to create a OnboardingState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OnboardingState we want to update
     *   }
     * })
     */
    upsert<T extends OnboardingStateUpsertArgs>(args: SelectSubset<T, OnboardingStateUpsertArgs<ExtArgs>>): Prisma__OnboardingStateClient<$Result.GetResult<Prisma.$OnboardingStatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OnboardingStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingStateCountArgs} args - Arguments to filter OnboardingStates to count.
     * @example
     * // Count the number of OnboardingStates
     * const count = await prisma.onboardingState.count({
     *   where: {
     *     // ... the filter for the OnboardingStates we want to count
     *   }
     * })
    **/
    count<T extends OnboardingStateCountArgs>(
      args?: Subset<T, OnboardingStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OnboardingStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OnboardingState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OnboardingStateAggregateArgs>(args: Subset<T, OnboardingStateAggregateArgs>): Prisma.PrismaPromise<GetOnboardingStateAggregateType<T>>

    /**
     * Group by OnboardingState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OnboardingStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OnboardingStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OnboardingStateGroupByArgs['orderBy'] }
        : { orderBy?: OnboardingStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OnboardingStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOnboardingStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OnboardingState model
   */
  readonly fields: OnboardingStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OnboardingState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OnboardingStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OnboardingState model
   */ 
  interface OnboardingStateFieldRefs {
    readonly userId: FieldRef<"OnboardingState", 'String'>
    readonly isCompleted: FieldRef<"OnboardingState", 'Boolean'>
    readonly completedAt: FieldRef<"OnboardingState", 'DateTime'>
    readonly lastNudgedAt: FieldRef<"OnboardingState", 'DateTime'>
    readonly updatedAt: FieldRef<"OnboardingState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OnboardingState findUnique
   */
  export type OnboardingStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingState to fetch.
     */
    where: OnboardingStateWhereUniqueInput
  }

  /**
   * OnboardingState findUniqueOrThrow
   */
  export type OnboardingStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingState to fetch.
     */
    where: OnboardingStateWhereUniqueInput
  }

  /**
   * OnboardingState findFirst
   */
  export type OnboardingStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingState to fetch.
     */
    where?: OnboardingStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingStates to fetch.
     */
    orderBy?: OnboardingStateOrderByWithRelationInput | OnboardingStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingStates.
     */
    cursor?: OnboardingStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingStates.
     */
    distinct?: OnboardingStateScalarFieldEnum | OnboardingStateScalarFieldEnum[]
  }

  /**
   * OnboardingState findFirstOrThrow
   */
  export type OnboardingStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingState to fetch.
     */
    where?: OnboardingStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingStates to fetch.
     */
    orderBy?: OnboardingStateOrderByWithRelationInput | OnboardingStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OnboardingStates.
     */
    cursor?: OnboardingStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OnboardingStates.
     */
    distinct?: OnboardingStateScalarFieldEnum | OnboardingStateScalarFieldEnum[]
  }

  /**
   * OnboardingState findMany
   */
  export type OnboardingStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * Filter, which OnboardingStates to fetch.
     */
    where?: OnboardingStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OnboardingStates to fetch.
     */
    orderBy?: OnboardingStateOrderByWithRelationInput | OnboardingStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OnboardingStates.
     */
    cursor?: OnboardingStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OnboardingStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OnboardingStates.
     */
    skip?: number
    distinct?: OnboardingStateScalarFieldEnum | OnboardingStateScalarFieldEnum[]
  }

  /**
   * OnboardingState create
   */
  export type OnboardingStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * The data needed to create a OnboardingState.
     */
    data: XOR<OnboardingStateCreateInput, OnboardingStateUncheckedCreateInput>
  }

  /**
   * OnboardingState createMany
   */
  export type OnboardingStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OnboardingStates.
     */
    data: OnboardingStateCreateManyInput | OnboardingStateCreateManyInput[]
  }

  /**
   * OnboardingState createManyAndReturn
   */
  export type OnboardingStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OnboardingStates.
     */
    data: OnboardingStateCreateManyInput | OnboardingStateCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OnboardingState update
   */
  export type OnboardingStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * The data needed to update a OnboardingState.
     */
    data: XOR<OnboardingStateUpdateInput, OnboardingStateUncheckedUpdateInput>
    /**
     * Choose, which OnboardingState to update.
     */
    where: OnboardingStateWhereUniqueInput
  }

  /**
   * OnboardingState updateMany
   */
  export type OnboardingStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OnboardingStates.
     */
    data: XOR<OnboardingStateUpdateManyMutationInput, OnboardingStateUncheckedUpdateManyInput>
    /**
     * Filter which OnboardingStates to update
     */
    where?: OnboardingStateWhereInput
  }

  /**
   * OnboardingState upsert
   */
  export type OnboardingStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * The filter to search for the OnboardingState to update in case it exists.
     */
    where: OnboardingStateWhereUniqueInput
    /**
     * In case the OnboardingState found by the `where` argument doesn't exist, create a new OnboardingState with this data.
     */
    create: XOR<OnboardingStateCreateInput, OnboardingStateUncheckedCreateInput>
    /**
     * In case the OnboardingState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OnboardingStateUpdateInput, OnboardingStateUncheckedUpdateInput>
  }

  /**
   * OnboardingState delete
   */
  export type OnboardingStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
    /**
     * Filter which OnboardingState to delete.
     */
    where: OnboardingStateWhereUniqueInput
  }

  /**
   * OnboardingState deleteMany
   */
  export type OnboardingStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OnboardingStates to delete
     */
    where?: OnboardingStateWhereInput
  }

  /**
   * OnboardingState without action
   */
  export type OnboardingStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OnboardingState
     */
    select?: OnboardingStateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OnboardingStateInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferredGenre
   */

  export type AggregateUserPreferredGenre = {
    _count: UserPreferredGenreCountAggregateOutputType | null
    _avg: UserPreferredGenreAvgAggregateOutputType | null
    _sum: UserPreferredGenreSumAggregateOutputType | null
    _min: UserPreferredGenreMinAggregateOutputType | null
    _max: UserPreferredGenreMaxAggregateOutputType | null
  }

  export type UserPreferredGenreAvgAggregateOutputType = {
    genreId: number | null
  }

  export type UserPreferredGenreSumAggregateOutputType = {
    genreId: number | null
  }

  export type UserPreferredGenreMinAggregateOutputType = {
    userId: string | null
    genreId: number | null
  }

  export type UserPreferredGenreMaxAggregateOutputType = {
    userId: string | null
    genreId: number | null
  }

  export type UserPreferredGenreCountAggregateOutputType = {
    userId: number
    genreId: number
    _all: number
  }


  export type UserPreferredGenreAvgAggregateInputType = {
    genreId?: true
  }

  export type UserPreferredGenreSumAggregateInputType = {
    genreId?: true
  }

  export type UserPreferredGenreMinAggregateInputType = {
    userId?: true
    genreId?: true
  }

  export type UserPreferredGenreMaxAggregateInputType = {
    userId?: true
    genreId?: true
  }

  export type UserPreferredGenreCountAggregateInputType = {
    userId?: true
    genreId?: true
    _all?: true
  }

  export type UserPreferredGenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferredGenre to aggregate.
     */
    where?: UserPreferredGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferredGenres to fetch.
     */
    orderBy?: UserPreferredGenreOrderByWithRelationInput | UserPreferredGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferredGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferredGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferredGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferredGenres
    **/
    _count?: true | UserPreferredGenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferredGenreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferredGenreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferredGenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferredGenreMaxAggregateInputType
  }

  export type GetUserPreferredGenreAggregateType<T extends UserPreferredGenreAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferredGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferredGenre[P]>
      : GetScalarType<T[P], AggregateUserPreferredGenre[P]>
  }




  export type UserPreferredGenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferredGenreWhereInput
    orderBy?: UserPreferredGenreOrderByWithAggregationInput | UserPreferredGenreOrderByWithAggregationInput[]
    by: UserPreferredGenreScalarFieldEnum[] | UserPreferredGenreScalarFieldEnum
    having?: UserPreferredGenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferredGenreCountAggregateInputType | true
    _avg?: UserPreferredGenreAvgAggregateInputType
    _sum?: UserPreferredGenreSumAggregateInputType
    _min?: UserPreferredGenreMinAggregateInputType
    _max?: UserPreferredGenreMaxAggregateInputType
  }

  export type UserPreferredGenreGroupByOutputType = {
    userId: string
    genreId: number
    _count: UserPreferredGenreCountAggregateOutputType | null
    _avg: UserPreferredGenreAvgAggregateOutputType | null
    _sum: UserPreferredGenreSumAggregateOutputType | null
    _min: UserPreferredGenreMinAggregateOutputType | null
    _max: UserPreferredGenreMaxAggregateOutputType | null
  }

  type GetUserPreferredGenreGroupByPayload<T extends UserPreferredGenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferredGenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferredGenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferredGenreGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferredGenreGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferredGenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    genreId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferredGenre"]>

  export type UserPreferredGenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    genreId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferredGenre"]>

  export type UserPreferredGenreSelectScalar = {
    userId?: boolean
    genreId?: boolean
  }

  export type UserPreferredGenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferredGenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferredGenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferredGenre"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      genreId: number
    }, ExtArgs["result"]["userPreferredGenre"]>
    composites: {}
  }

  type UserPreferredGenreGetPayload<S extends boolean | null | undefined | UserPreferredGenreDefaultArgs> = $Result.GetResult<Prisma.$UserPreferredGenrePayload, S>

  type UserPreferredGenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserPreferredGenreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserPreferredGenreCountAggregateInputType | true
    }

  export interface UserPreferredGenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferredGenre'], meta: { name: 'UserPreferredGenre' } }
    /**
     * Find zero or one UserPreferredGenre that matches the filter.
     * @param {UserPreferredGenreFindUniqueArgs} args - Arguments to find a UserPreferredGenre
     * @example
     * // Get one UserPreferredGenre
     * const userPreferredGenre = await prisma.userPreferredGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferredGenreFindUniqueArgs>(args: SelectSubset<T, UserPreferredGenreFindUniqueArgs<ExtArgs>>): Prisma__UserPreferredGenreClient<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserPreferredGenre that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserPreferredGenreFindUniqueOrThrowArgs} args - Arguments to find a UserPreferredGenre
     * @example
     * // Get one UserPreferredGenre
     * const userPreferredGenre = await prisma.userPreferredGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferredGenreFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferredGenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferredGenreClient<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserPreferredGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferredGenreFindFirstArgs} args - Arguments to find a UserPreferredGenre
     * @example
     * // Get one UserPreferredGenre
     * const userPreferredGenre = await prisma.userPreferredGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferredGenreFindFirstArgs>(args?: SelectSubset<T, UserPreferredGenreFindFirstArgs<ExtArgs>>): Prisma__UserPreferredGenreClient<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserPreferredGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferredGenreFindFirstOrThrowArgs} args - Arguments to find a UserPreferredGenre
     * @example
     * // Get one UserPreferredGenre
     * const userPreferredGenre = await prisma.userPreferredGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferredGenreFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferredGenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferredGenreClient<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserPreferredGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferredGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferredGenres
     * const userPreferredGenres = await prisma.userPreferredGenre.findMany()
     * 
     * // Get first 10 UserPreferredGenres
     * const userPreferredGenres = await prisma.userPreferredGenre.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userPreferredGenreWithUserIdOnly = await prisma.userPreferredGenre.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserPreferredGenreFindManyArgs>(args?: SelectSubset<T, UserPreferredGenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserPreferredGenre.
     * @param {UserPreferredGenreCreateArgs} args - Arguments to create a UserPreferredGenre.
     * @example
     * // Create one UserPreferredGenre
     * const UserPreferredGenre = await prisma.userPreferredGenre.create({
     *   data: {
     *     // ... data to create a UserPreferredGenre
     *   }
     * })
     * 
     */
    create<T extends UserPreferredGenreCreateArgs>(args: SelectSubset<T, UserPreferredGenreCreateArgs<ExtArgs>>): Prisma__UserPreferredGenreClient<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserPreferredGenres.
     * @param {UserPreferredGenreCreateManyArgs} args - Arguments to create many UserPreferredGenres.
     * @example
     * // Create many UserPreferredGenres
     * const userPreferredGenre = await prisma.userPreferredGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferredGenreCreateManyArgs>(args?: SelectSubset<T, UserPreferredGenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferredGenres and returns the data saved in the database.
     * @param {UserPreferredGenreCreateManyAndReturnArgs} args - Arguments to create many UserPreferredGenres.
     * @example
     * // Create many UserPreferredGenres
     * const userPreferredGenre = await prisma.userPreferredGenre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferredGenres and only return the `userId`
     * const userPreferredGenreWithUserIdOnly = await prisma.userPreferredGenre.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferredGenreCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferredGenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserPreferredGenre.
     * @param {UserPreferredGenreDeleteArgs} args - Arguments to delete one UserPreferredGenre.
     * @example
     * // Delete one UserPreferredGenre
     * const UserPreferredGenre = await prisma.userPreferredGenre.delete({
     *   where: {
     *     // ... filter to delete one UserPreferredGenre
     *   }
     * })
     * 
     */
    delete<T extends UserPreferredGenreDeleteArgs>(args: SelectSubset<T, UserPreferredGenreDeleteArgs<ExtArgs>>): Prisma__UserPreferredGenreClient<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserPreferredGenre.
     * @param {UserPreferredGenreUpdateArgs} args - Arguments to update one UserPreferredGenre.
     * @example
     * // Update one UserPreferredGenre
     * const userPreferredGenre = await prisma.userPreferredGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferredGenreUpdateArgs>(args: SelectSubset<T, UserPreferredGenreUpdateArgs<ExtArgs>>): Prisma__UserPreferredGenreClient<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserPreferredGenres.
     * @param {UserPreferredGenreDeleteManyArgs} args - Arguments to filter UserPreferredGenres to delete.
     * @example
     * // Delete a few UserPreferredGenres
     * const { count } = await prisma.userPreferredGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferredGenreDeleteManyArgs>(args?: SelectSubset<T, UserPreferredGenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferredGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferredGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferredGenres
     * const userPreferredGenre = await prisma.userPreferredGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferredGenreUpdateManyArgs>(args: SelectSubset<T, UserPreferredGenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPreferredGenre.
     * @param {UserPreferredGenreUpsertArgs} args - Arguments to update or create a UserPreferredGenre.
     * @example
     * // Update or create a UserPreferredGenre
     * const userPreferredGenre = await prisma.userPreferredGenre.upsert({
     *   create: {
     *     // ... data to create a UserPreferredGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferredGenre we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferredGenreUpsertArgs>(args: SelectSubset<T, UserPreferredGenreUpsertArgs<ExtArgs>>): Prisma__UserPreferredGenreClient<$Result.GetResult<Prisma.$UserPreferredGenrePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserPreferredGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferredGenreCountArgs} args - Arguments to filter UserPreferredGenres to count.
     * @example
     * // Count the number of UserPreferredGenres
     * const count = await prisma.userPreferredGenre.count({
     *   where: {
     *     // ... the filter for the UserPreferredGenres we want to count
     *   }
     * })
    **/
    count<T extends UserPreferredGenreCountArgs>(
      args?: Subset<T, UserPreferredGenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferredGenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferredGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferredGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferredGenreAggregateArgs>(args: Subset<T, UserPreferredGenreAggregateArgs>): Prisma.PrismaPromise<GetUserPreferredGenreAggregateType<T>>

    /**
     * Group by UserPreferredGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferredGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferredGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferredGenreGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferredGenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferredGenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferredGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferredGenre model
   */
  readonly fields: UserPreferredGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferredGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferredGenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferredGenre model
   */ 
  interface UserPreferredGenreFieldRefs {
    readonly userId: FieldRef<"UserPreferredGenre", 'String'>
    readonly genreId: FieldRef<"UserPreferredGenre", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferredGenre findUnique
   */
  export type UserPreferredGenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferredGenre to fetch.
     */
    where: UserPreferredGenreWhereUniqueInput
  }

  /**
   * UserPreferredGenre findUniqueOrThrow
   */
  export type UserPreferredGenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferredGenre to fetch.
     */
    where: UserPreferredGenreWhereUniqueInput
  }

  /**
   * UserPreferredGenre findFirst
   */
  export type UserPreferredGenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferredGenre to fetch.
     */
    where?: UserPreferredGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferredGenres to fetch.
     */
    orderBy?: UserPreferredGenreOrderByWithRelationInput | UserPreferredGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferredGenres.
     */
    cursor?: UserPreferredGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferredGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferredGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferredGenres.
     */
    distinct?: UserPreferredGenreScalarFieldEnum | UserPreferredGenreScalarFieldEnum[]
  }

  /**
   * UserPreferredGenre findFirstOrThrow
   */
  export type UserPreferredGenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferredGenre to fetch.
     */
    where?: UserPreferredGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferredGenres to fetch.
     */
    orderBy?: UserPreferredGenreOrderByWithRelationInput | UserPreferredGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferredGenres.
     */
    cursor?: UserPreferredGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferredGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferredGenres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferredGenres.
     */
    distinct?: UserPreferredGenreScalarFieldEnum | UserPreferredGenreScalarFieldEnum[]
  }

  /**
   * UserPreferredGenre findMany
   */
  export type UserPreferredGenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferredGenres to fetch.
     */
    where?: UserPreferredGenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferredGenres to fetch.
     */
    orderBy?: UserPreferredGenreOrderByWithRelationInput | UserPreferredGenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferredGenres.
     */
    cursor?: UserPreferredGenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferredGenres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferredGenres.
     */
    skip?: number
    distinct?: UserPreferredGenreScalarFieldEnum | UserPreferredGenreScalarFieldEnum[]
  }

  /**
   * UserPreferredGenre create
   */
  export type UserPreferredGenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferredGenre.
     */
    data: XOR<UserPreferredGenreCreateInput, UserPreferredGenreUncheckedCreateInput>
  }

  /**
   * UserPreferredGenre createMany
   */
  export type UserPreferredGenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferredGenres.
     */
    data: UserPreferredGenreCreateManyInput | UserPreferredGenreCreateManyInput[]
  }

  /**
   * UserPreferredGenre createManyAndReturn
   */
  export type UserPreferredGenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserPreferredGenres.
     */
    data: UserPreferredGenreCreateManyInput | UserPreferredGenreCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferredGenre update
   */
  export type UserPreferredGenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferredGenre.
     */
    data: XOR<UserPreferredGenreUpdateInput, UserPreferredGenreUncheckedUpdateInput>
    /**
     * Choose, which UserPreferredGenre to update.
     */
    where: UserPreferredGenreWhereUniqueInput
  }

  /**
   * UserPreferredGenre updateMany
   */
  export type UserPreferredGenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferredGenres.
     */
    data: XOR<UserPreferredGenreUpdateManyMutationInput, UserPreferredGenreUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferredGenres to update
     */
    where?: UserPreferredGenreWhereInput
  }

  /**
   * UserPreferredGenre upsert
   */
  export type UserPreferredGenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferredGenre to update in case it exists.
     */
    where: UserPreferredGenreWhereUniqueInput
    /**
     * In case the UserPreferredGenre found by the `where` argument doesn't exist, create a new UserPreferredGenre with this data.
     */
    create: XOR<UserPreferredGenreCreateInput, UserPreferredGenreUncheckedCreateInput>
    /**
     * In case the UserPreferredGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferredGenreUpdateInput, UserPreferredGenreUncheckedUpdateInput>
  }

  /**
   * UserPreferredGenre delete
   */
  export type UserPreferredGenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
    /**
     * Filter which UserPreferredGenre to delete.
     */
    where: UserPreferredGenreWhereUniqueInput
  }

  /**
   * UserPreferredGenre deleteMany
   */
  export type UserPreferredGenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferredGenres to delete
     */
    where?: UserPreferredGenreWhereInput
  }

  /**
   * UserPreferredGenre without action
   */
  export type UserPreferredGenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferredGenre
     */
    select?: UserPreferredGenreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferredGenreInclude<ExtArgs> | null
  }


  /**
   * Model UserTopTen
   */

  export type AggregateUserTopTen = {
    _count: UserTopTenCountAggregateOutputType | null
    _avg: UserTopTenAvgAggregateOutputType | null
    _sum: UserTopTenSumAggregateOutputType | null
    _min: UserTopTenMinAggregateOutputType | null
    _max: UserTopTenMaxAggregateOutputType | null
  }

  export type UserTopTenAvgAggregateOutputType = {
    tmdbId: number | null
    position: number | null
  }

  export type UserTopTenSumAggregateOutputType = {
    tmdbId: number | null
    position: number | null
  }

  export type UserTopTenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tmdbId: number | null
    position: number | null
    createdAt: Date | null
  }

  export type UserTopTenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tmdbId: number | null
    position: number | null
    createdAt: Date | null
  }

  export type UserTopTenCountAggregateOutputType = {
    id: number
    userId: number
    tmdbId: number
    position: number
    createdAt: number
    _all: number
  }


  export type UserTopTenAvgAggregateInputType = {
    tmdbId?: true
    position?: true
  }

  export type UserTopTenSumAggregateInputType = {
    tmdbId?: true
    position?: true
  }

  export type UserTopTenMinAggregateInputType = {
    id?: true
    userId?: true
    tmdbId?: true
    position?: true
    createdAt?: true
  }

  export type UserTopTenMaxAggregateInputType = {
    id?: true
    userId?: true
    tmdbId?: true
    position?: true
    createdAt?: true
  }

  export type UserTopTenCountAggregateInputType = {
    id?: true
    userId?: true
    tmdbId?: true
    position?: true
    createdAt?: true
    _all?: true
  }

  export type UserTopTenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTopTen to aggregate.
     */
    where?: UserTopTenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTopTens to fetch.
     */
    orderBy?: UserTopTenOrderByWithRelationInput | UserTopTenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTopTenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTopTens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTopTens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTopTens
    **/
    _count?: true | UserTopTenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTopTenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTopTenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTopTenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTopTenMaxAggregateInputType
  }

  export type GetUserTopTenAggregateType<T extends UserTopTenAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTopTen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTopTen[P]>
      : GetScalarType<T[P], AggregateUserTopTen[P]>
  }




  export type UserTopTenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTopTenWhereInput
    orderBy?: UserTopTenOrderByWithAggregationInput | UserTopTenOrderByWithAggregationInput[]
    by: UserTopTenScalarFieldEnum[] | UserTopTenScalarFieldEnum
    having?: UserTopTenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTopTenCountAggregateInputType | true
    _avg?: UserTopTenAvgAggregateInputType
    _sum?: UserTopTenSumAggregateInputType
    _min?: UserTopTenMinAggregateInputType
    _max?: UserTopTenMaxAggregateInputType
  }

  export type UserTopTenGroupByOutputType = {
    id: string
    userId: string
    tmdbId: number
    position: number
    createdAt: Date
    _count: UserTopTenCountAggregateOutputType | null
    _avg: UserTopTenAvgAggregateOutputType | null
    _sum: UserTopTenSumAggregateOutputType | null
    _min: UserTopTenMinAggregateOutputType | null
    _max: UserTopTenMaxAggregateOutputType | null
  }

  type GetUserTopTenGroupByPayload<T extends UserTopTenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTopTenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTopTenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTopTenGroupByOutputType[P]>
            : GetScalarType<T[P], UserTopTenGroupByOutputType[P]>
        }
      >
    >


  export type UserTopTenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tmdbId?: boolean
    position?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTopTen"]>

  export type UserTopTenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tmdbId?: boolean
    position?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTopTen"]>

  export type UserTopTenSelectScalar = {
    id?: boolean
    userId?: boolean
    tmdbId?: boolean
    position?: boolean
    createdAt?: boolean
  }

  export type UserTopTenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserTopTenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserTopTenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTopTen"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tmdbId: number
      position: number
      createdAt: Date
    }, ExtArgs["result"]["userTopTen"]>
    composites: {}
  }

  type UserTopTenGetPayload<S extends boolean | null | undefined | UserTopTenDefaultArgs> = $Result.GetResult<Prisma.$UserTopTenPayload, S>

  type UserTopTenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTopTenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTopTenCountAggregateInputType | true
    }

  export interface UserTopTenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTopTen'], meta: { name: 'UserTopTen' } }
    /**
     * Find zero or one UserTopTen that matches the filter.
     * @param {UserTopTenFindUniqueArgs} args - Arguments to find a UserTopTen
     * @example
     * // Get one UserTopTen
     * const userTopTen = await prisma.userTopTen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTopTenFindUniqueArgs>(args: SelectSubset<T, UserTopTenFindUniqueArgs<ExtArgs>>): Prisma__UserTopTenClient<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserTopTen that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTopTenFindUniqueOrThrowArgs} args - Arguments to find a UserTopTen
     * @example
     * // Get one UserTopTen
     * const userTopTen = await prisma.userTopTen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTopTenFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTopTenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTopTenClient<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserTopTen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopTenFindFirstArgs} args - Arguments to find a UserTopTen
     * @example
     * // Get one UserTopTen
     * const userTopTen = await prisma.userTopTen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTopTenFindFirstArgs>(args?: SelectSubset<T, UserTopTenFindFirstArgs<ExtArgs>>): Prisma__UserTopTenClient<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserTopTen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopTenFindFirstOrThrowArgs} args - Arguments to find a UserTopTen
     * @example
     * // Get one UserTopTen
     * const userTopTen = await prisma.userTopTen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTopTenFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTopTenFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTopTenClient<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserTopTens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopTenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTopTens
     * const userTopTens = await prisma.userTopTen.findMany()
     * 
     * // Get first 10 UserTopTens
     * const userTopTens = await prisma.userTopTen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTopTenWithIdOnly = await prisma.userTopTen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTopTenFindManyArgs>(args?: SelectSubset<T, UserTopTenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserTopTen.
     * @param {UserTopTenCreateArgs} args - Arguments to create a UserTopTen.
     * @example
     * // Create one UserTopTen
     * const UserTopTen = await prisma.userTopTen.create({
     *   data: {
     *     // ... data to create a UserTopTen
     *   }
     * })
     * 
     */
    create<T extends UserTopTenCreateArgs>(args: SelectSubset<T, UserTopTenCreateArgs<ExtArgs>>): Prisma__UserTopTenClient<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserTopTens.
     * @param {UserTopTenCreateManyArgs} args - Arguments to create many UserTopTens.
     * @example
     * // Create many UserTopTens
     * const userTopTen = await prisma.userTopTen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTopTenCreateManyArgs>(args?: SelectSubset<T, UserTopTenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTopTens and returns the data saved in the database.
     * @param {UserTopTenCreateManyAndReturnArgs} args - Arguments to create many UserTopTens.
     * @example
     * // Create many UserTopTens
     * const userTopTen = await prisma.userTopTen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTopTens and only return the `id`
     * const userTopTenWithIdOnly = await prisma.userTopTen.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTopTenCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTopTenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserTopTen.
     * @param {UserTopTenDeleteArgs} args - Arguments to delete one UserTopTen.
     * @example
     * // Delete one UserTopTen
     * const UserTopTen = await prisma.userTopTen.delete({
     *   where: {
     *     // ... filter to delete one UserTopTen
     *   }
     * })
     * 
     */
    delete<T extends UserTopTenDeleteArgs>(args: SelectSubset<T, UserTopTenDeleteArgs<ExtArgs>>): Prisma__UserTopTenClient<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserTopTen.
     * @param {UserTopTenUpdateArgs} args - Arguments to update one UserTopTen.
     * @example
     * // Update one UserTopTen
     * const userTopTen = await prisma.userTopTen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTopTenUpdateArgs>(args: SelectSubset<T, UserTopTenUpdateArgs<ExtArgs>>): Prisma__UserTopTenClient<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserTopTens.
     * @param {UserTopTenDeleteManyArgs} args - Arguments to filter UserTopTens to delete.
     * @example
     * // Delete a few UserTopTens
     * const { count } = await prisma.userTopTen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTopTenDeleteManyArgs>(args?: SelectSubset<T, UserTopTenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTopTens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopTenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTopTens
     * const userTopTen = await prisma.userTopTen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTopTenUpdateManyArgs>(args: SelectSubset<T, UserTopTenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTopTen.
     * @param {UserTopTenUpsertArgs} args - Arguments to update or create a UserTopTen.
     * @example
     * // Update or create a UserTopTen
     * const userTopTen = await prisma.userTopTen.upsert({
     *   create: {
     *     // ... data to create a UserTopTen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTopTen we want to update
     *   }
     * })
     */
    upsert<T extends UserTopTenUpsertArgs>(args: SelectSubset<T, UserTopTenUpsertArgs<ExtArgs>>): Prisma__UserTopTenClient<$Result.GetResult<Prisma.$UserTopTenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserTopTens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopTenCountArgs} args - Arguments to filter UserTopTens to count.
     * @example
     * // Count the number of UserTopTens
     * const count = await prisma.userTopTen.count({
     *   where: {
     *     // ... the filter for the UserTopTens we want to count
     *   }
     * })
    **/
    count<T extends UserTopTenCountArgs>(
      args?: Subset<T, UserTopTenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTopTenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTopTen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopTenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTopTenAggregateArgs>(args: Subset<T, UserTopTenAggregateArgs>): Prisma.PrismaPromise<GetUserTopTenAggregateType<T>>

    /**
     * Group by UserTopTen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTopTenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTopTenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTopTenGroupByArgs['orderBy'] }
        : { orderBy?: UserTopTenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTopTenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTopTenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTopTen model
   */
  readonly fields: UserTopTenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTopTen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTopTenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTopTen model
   */ 
  interface UserTopTenFieldRefs {
    readonly id: FieldRef<"UserTopTen", 'String'>
    readonly userId: FieldRef<"UserTopTen", 'String'>
    readonly tmdbId: FieldRef<"UserTopTen", 'Int'>
    readonly position: FieldRef<"UserTopTen", 'Int'>
    readonly createdAt: FieldRef<"UserTopTen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTopTen findUnique
   */
  export type UserTopTenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * Filter, which UserTopTen to fetch.
     */
    where: UserTopTenWhereUniqueInput
  }

  /**
   * UserTopTen findUniqueOrThrow
   */
  export type UserTopTenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * Filter, which UserTopTen to fetch.
     */
    where: UserTopTenWhereUniqueInput
  }

  /**
   * UserTopTen findFirst
   */
  export type UserTopTenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * Filter, which UserTopTen to fetch.
     */
    where?: UserTopTenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTopTens to fetch.
     */
    orderBy?: UserTopTenOrderByWithRelationInput | UserTopTenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTopTens.
     */
    cursor?: UserTopTenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTopTens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTopTens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTopTens.
     */
    distinct?: UserTopTenScalarFieldEnum | UserTopTenScalarFieldEnum[]
  }

  /**
   * UserTopTen findFirstOrThrow
   */
  export type UserTopTenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * Filter, which UserTopTen to fetch.
     */
    where?: UserTopTenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTopTens to fetch.
     */
    orderBy?: UserTopTenOrderByWithRelationInput | UserTopTenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTopTens.
     */
    cursor?: UserTopTenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTopTens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTopTens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTopTens.
     */
    distinct?: UserTopTenScalarFieldEnum | UserTopTenScalarFieldEnum[]
  }

  /**
   * UserTopTen findMany
   */
  export type UserTopTenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * Filter, which UserTopTens to fetch.
     */
    where?: UserTopTenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTopTens to fetch.
     */
    orderBy?: UserTopTenOrderByWithRelationInput | UserTopTenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTopTens.
     */
    cursor?: UserTopTenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTopTens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTopTens.
     */
    skip?: number
    distinct?: UserTopTenScalarFieldEnum | UserTopTenScalarFieldEnum[]
  }

  /**
   * UserTopTen create
   */
  export type UserTopTenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTopTen.
     */
    data: XOR<UserTopTenCreateInput, UserTopTenUncheckedCreateInput>
  }

  /**
   * UserTopTen createMany
   */
  export type UserTopTenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTopTens.
     */
    data: UserTopTenCreateManyInput | UserTopTenCreateManyInput[]
  }

  /**
   * UserTopTen createManyAndReturn
   */
  export type UserTopTenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserTopTens.
     */
    data: UserTopTenCreateManyInput | UserTopTenCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTopTen update
   */
  export type UserTopTenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTopTen.
     */
    data: XOR<UserTopTenUpdateInput, UserTopTenUncheckedUpdateInput>
    /**
     * Choose, which UserTopTen to update.
     */
    where: UserTopTenWhereUniqueInput
  }

  /**
   * UserTopTen updateMany
   */
  export type UserTopTenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTopTens.
     */
    data: XOR<UserTopTenUpdateManyMutationInput, UserTopTenUncheckedUpdateManyInput>
    /**
     * Filter which UserTopTens to update
     */
    where?: UserTopTenWhereInput
  }

  /**
   * UserTopTen upsert
   */
  export type UserTopTenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTopTen to update in case it exists.
     */
    where: UserTopTenWhereUniqueInput
    /**
     * In case the UserTopTen found by the `where` argument doesn't exist, create a new UserTopTen with this data.
     */
    create: XOR<UserTopTenCreateInput, UserTopTenUncheckedCreateInput>
    /**
     * In case the UserTopTen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTopTenUpdateInput, UserTopTenUncheckedUpdateInput>
  }

  /**
   * UserTopTen delete
   */
  export type UserTopTenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
    /**
     * Filter which UserTopTen to delete.
     */
    where: UserTopTenWhereUniqueInput
  }

  /**
   * UserTopTen deleteMany
   */
  export type UserTopTenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTopTens to delete
     */
    where?: UserTopTenWhereInput
  }

  /**
   * UserTopTen without action
   */
  export type UserTopTenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTopTen
     */
    select?: UserTopTenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTopTenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    clerkId: 'clerkId',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const MovieInteractionScalarFieldEnum: {
    userId: 'userId',
    movieId: 'movieId',
    watched: 'watched',
    watchlisted: 'watchlisted',
    favorited: 'favorited',
    ratingHalf: 'ratingHalf',
    ratedAt: 'ratedAt',
    favoritedAt: 'favoritedAt',
    watchedAt: 'watchedAt',
    updatedAt: 'updatedAt'
  };

  export type MovieInteractionScalarFieldEnum = (typeof MovieInteractionScalarFieldEnum)[keyof typeof MovieInteractionScalarFieldEnum]


  export const WatchLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    movieId: 'movieId',
    watchedAt: 'watchedAt',
    rewatch: 'rewatch',
    tags: 'tags',
    note: 'note',
    importId: 'importId',
    importRowId: 'importRowId',
    createdAt: 'createdAt'
  };

  export type WatchLogScalarFieldEnum = (typeof WatchLogScalarFieldEnum)[keyof typeof WatchLogScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    movieId: 'movieId',
    watchLogId: 'watchLogId',
    bodyRaw: 'bodyRaw',
    bodyFormat: 'bodyFormat',
    ratingHalf: 'ratingHalf',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewCommentScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    body: 'body',
    createdAt: 'createdAt'
  };

  export type ReviewCommentScalarFieldEnum = (typeof ReviewCommentScalarFieldEnum)[keyof typeof ReviewCommentScalarFieldEnum]


  export const ReviewFavoriteScalarFieldEnum: {
    reviewId: 'reviewId',
    userId: 'userId'
  };

  export type ReviewFavoriteScalarFieldEnum = (typeof ReviewFavoriteScalarFieldEnum)[keyof typeof ReviewFavoriteScalarFieldEnum]


  export const MovieListScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    tags: 'tags',
    isRanked: 'isRanked',
    isSystem: 'isSystem',
    systemKey: 'systemKey',
    isPublic: 'isPublic',
    sourceListId: 'sourceListId',
    sourceType: 'sourceType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MovieListScalarFieldEnum = (typeof MovieListScalarFieldEnum)[keyof typeof MovieListScalarFieldEnum]


  export const MovieListItemScalarFieldEnum: {
    listId: 'listId',
    movieId: 'movieId',
    position: 'position',
    note: 'note',
    addedAt: 'addedAt'
  };

  export type MovieListItemScalarFieldEnum = (typeof MovieListItemScalarFieldEnum)[keyof typeof MovieListItemScalarFieldEnum]


  export const ImportRunScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    source: 'source',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImportRunScalarFieldEnum = (typeof ImportRunScalarFieldEnum)[keyof typeof ImportRunScalarFieldEnum]


  export const ImportAuditRowScalarFieldEnum: {
    id: 'id',
    importId: 'importId',
    fileName: 'fileName',
    rowNumber: 'rowNumber',
    title: 'title',
    year: 'year',
    letterboxdUrl: 'letterboxdUrl',
    tmdbMovieId: 'tmdbMovieId',
    status: 'status',
    message: 'message',
    rawJson: 'rawJson'
  };

  export type ImportAuditRowScalarFieldEnum = (typeof ImportAuditRowScalarFieldEnum)[keyof typeof ImportAuditRowScalarFieldEnum]


  export const BallotScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventYear: 'eventYear',
    category: 'category',
    nomineeId: 'nomineeId',
    nomineeName: 'nomineeName',
    isWinner: 'isWinner',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BallotScalarFieldEnum = (typeof BallotScalarFieldEnum)[keyof typeof BallotScalarFieldEnum]


  export const AwardEventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    type: 'type'
  };

  export type AwardEventScalarFieldEnum = (typeof AwardEventScalarFieldEnum)[keyof typeof AwardEventScalarFieldEnum]


  export const AwardSeasonScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    year: 'year',
    season: 'season',
    phase: 'phase',
    date: 'date'
  };

  export type AwardSeasonScalarFieldEnum = (typeof AwardSeasonScalarFieldEnum)[keyof typeof AwardSeasonScalarFieldEnum]


  export const MovieScalarFieldEnum: {
    tmdbId: 'tmdbId',
    title: 'title',
    posterPath: 'posterPath',
    backdropPath: 'backdropPath',
    eligibleDate: 'eligibleDate',
    eligibilityYear: 'eligibilityYear',
    seasonKey: 'seasonKey'
  };

  export type MovieScalarFieldEnum = (typeof MovieScalarFieldEnum)[keyof typeof MovieScalarFieldEnum]


  export const AwardWinnerScalarFieldEnum: {
    id: 'id',
    seasonId: 'seasonId',
    prizeName: 'prizeName',
    movieId: 'movieId',
    movieTitle: 'movieTitle',
    posterPath: 'posterPath',
    personName: 'personName',
    personPath: 'personPath',
    isWinner: 'isWinner',
    sourceUrl: 'sourceUrl',
    createdAt: 'createdAt'
  };

  export type AwardWinnerScalarFieldEnum = (typeof AwardWinnerScalarFieldEnum)[keyof typeof AwardWinnerScalarFieldEnum]


  export const StreamingSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    providerId: 'providerId',
    name: 'name',
    logoPath: 'logoPath',
    createdAt: 'createdAt'
  };

  export type StreamingSubscriptionScalarFieldEnum = (typeof StreamingSubscriptionScalarFieldEnum)[keyof typeof StreamingSubscriptionScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    userId: 'userId',
    providerMode: 'providerMode',
    region: 'region',
    runtimeMin: 'runtimeMin',
    runtimeMax: 'runtimeMax',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const OnboardingStateScalarFieldEnum: {
    userId: 'userId',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt',
    lastNudgedAt: 'lastNudgedAt',
    updatedAt: 'updatedAt'
  };

  export type OnboardingStateScalarFieldEnum = (typeof OnboardingStateScalarFieldEnum)[keyof typeof OnboardingStateScalarFieldEnum]


  export const UserPreferredGenreScalarFieldEnum: {
    userId: 'userId',
    genreId: 'genreId'
  };

  export type UserPreferredGenreScalarFieldEnum = (typeof UserPreferredGenreScalarFieldEnum)[keyof typeof UserPreferredGenreScalarFieldEnum]


  export const UserTopTenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tmdbId: 'tmdbId',
    position: 'position',
    createdAt: 'createdAt'
  };

  export type UserTopTenScalarFieldEnum = (typeof UserTopTenScalarFieldEnum)[keyof typeof UserTopTenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    clerkId?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    interactions?: MovieInteractionListRelationFilter
    watchLogs?: WatchLogListRelationFilter
    reviews?: ReviewListRelationFilter
    reviewComments?: ReviewCommentListRelationFilter
    reviewFavorites?: ReviewFavoriteListRelationFilter
    movieLists?: MovieListListRelationFilter
    ballots?: BallotListRelationFilter
    subscriptions?: StreamingSubscriptionListRelationFilter
    importRuns?: ImportRunListRelationFilter
    topTen?: UserTopTenListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    onboarding?: XOR<OnboardingStateNullableScalarRelationFilter, OnboardingStateWhereInput> | null
    preferredGenres?: UserPreferredGenreListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    clerkId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    interactions?: MovieInteractionOrderByRelationAggregateInput
    watchLogs?: WatchLogOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    reviewComments?: ReviewCommentOrderByRelationAggregateInput
    reviewFavorites?: ReviewFavoriteOrderByRelationAggregateInput
    movieLists?: MovieListOrderByRelationAggregateInput
    ballots?: BallotOrderByRelationAggregateInput
    subscriptions?: StreamingSubscriptionOrderByRelationAggregateInput
    importRuns?: ImportRunOrderByRelationAggregateInput
    topTen?: UserTopTenOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    onboarding?: OnboardingStateOrderByWithRelationInput
    preferredGenres?: UserPreferredGenreOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clerkId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    interactions?: MovieInteractionListRelationFilter
    watchLogs?: WatchLogListRelationFilter
    reviews?: ReviewListRelationFilter
    reviewComments?: ReviewCommentListRelationFilter
    reviewFavorites?: ReviewFavoriteListRelationFilter
    movieLists?: MovieListListRelationFilter
    ballots?: BallotListRelationFilter
    subscriptions?: StreamingSubscriptionListRelationFilter
    importRuns?: ImportRunListRelationFilter
    topTen?: UserTopTenListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    onboarding?: XOR<OnboardingStateNullableScalarRelationFilter, OnboardingStateWhereInput> | null
    preferredGenres?: UserPreferredGenreListRelationFilter
  }, "id" | "clerkId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    clerkId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    clerkId?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type MovieInteractionWhereInput = {
    AND?: MovieInteractionWhereInput | MovieInteractionWhereInput[]
    OR?: MovieInteractionWhereInput[]
    NOT?: MovieInteractionWhereInput | MovieInteractionWhereInput[]
    userId?: StringFilter<"MovieInteraction"> | string
    movieId?: IntFilter<"MovieInteraction"> | number
    watched?: BoolFilter<"MovieInteraction"> | boolean
    watchlisted?: BoolFilter<"MovieInteraction"> | boolean
    favorited?: BoolFilter<"MovieInteraction"> | boolean
    ratingHalf?: IntNullableFilter<"MovieInteraction"> | number | null
    ratedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    favoritedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    watchedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    updatedAt?: DateTimeFilter<"MovieInteraction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
  }

  export type MovieInteractionOrderByWithRelationInput = {
    userId?: SortOrder
    movieId?: SortOrder
    watched?: SortOrder
    watchlisted?: SortOrder
    favorited?: SortOrder
    ratingHalf?: SortOrderInput | SortOrder
    ratedAt?: SortOrderInput | SortOrder
    favoritedAt?: SortOrderInput | SortOrder
    watchedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieInteractionWhereUniqueInput = Prisma.AtLeast<{
    userId_movieId?: MovieInteractionUserIdMovieIdCompoundUniqueInput
    AND?: MovieInteractionWhereInput | MovieInteractionWhereInput[]
    OR?: MovieInteractionWhereInput[]
    NOT?: MovieInteractionWhereInput | MovieInteractionWhereInput[]
    userId?: StringFilter<"MovieInteraction"> | string
    movieId?: IntFilter<"MovieInteraction"> | number
    watched?: BoolFilter<"MovieInteraction"> | boolean
    watchlisted?: BoolFilter<"MovieInteraction"> | boolean
    favorited?: BoolFilter<"MovieInteraction"> | boolean
    ratingHalf?: IntNullableFilter<"MovieInteraction"> | number | null
    ratedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    favoritedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    watchedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    updatedAt?: DateTimeFilter<"MovieInteraction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
  }, "userId_movieId">

  export type MovieInteractionOrderByWithAggregationInput = {
    userId?: SortOrder
    movieId?: SortOrder
    watched?: SortOrder
    watchlisted?: SortOrder
    favorited?: SortOrder
    ratingHalf?: SortOrderInput | SortOrder
    ratedAt?: SortOrderInput | SortOrder
    favoritedAt?: SortOrderInput | SortOrder
    watchedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: MovieInteractionCountOrderByAggregateInput
    _avg?: MovieInteractionAvgOrderByAggregateInput
    _max?: MovieInteractionMaxOrderByAggregateInput
    _min?: MovieInteractionMinOrderByAggregateInput
    _sum?: MovieInteractionSumOrderByAggregateInput
  }

  export type MovieInteractionScalarWhereWithAggregatesInput = {
    AND?: MovieInteractionScalarWhereWithAggregatesInput | MovieInteractionScalarWhereWithAggregatesInput[]
    OR?: MovieInteractionScalarWhereWithAggregatesInput[]
    NOT?: MovieInteractionScalarWhereWithAggregatesInput | MovieInteractionScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"MovieInteraction"> | string
    movieId?: IntWithAggregatesFilter<"MovieInteraction"> | number
    watched?: BoolWithAggregatesFilter<"MovieInteraction"> | boolean
    watchlisted?: BoolWithAggregatesFilter<"MovieInteraction"> | boolean
    favorited?: BoolWithAggregatesFilter<"MovieInteraction"> | boolean
    ratingHalf?: IntNullableWithAggregatesFilter<"MovieInteraction"> | number | null
    ratedAt?: DateTimeNullableWithAggregatesFilter<"MovieInteraction"> | Date | string | null
    favoritedAt?: DateTimeNullableWithAggregatesFilter<"MovieInteraction"> | Date | string | null
    watchedAt?: DateTimeNullableWithAggregatesFilter<"MovieInteraction"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"MovieInteraction"> | Date | string
  }

  export type WatchLogWhereInput = {
    AND?: WatchLogWhereInput | WatchLogWhereInput[]
    OR?: WatchLogWhereInput[]
    NOT?: WatchLogWhereInput | WatchLogWhereInput[]
    id?: StringFilter<"WatchLog"> | string
    userId?: StringFilter<"WatchLog"> | string
    movieId?: IntFilter<"WatchLog"> | number
    watchedAt?: DateTimeFilter<"WatchLog"> | Date | string
    rewatch?: BoolFilter<"WatchLog"> | boolean
    tags?: StringNullableFilter<"WatchLog"> | string | null
    note?: StringNullableFilter<"WatchLog"> | string | null
    importId?: StringNullableFilter<"WatchLog"> | string | null
    importRowId?: StringNullableFilter<"WatchLog"> | string | null
    createdAt?: DateTimeFilter<"WatchLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    importRun?: XOR<ImportRunNullableScalarRelationFilter, ImportRunWhereInput> | null
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
  }

  export type WatchLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchedAt?: SortOrder
    rewatch?: SortOrder
    tags?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    importId?: SortOrderInput | SortOrder
    importRowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    importRun?: ImportRunOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
  }

  export type WatchLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_movieId_watchedAt_importId?: WatchLogUserIdMovieIdWatchedAtImportIdCompoundUniqueInput
    AND?: WatchLogWhereInput | WatchLogWhereInput[]
    OR?: WatchLogWhereInput[]
    NOT?: WatchLogWhereInput | WatchLogWhereInput[]
    userId?: StringFilter<"WatchLog"> | string
    movieId?: IntFilter<"WatchLog"> | number
    watchedAt?: DateTimeFilter<"WatchLog"> | Date | string
    rewatch?: BoolFilter<"WatchLog"> | boolean
    tags?: StringNullableFilter<"WatchLog"> | string | null
    note?: StringNullableFilter<"WatchLog"> | string | null
    importId?: StringNullableFilter<"WatchLog"> | string | null
    importRowId?: StringNullableFilter<"WatchLog"> | string | null
    createdAt?: DateTimeFilter<"WatchLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    importRun?: XOR<ImportRunNullableScalarRelationFilter, ImportRunWhereInput> | null
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
  }, "id" | "userId_movieId_watchedAt_importId">

  export type WatchLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchedAt?: SortOrder
    rewatch?: SortOrder
    tags?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    importId?: SortOrderInput | SortOrder
    importRowId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WatchLogCountOrderByAggregateInput
    _avg?: WatchLogAvgOrderByAggregateInput
    _max?: WatchLogMaxOrderByAggregateInput
    _min?: WatchLogMinOrderByAggregateInput
    _sum?: WatchLogSumOrderByAggregateInput
  }

  export type WatchLogScalarWhereWithAggregatesInput = {
    AND?: WatchLogScalarWhereWithAggregatesInput | WatchLogScalarWhereWithAggregatesInput[]
    OR?: WatchLogScalarWhereWithAggregatesInput[]
    NOT?: WatchLogScalarWhereWithAggregatesInput | WatchLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchLog"> | string
    userId?: StringWithAggregatesFilter<"WatchLog"> | string
    movieId?: IntWithAggregatesFilter<"WatchLog"> | number
    watchedAt?: DateTimeWithAggregatesFilter<"WatchLog"> | Date | string
    rewatch?: BoolWithAggregatesFilter<"WatchLog"> | boolean
    tags?: StringNullableWithAggregatesFilter<"WatchLog"> | string | null
    note?: StringNullableWithAggregatesFilter<"WatchLog"> | string | null
    importId?: StringNullableWithAggregatesFilter<"WatchLog"> | string | null
    importRowId?: StringNullableWithAggregatesFilter<"WatchLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WatchLog"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    movieId?: IntFilter<"Review"> | number
    watchLogId?: StringNullableFilter<"Review"> | string | null
    bodyRaw?: StringFilter<"Review"> | string
    bodyFormat?: StringFilter<"Review"> | string
    ratingHalf?: IntNullableFilter<"Review"> | number | null
    tags?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    watchLog?: XOR<WatchLogNullableScalarRelationFilter, WatchLogWhereInput> | null
    comments?: ReviewCommentListRelationFilter
    favorites?: ReviewFavoriteListRelationFilter
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchLogId?: SortOrderInput | SortOrder
    bodyRaw?: SortOrder
    bodyFormat?: SortOrder
    ratingHalf?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    watchLog?: WatchLogOrderByWithRelationInput
    comments?: ReviewCommentOrderByRelationAggregateInput
    favorites?: ReviewFavoriteOrderByRelationAggregateInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    watchLogId?: string
    userId_movieId_watchLogId?: ReviewUserIdMovieIdWatchLogIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    movieId?: IntFilter<"Review"> | number
    bodyRaw?: StringFilter<"Review"> | string
    bodyFormat?: StringFilter<"Review"> | string
    ratingHalf?: IntNullableFilter<"Review"> | number | null
    tags?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    watchLog?: XOR<WatchLogNullableScalarRelationFilter, WatchLogWhereInput> | null
    comments?: ReviewCommentListRelationFilter
    favorites?: ReviewFavoriteListRelationFilter
  }, "id" | "watchLogId" | "userId_movieId_watchLogId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchLogId?: SortOrderInput | SortOrder
    bodyRaw?: SortOrder
    bodyFormat?: SortOrder
    ratingHalf?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    movieId?: IntWithAggregatesFilter<"Review"> | number
    watchLogId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    bodyRaw?: StringWithAggregatesFilter<"Review"> | string
    bodyFormat?: StringWithAggregatesFilter<"Review"> | string
    ratingHalf?: IntNullableWithAggregatesFilter<"Review"> | number | null
    tags?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ReviewCommentWhereInput = {
    AND?: ReviewCommentWhereInput | ReviewCommentWhereInput[]
    OR?: ReviewCommentWhereInput[]
    NOT?: ReviewCommentWhereInput | ReviewCommentWhereInput[]
    id?: StringFilter<"ReviewComment"> | string
    reviewId?: StringFilter<"ReviewComment"> | string
    userId?: StringFilter<"ReviewComment"> | string
    body?: StringFilter<"ReviewComment"> | string
    createdAt?: DateTimeFilter<"ReviewComment"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewCommentOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    review?: ReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewCommentWhereInput | ReviewCommentWhereInput[]
    OR?: ReviewCommentWhereInput[]
    NOT?: ReviewCommentWhereInput | ReviewCommentWhereInput[]
    reviewId?: StringFilter<"ReviewComment"> | string
    userId?: StringFilter<"ReviewComment"> | string
    body?: StringFilter<"ReviewComment"> | string
    createdAt?: DateTimeFilter<"ReviewComment"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewCommentOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewCommentCountOrderByAggregateInput
    _max?: ReviewCommentMaxOrderByAggregateInput
    _min?: ReviewCommentMinOrderByAggregateInput
  }

  export type ReviewCommentScalarWhereWithAggregatesInput = {
    AND?: ReviewCommentScalarWhereWithAggregatesInput | ReviewCommentScalarWhereWithAggregatesInput[]
    OR?: ReviewCommentScalarWhereWithAggregatesInput[]
    NOT?: ReviewCommentScalarWhereWithAggregatesInput | ReviewCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewComment"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewComment"> | string
    userId?: StringWithAggregatesFilter<"ReviewComment"> | string
    body?: StringWithAggregatesFilter<"ReviewComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewComment"> | Date | string
  }

  export type ReviewFavoriteWhereInput = {
    AND?: ReviewFavoriteWhereInput | ReviewFavoriteWhereInput[]
    OR?: ReviewFavoriteWhereInput[]
    NOT?: ReviewFavoriteWhereInput | ReviewFavoriteWhereInput[]
    reviewId?: StringFilter<"ReviewFavorite"> | string
    userId?: StringFilter<"ReviewFavorite"> | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewFavoriteOrderByWithRelationInput = {
    reviewId?: SortOrder
    userId?: SortOrder
    review?: ReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewFavoriteWhereUniqueInput = Prisma.AtLeast<{
    reviewId_userId?: ReviewFavoriteReviewIdUserIdCompoundUniqueInput
    AND?: ReviewFavoriteWhereInput | ReviewFavoriteWhereInput[]
    OR?: ReviewFavoriteWhereInput[]
    NOT?: ReviewFavoriteWhereInput | ReviewFavoriteWhereInput[]
    reviewId?: StringFilter<"ReviewFavorite"> | string
    userId?: StringFilter<"ReviewFavorite"> | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "reviewId_userId">

  export type ReviewFavoriteOrderByWithAggregationInput = {
    reviewId?: SortOrder
    userId?: SortOrder
    _count?: ReviewFavoriteCountOrderByAggregateInput
    _max?: ReviewFavoriteMaxOrderByAggregateInput
    _min?: ReviewFavoriteMinOrderByAggregateInput
  }

  export type ReviewFavoriteScalarWhereWithAggregatesInput = {
    AND?: ReviewFavoriteScalarWhereWithAggregatesInput | ReviewFavoriteScalarWhereWithAggregatesInput[]
    OR?: ReviewFavoriteScalarWhereWithAggregatesInput[]
    NOT?: ReviewFavoriteScalarWhereWithAggregatesInput | ReviewFavoriteScalarWhereWithAggregatesInput[]
    reviewId?: StringWithAggregatesFilter<"ReviewFavorite"> | string
    userId?: StringWithAggregatesFilter<"ReviewFavorite"> | string
  }

  export type MovieListWhereInput = {
    AND?: MovieListWhereInput | MovieListWhereInput[]
    OR?: MovieListWhereInput[]
    NOT?: MovieListWhereInput | MovieListWhereInput[]
    id?: StringFilter<"MovieList"> | string
    userId?: StringFilter<"MovieList"> | string
    title?: StringFilter<"MovieList"> | string
    description?: StringNullableFilter<"MovieList"> | string | null
    tags?: StringNullableFilter<"MovieList"> | string | null
    isRanked?: BoolFilter<"MovieList"> | boolean
    isSystem?: BoolFilter<"MovieList"> | boolean
    systemKey?: StringNullableFilter<"MovieList"> | string | null
    isPublic?: BoolFilter<"MovieList"> | boolean
    sourceListId?: StringNullableFilter<"MovieList"> | string | null
    sourceType?: StringNullableFilter<"MovieList"> | string | null
    createdAt?: DateTimeFilter<"MovieList"> | Date | string
    updatedAt?: DateTimeFilter<"MovieList"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: MovieListItemListRelationFilter
  }

  export type MovieListOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isRanked?: SortOrder
    isSystem?: SortOrder
    systemKey?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    sourceListId?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: MovieListItemOrderByRelationAggregateInput
  }

  export type MovieListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    systemKey?: string
    userId_title?: MovieListUserIdTitleCompoundUniqueInput
    AND?: MovieListWhereInput | MovieListWhereInput[]
    OR?: MovieListWhereInput[]
    NOT?: MovieListWhereInput | MovieListWhereInput[]
    userId?: StringFilter<"MovieList"> | string
    title?: StringFilter<"MovieList"> | string
    description?: StringNullableFilter<"MovieList"> | string | null
    tags?: StringNullableFilter<"MovieList"> | string | null
    isRanked?: BoolFilter<"MovieList"> | boolean
    isSystem?: BoolFilter<"MovieList"> | boolean
    isPublic?: BoolFilter<"MovieList"> | boolean
    sourceListId?: StringNullableFilter<"MovieList"> | string | null
    sourceType?: StringNullableFilter<"MovieList"> | string | null
    createdAt?: DateTimeFilter<"MovieList"> | Date | string
    updatedAt?: DateTimeFilter<"MovieList"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: MovieListItemListRelationFilter
  }, "id" | "systemKey" | "userId_title">

  export type MovieListOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isRanked?: SortOrder
    isSystem?: SortOrder
    systemKey?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    sourceListId?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MovieListCountOrderByAggregateInput
    _max?: MovieListMaxOrderByAggregateInput
    _min?: MovieListMinOrderByAggregateInput
  }

  export type MovieListScalarWhereWithAggregatesInput = {
    AND?: MovieListScalarWhereWithAggregatesInput | MovieListScalarWhereWithAggregatesInput[]
    OR?: MovieListScalarWhereWithAggregatesInput[]
    NOT?: MovieListScalarWhereWithAggregatesInput | MovieListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MovieList"> | string
    userId?: StringWithAggregatesFilter<"MovieList"> | string
    title?: StringWithAggregatesFilter<"MovieList"> | string
    description?: StringNullableWithAggregatesFilter<"MovieList"> | string | null
    tags?: StringNullableWithAggregatesFilter<"MovieList"> | string | null
    isRanked?: BoolWithAggregatesFilter<"MovieList"> | boolean
    isSystem?: BoolWithAggregatesFilter<"MovieList"> | boolean
    systemKey?: StringNullableWithAggregatesFilter<"MovieList"> | string | null
    isPublic?: BoolWithAggregatesFilter<"MovieList"> | boolean
    sourceListId?: StringNullableWithAggregatesFilter<"MovieList"> | string | null
    sourceType?: StringNullableWithAggregatesFilter<"MovieList"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MovieList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MovieList"> | Date | string
  }

  export type MovieListItemWhereInput = {
    AND?: MovieListItemWhereInput | MovieListItemWhereInput[]
    OR?: MovieListItemWhereInput[]
    NOT?: MovieListItemWhereInput | MovieListItemWhereInput[]
    listId?: StringFilter<"MovieListItem"> | string
    movieId?: IntFilter<"MovieListItem"> | number
    position?: IntNullableFilter<"MovieListItem"> | number | null
    note?: StringNullableFilter<"MovieListItem"> | string | null
    addedAt?: DateTimeFilter<"MovieListItem"> | Date | string
    list?: XOR<MovieListScalarRelationFilter, MovieListWhereInput>
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
  }

  export type MovieListItemOrderByWithRelationInput = {
    listId?: SortOrder
    movieId?: SortOrder
    position?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    list?: MovieListOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
  }

  export type MovieListItemWhereUniqueInput = Prisma.AtLeast<{
    listId_position?: MovieListItemListIdPositionCompoundUniqueInput
    listId_movieId?: MovieListItemListIdMovieIdCompoundUniqueInput
    AND?: MovieListItemWhereInput | MovieListItemWhereInput[]
    OR?: MovieListItemWhereInput[]
    NOT?: MovieListItemWhereInput | MovieListItemWhereInput[]
    listId?: StringFilter<"MovieListItem"> | string
    movieId?: IntFilter<"MovieListItem"> | number
    position?: IntNullableFilter<"MovieListItem"> | number | null
    note?: StringNullableFilter<"MovieListItem"> | string | null
    addedAt?: DateTimeFilter<"MovieListItem"> | Date | string
    list?: XOR<MovieListScalarRelationFilter, MovieListWhereInput>
    movie?: XOR<MovieNullableScalarRelationFilter, MovieWhereInput> | null
  }, "listId_movieId" | "listId_position">

  export type MovieListItemOrderByWithAggregationInput = {
    listId?: SortOrder
    movieId?: SortOrder
    position?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    addedAt?: SortOrder
    _count?: MovieListItemCountOrderByAggregateInput
    _avg?: MovieListItemAvgOrderByAggregateInput
    _max?: MovieListItemMaxOrderByAggregateInput
    _min?: MovieListItemMinOrderByAggregateInput
    _sum?: MovieListItemSumOrderByAggregateInput
  }

  export type MovieListItemScalarWhereWithAggregatesInput = {
    AND?: MovieListItemScalarWhereWithAggregatesInput | MovieListItemScalarWhereWithAggregatesInput[]
    OR?: MovieListItemScalarWhereWithAggregatesInput[]
    NOT?: MovieListItemScalarWhereWithAggregatesInput | MovieListItemScalarWhereWithAggregatesInput[]
    listId?: StringWithAggregatesFilter<"MovieListItem"> | string
    movieId?: IntWithAggregatesFilter<"MovieListItem"> | number
    position?: IntNullableWithAggregatesFilter<"MovieListItem"> | number | null
    note?: StringNullableWithAggregatesFilter<"MovieListItem"> | string | null
    addedAt?: DateTimeWithAggregatesFilter<"MovieListItem"> | Date | string
  }

  export type ImportRunWhereInput = {
    AND?: ImportRunWhereInput | ImportRunWhereInput[]
    OR?: ImportRunWhereInput[]
    NOT?: ImportRunWhereInput | ImportRunWhereInput[]
    id?: StringFilter<"ImportRun"> | string
    userId?: StringFilter<"ImportRun"> | string
    source?: StringFilter<"ImportRun"> | string
    status?: StringFilter<"ImportRun"> | string
    createdAt?: DateTimeFilter<"ImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"ImportRun"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    auditRows?: ImportAuditRowListRelationFilter
    watchLogs?: WatchLogListRelationFilter
  }

  export type ImportRunOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    auditRows?: ImportAuditRowOrderByRelationAggregateInput
    watchLogs?: WatchLogOrderByRelationAggregateInput
  }

  export type ImportRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportRunWhereInput | ImportRunWhereInput[]
    OR?: ImportRunWhereInput[]
    NOT?: ImportRunWhereInput | ImportRunWhereInput[]
    userId?: StringFilter<"ImportRun"> | string
    source?: StringFilter<"ImportRun"> | string
    status?: StringFilter<"ImportRun"> | string
    createdAt?: DateTimeFilter<"ImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"ImportRun"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    auditRows?: ImportAuditRowListRelationFilter
    watchLogs?: WatchLogListRelationFilter
  }, "id">

  export type ImportRunOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImportRunCountOrderByAggregateInput
    _max?: ImportRunMaxOrderByAggregateInput
    _min?: ImportRunMinOrderByAggregateInput
  }

  export type ImportRunScalarWhereWithAggregatesInput = {
    AND?: ImportRunScalarWhereWithAggregatesInput | ImportRunScalarWhereWithAggregatesInput[]
    OR?: ImportRunScalarWhereWithAggregatesInput[]
    NOT?: ImportRunScalarWhereWithAggregatesInput | ImportRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportRun"> | string
    userId?: StringWithAggregatesFilter<"ImportRun"> | string
    source?: StringWithAggregatesFilter<"ImportRun"> | string
    status?: StringWithAggregatesFilter<"ImportRun"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ImportRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImportRun"> | Date | string
  }

  export type ImportAuditRowWhereInput = {
    AND?: ImportAuditRowWhereInput | ImportAuditRowWhereInput[]
    OR?: ImportAuditRowWhereInput[]
    NOT?: ImportAuditRowWhereInput | ImportAuditRowWhereInput[]
    id?: StringFilter<"ImportAuditRow"> | string
    importId?: StringFilter<"ImportAuditRow"> | string
    fileName?: StringFilter<"ImportAuditRow"> | string
    rowNumber?: IntFilter<"ImportAuditRow"> | number
    title?: StringFilter<"ImportAuditRow"> | string
    year?: IntNullableFilter<"ImportAuditRow"> | number | null
    letterboxdUrl?: StringNullableFilter<"ImportAuditRow"> | string | null
    tmdbMovieId?: IntNullableFilter<"ImportAuditRow"> | number | null
    status?: StringFilter<"ImportAuditRow"> | string
    message?: StringNullableFilter<"ImportAuditRow"> | string | null
    rawJson?: StringNullableFilter<"ImportAuditRow"> | string | null
    importRun?: XOR<ImportRunScalarRelationFilter, ImportRunWhereInput>
  }

  export type ImportAuditRowOrderByWithRelationInput = {
    id?: SortOrder
    importId?: SortOrder
    fileName?: SortOrder
    rowNumber?: SortOrder
    title?: SortOrder
    year?: SortOrderInput | SortOrder
    letterboxdUrl?: SortOrderInput | SortOrder
    tmdbMovieId?: SortOrderInput | SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    rawJson?: SortOrderInput | SortOrder
    importRun?: ImportRunOrderByWithRelationInput
  }

  export type ImportAuditRowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    importId_fileName_rowNumber?: ImportAuditRowImportIdFileNameRowNumberCompoundUniqueInput
    AND?: ImportAuditRowWhereInput | ImportAuditRowWhereInput[]
    OR?: ImportAuditRowWhereInput[]
    NOT?: ImportAuditRowWhereInput | ImportAuditRowWhereInput[]
    importId?: StringFilter<"ImportAuditRow"> | string
    fileName?: StringFilter<"ImportAuditRow"> | string
    rowNumber?: IntFilter<"ImportAuditRow"> | number
    title?: StringFilter<"ImportAuditRow"> | string
    year?: IntNullableFilter<"ImportAuditRow"> | number | null
    letterboxdUrl?: StringNullableFilter<"ImportAuditRow"> | string | null
    tmdbMovieId?: IntNullableFilter<"ImportAuditRow"> | number | null
    status?: StringFilter<"ImportAuditRow"> | string
    message?: StringNullableFilter<"ImportAuditRow"> | string | null
    rawJson?: StringNullableFilter<"ImportAuditRow"> | string | null
    importRun?: XOR<ImportRunScalarRelationFilter, ImportRunWhereInput>
  }, "id" | "importId_fileName_rowNumber">

  export type ImportAuditRowOrderByWithAggregationInput = {
    id?: SortOrder
    importId?: SortOrder
    fileName?: SortOrder
    rowNumber?: SortOrder
    title?: SortOrder
    year?: SortOrderInput | SortOrder
    letterboxdUrl?: SortOrderInput | SortOrder
    tmdbMovieId?: SortOrderInput | SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    rawJson?: SortOrderInput | SortOrder
    _count?: ImportAuditRowCountOrderByAggregateInput
    _avg?: ImportAuditRowAvgOrderByAggregateInput
    _max?: ImportAuditRowMaxOrderByAggregateInput
    _min?: ImportAuditRowMinOrderByAggregateInput
    _sum?: ImportAuditRowSumOrderByAggregateInput
  }

  export type ImportAuditRowScalarWhereWithAggregatesInput = {
    AND?: ImportAuditRowScalarWhereWithAggregatesInput | ImportAuditRowScalarWhereWithAggregatesInput[]
    OR?: ImportAuditRowScalarWhereWithAggregatesInput[]
    NOT?: ImportAuditRowScalarWhereWithAggregatesInput | ImportAuditRowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportAuditRow"> | string
    importId?: StringWithAggregatesFilter<"ImportAuditRow"> | string
    fileName?: StringWithAggregatesFilter<"ImportAuditRow"> | string
    rowNumber?: IntWithAggregatesFilter<"ImportAuditRow"> | number
    title?: StringWithAggregatesFilter<"ImportAuditRow"> | string
    year?: IntNullableWithAggregatesFilter<"ImportAuditRow"> | number | null
    letterboxdUrl?: StringNullableWithAggregatesFilter<"ImportAuditRow"> | string | null
    tmdbMovieId?: IntNullableWithAggregatesFilter<"ImportAuditRow"> | number | null
    status?: StringWithAggregatesFilter<"ImportAuditRow"> | string
    message?: StringNullableWithAggregatesFilter<"ImportAuditRow"> | string | null
    rawJson?: StringNullableWithAggregatesFilter<"ImportAuditRow"> | string | null
  }

  export type BallotWhereInput = {
    AND?: BallotWhereInput | BallotWhereInput[]
    OR?: BallotWhereInput[]
    NOT?: BallotWhereInput | BallotWhereInput[]
    id?: StringFilter<"Ballot"> | string
    userId?: StringFilter<"Ballot"> | string
    eventYear?: IntFilter<"Ballot"> | number
    category?: StringFilter<"Ballot"> | string
    nomineeId?: StringFilter<"Ballot"> | string
    nomineeName?: StringFilter<"Ballot"> | string
    isWinner?: BoolFilter<"Ballot"> | boolean
    createdAt?: DateTimeFilter<"Ballot"> | Date | string
    updatedAt?: DateTimeFilter<"Ballot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BallotOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventYear?: SortOrder
    category?: SortOrder
    nomineeId?: SortOrder
    nomineeName?: SortOrder
    isWinner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BallotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_eventYear_category?: BallotUserIdEventYearCategoryCompoundUniqueInput
    AND?: BallotWhereInput | BallotWhereInput[]
    OR?: BallotWhereInput[]
    NOT?: BallotWhereInput | BallotWhereInput[]
    userId?: StringFilter<"Ballot"> | string
    eventYear?: IntFilter<"Ballot"> | number
    category?: StringFilter<"Ballot"> | string
    nomineeId?: StringFilter<"Ballot"> | string
    nomineeName?: StringFilter<"Ballot"> | string
    isWinner?: BoolFilter<"Ballot"> | boolean
    createdAt?: DateTimeFilter<"Ballot"> | Date | string
    updatedAt?: DateTimeFilter<"Ballot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_eventYear_category">

  export type BallotOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventYear?: SortOrder
    category?: SortOrder
    nomineeId?: SortOrder
    nomineeName?: SortOrder
    isWinner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BallotCountOrderByAggregateInput
    _avg?: BallotAvgOrderByAggregateInput
    _max?: BallotMaxOrderByAggregateInput
    _min?: BallotMinOrderByAggregateInput
    _sum?: BallotSumOrderByAggregateInput
  }

  export type BallotScalarWhereWithAggregatesInput = {
    AND?: BallotScalarWhereWithAggregatesInput | BallotScalarWhereWithAggregatesInput[]
    OR?: BallotScalarWhereWithAggregatesInput[]
    NOT?: BallotScalarWhereWithAggregatesInput | BallotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ballot"> | string
    userId?: StringWithAggregatesFilter<"Ballot"> | string
    eventYear?: IntWithAggregatesFilter<"Ballot"> | number
    category?: StringWithAggregatesFilter<"Ballot"> | string
    nomineeId?: StringWithAggregatesFilter<"Ballot"> | string
    nomineeName?: StringWithAggregatesFilter<"Ballot"> | string
    isWinner?: BoolWithAggregatesFilter<"Ballot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Ballot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ballot"> | Date | string
  }

  export type AwardEventWhereInput = {
    AND?: AwardEventWhereInput | AwardEventWhereInput[]
    OR?: AwardEventWhereInput[]
    NOT?: AwardEventWhereInput | AwardEventWhereInput[]
    id?: StringFilter<"AwardEvent"> | string
    name?: StringFilter<"AwardEvent"> | string
    slug?: StringFilter<"AwardEvent"> | string
    type?: StringFilter<"AwardEvent"> | string
    seasons?: AwardSeasonListRelationFilter
  }

  export type AwardEventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    seasons?: AwardSeasonOrderByRelationAggregateInput
  }

  export type AwardEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: AwardEventWhereInput | AwardEventWhereInput[]
    OR?: AwardEventWhereInput[]
    NOT?: AwardEventWhereInput | AwardEventWhereInput[]
    type?: StringFilter<"AwardEvent"> | string
    seasons?: AwardSeasonListRelationFilter
  }, "id" | "name" | "slug">

  export type AwardEventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    _count?: AwardEventCountOrderByAggregateInput
    _max?: AwardEventMaxOrderByAggregateInput
    _min?: AwardEventMinOrderByAggregateInput
  }

  export type AwardEventScalarWhereWithAggregatesInput = {
    AND?: AwardEventScalarWhereWithAggregatesInput | AwardEventScalarWhereWithAggregatesInput[]
    OR?: AwardEventScalarWhereWithAggregatesInput[]
    NOT?: AwardEventScalarWhereWithAggregatesInput | AwardEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AwardEvent"> | string
    name?: StringWithAggregatesFilter<"AwardEvent"> | string
    slug?: StringWithAggregatesFilter<"AwardEvent"> | string
    type?: StringWithAggregatesFilter<"AwardEvent"> | string
  }

  export type AwardSeasonWhereInput = {
    AND?: AwardSeasonWhereInput | AwardSeasonWhereInput[]
    OR?: AwardSeasonWhereInput[]
    NOT?: AwardSeasonWhereInput | AwardSeasonWhereInput[]
    id?: StringFilter<"AwardSeason"> | string
    eventId?: StringFilter<"AwardSeason"> | string
    year?: IntFilter<"AwardSeason"> | number
    season?: StringFilter<"AwardSeason"> | string
    phase?: StringFilter<"AwardSeason"> | string
    date?: DateTimeNullableFilter<"AwardSeason"> | Date | string | null
    event?: XOR<AwardEventScalarRelationFilter, AwardEventWhereInput>
    winners?: AwardWinnerListRelationFilter
  }

  export type AwardSeasonOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    year?: SortOrder
    season?: SortOrder
    phase?: SortOrder
    date?: SortOrderInput | SortOrder
    event?: AwardEventOrderByWithRelationInput
    winners?: AwardWinnerOrderByRelationAggregateInput
  }

  export type AwardSeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_year?: AwardSeasonEventIdYearCompoundUniqueInput
    eventId_season?: AwardSeasonEventIdSeasonCompoundUniqueInput
    AND?: AwardSeasonWhereInput | AwardSeasonWhereInput[]
    OR?: AwardSeasonWhereInput[]
    NOT?: AwardSeasonWhereInput | AwardSeasonWhereInput[]
    eventId?: StringFilter<"AwardSeason"> | string
    year?: IntFilter<"AwardSeason"> | number
    season?: StringFilter<"AwardSeason"> | string
    phase?: StringFilter<"AwardSeason"> | string
    date?: DateTimeNullableFilter<"AwardSeason"> | Date | string | null
    event?: XOR<AwardEventScalarRelationFilter, AwardEventWhereInput>
    winners?: AwardWinnerListRelationFilter
  }, "id" | "eventId_year" | "eventId_season">

  export type AwardSeasonOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    year?: SortOrder
    season?: SortOrder
    phase?: SortOrder
    date?: SortOrderInput | SortOrder
    _count?: AwardSeasonCountOrderByAggregateInput
    _avg?: AwardSeasonAvgOrderByAggregateInput
    _max?: AwardSeasonMaxOrderByAggregateInput
    _min?: AwardSeasonMinOrderByAggregateInput
    _sum?: AwardSeasonSumOrderByAggregateInput
  }

  export type AwardSeasonScalarWhereWithAggregatesInput = {
    AND?: AwardSeasonScalarWhereWithAggregatesInput | AwardSeasonScalarWhereWithAggregatesInput[]
    OR?: AwardSeasonScalarWhereWithAggregatesInput[]
    NOT?: AwardSeasonScalarWhereWithAggregatesInput | AwardSeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AwardSeason"> | string
    eventId?: StringWithAggregatesFilter<"AwardSeason"> | string
    year?: IntWithAggregatesFilter<"AwardSeason"> | number
    season?: StringWithAggregatesFilter<"AwardSeason"> | string
    phase?: StringWithAggregatesFilter<"AwardSeason"> | string
    date?: DateTimeNullableWithAggregatesFilter<"AwardSeason"> | Date | string | null
  }

  export type MovieWhereInput = {
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    tmdbId?: IntFilter<"Movie"> | number
    title?: StringFilter<"Movie"> | string
    posterPath?: StringNullableFilter<"Movie"> | string | null
    backdropPath?: StringNullableFilter<"Movie"> | string | null
    eligibleDate?: DateTimeNullableFilter<"Movie"> | Date | string | null
    eligibilityYear?: IntNullableFilter<"Movie"> | number | null
    seasonKey?: StringNullableFilter<"Movie"> | string | null
    winners?: AwardWinnerListRelationFilter
    interactions?: MovieInteractionListRelationFilter
    watchLogs?: WatchLogListRelationFilter
    listItems?: MovieListItemListRelationFilter
  }

  export type MovieOrderByWithRelationInput = {
    tmdbId?: SortOrder
    title?: SortOrder
    posterPath?: SortOrderInput | SortOrder
    backdropPath?: SortOrderInput | SortOrder
    eligibleDate?: SortOrderInput | SortOrder
    eligibilityYear?: SortOrderInput | SortOrder
    seasonKey?: SortOrderInput | SortOrder
    winners?: AwardWinnerOrderByRelationAggregateInput
    interactions?: MovieInteractionOrderByRelationAggregateInput
    watchLogs?: WatchLogOrderByRelationAggregateInput
    listItems?: MovieListItemOrderByRelationAggregateInput
  }

  export type MovieWhereUniqueInput = Prisma.AtLeast<{
    tmdbId?: number
    AND?: MovieWhereInput | MovieWhereInput[]
    OR?: MovieWhereInput[]
    NOT?: MovieWhereInput | MovieWhereInput[]
    title?: StringFilter<"Movie"> | string
    posterPath?: StringNullableFilter<"Movie"> | string | null
    backdropPath?: StringNullableFilter<"Movie"> | string | null
    eligibleDate?: DateTimeNullableFilter<"Movie"> | Date | string | null
    eligibilityYear?: IntNullableFilter<"Movie"> | number | null
    seasonKey?: StringNullableFilter<"Movie"> | string | null
    winners?: AwardWinnerListRelationFilter
    interactions?: MovieInteractionListRelationFilter
    watchLogs?: WatchLogListRelationFilter
    listItems?: MovieListItemListRelationFilter
  }, "tmdbId">

  export type MovieOrderByWithAggregationInput = {
    tmdbId?: SortOrder
    title?: SortOrder
    posterPath?: SortOrderInput | SortOrder
    backdropPath?: SortOrderInput | SortOrder
    eligibleDate?: SortOrderInput | SortOrder
    eligibilityYear?: SortOrderInput | SortOrder
    seasonKey?: SortOrderInput | SortOrder
    _count?: MovieCountOrderByAggregateInput
    _avg?: MovieAvgOrderByAggregateInput
    _max?: MovieMaxOrderByAggregateInput
    _min?: MovieMinOrderByAggregateInput
    _sum?: MovieSumOrderByAggregateInput
  }

  export type MovieScalarWhereWithAggregatesInput = {
    AND?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    OR?: MovieScalarWhereWithAggregatesInput[]
    NOT?: MovieScalarWhereWithAggregatesInput | MovieScalarWhereWithAggregatesInput[]
    tmdbId?: IntWithAggregatesFilter<"Movie"> | number
    title?: StringWithAggregatesFilter<"Movie"> | string
    posterPath?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    backdropPath?: StringNullableWithAggregatesFilter<"Movie"> | string | null
    eligibleDate?: DateTimeNullableWithAggregatesFilter<"Movie"> | Date | string | null
    eligibilityYear?: IntNullableWithAggregatesFilter<"Movie"> | number | null
    seasonKey?: StringNullableWithAggregatesFilter<"Movie"> | string | null
  }

  export type AwardWinnerWhereInput = {
    AND?: AwardWinnerWhereInput | AwardWinnerWhereInput[]
    OR?: AwardWinnerWhereInput[]
    NOT?: AwardWinnerWhereInput | AwardWinnerWhereInput[]
    id?: StringFilter<"AwardWinner"> | string
    seasonId?: StringFilter<"AwardWinner"> | string
    prizeName?: StringFilter<"AwardWinner"> | string
    movieId?: IntFilter<"AwardWinner"> | number
    movieTitle?: StringFilter<"AwardWinner"> | string
    posterPath?: StringNullableFilter<"AwardWinner"> | string | null
    personName?: StringNullableFilter<"AwardWinner"> | string | null
    personPath?: StringNullableFilter<"AwardWinner"> | string | null
    isWinner?: BoolFilter<"AwardWinner"> | boolean
    sourceUrl?: StringNullableFilter<"AwardWinner"> | string | null
    createdAt?: DateTimeFilter<"AwardWinner"> | Date | string
    seasonRel?: XOR<AwardSeasonScalarRelationFilter, AwardSeasonWhereInput>
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }

  export type AwardWinnerOrderByWithRelationInput = {
    id?: SortOrder
    seasonId?: SortOrder
    prizeName?: SortOrder
    movieId?: SortOrder
    movieTitle?: SortOrder
    posterPath?: SortOrderInput | SortOrder
    personName?: SortOrderInput | SortOrder
    personPath?: SortOrderInput | SortOrder
    isWinner?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    seasonRel?: AwardSeasonOrderByWithRelationInput
    movie?: MovieOrderByWithRelationInput
  }

  export type AwardWinnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AwardWinnerWhereInput | AwardWinnerWhereInput[]
    OR?: AwardWinnerWhereInput[]
    NOT?: AwardWinnerWhereInput | AwardWinnerWhereInput[]
    seasonId?: StringFilter<"AwardWinner"> | string
    prizeName?: StringFilter<"AwardWinner"> | string
    movieId?: IntFilter<"AwardWinner"> | number
    movieTitle?: StringFilter<"AwardWinner"> | string
    posterPath?: StringNullableFilter<"AwardWinner"> | string | null
    personName?: StringNullableFilter<"AwardWinner"> | string | null
    personPath?: StringNullableFilter<"AwardWinner"> | string | null
    isWinner?: BoolFilter<"AwardWinner"> | boolean
    sourceUrl?: StringNullableFilter<"AwardWinner"> | string | null
    createdAt?: DateTimeFilter<"AwardWinner"> | Date | string
    seasonRel?: XOR<AwardSeasonScalarRelationFilter, AwardSeasonWhereInput>
    movie?: XOR<MovieScalarRelationFilter, MovieWhereInput>
  }, "id">

  export type AwardWinnerOrderByWithAggregationInput = {
    id?: SortOrder
    seasonId?: SortOrder
    prizeName?: SortOrder
    movieId?: SortOrder
    movieTitle?: SortOrder
    posterPath?: SortOrderInput | SortOrder
    personName?: SortOrderInput | SortOrder
    personPath?: SortOrderInput | SortOrder
    isWinner?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AwardWinnerCountOrderByAggregateInput
    _avg?: AwardWinnerAvgOrderByAggregateInput
    _max?: AwardWinnerMaxOrderByAggregateInput
    _min?: AwardWinnerMinOrderByAggregateInput
    _sum?: AwardWinnerSumOrderByAggregateInput
  }

  export type AwardWinnerScalarWhereWithAggregatesInput = {
    AND?: AwardWinnerScalarWhereWithAggregatesInput | AwardWinnerScalarWhereWithAggregatesInput[]
    OR?: AwardWinnerScalarWhereWithAggregatesInput[]
    NOT?: AwardWinnerScalarWhereWithAggregatesInput | AwardWinnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AwardWinner"> | string
    seasonId?: StringWithAggregatesFilter<"AwardWinner"> | string
    prizeName?: StringWithAggregatesFilter<"AwardWinner"> | string
    movieId?: IntWithAggregatesFilter<"AwardWinner"> | number
    movieTitle?: StringWithAggregatesFilter<"AwardWinner"> | string
    posterPath?: StringNullableWithAggregatesFilter<"AwardWinner"> | string | null
    personName?: StringNullableWithAggregatesFilter<"AwardWinner"> | string | null
    personPath?: StringNullableWithAggregatesFilter<"AwardWinner"> | string | null
    isWinner?: BoolWithAggregatesFilter<"AwardWinner"> | boolean
    sourceUrl?: StringNullableWithAggregatesFilter<"AwardWinner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AwardWinner"> | Date | string
  }

  export type StreamingSubscriptionWhereInput = {
    AND?: StreamingSubscriptionWhereInput | StreamingSubscriptionWhereInput[]
    OR?: StreamingSubscriptionWhereInput[]
    NOT?: StreamingSubscriptionWhereInput | StreamingSubscriptionWhereInput[]
    id?: StringFilter<"StreamingSubscription"> | string
    userId?: StringFilter<"StreamingSubscription"> | string
    providerId?: IntFilter<"StreamingSubscription"> | number
    name?: StringFilter<"StreamingSubscription"> | string
    logoPath?: StringNullableFilter<"StreamingSubscription"> | string | null
    createdAt?: DateTimeFilter<"StreamingSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StreamingSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    logoPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StreamingSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_providerId?: StreamingSubscriptionUserIdProviderIdCompoundUniqueInput
    AND?: StreamingSubscriptionWhereInput | StreamingSubscriptionWhereInput[]
    OR?: StreamingSubscriptionWhereInput[]
    NOT?: StreamingSubscriptionWhereInput | StreamingSubscriptionWhereInput[]
    userId?: StringFilter<"StreamingSubscription"> | string
    providerId?: IntFilter<"StreamingSubscription"> | number
    name?: StringFilter<"StreamingSubscription"> | string
    logoPath?: StringNullableFilter<"StreamingSubscription"> | string | null
    createdAt?: DateTimeFilter<"StreamingSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_providerId">

  export type StreamingSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    logoPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StreamingSubscriptionCountOrderByAggregateInput
    _avg?: StreamingSubscriptionAvgOrderByAggregateInput
    _max?: StreamingSubscriptionMaxOrderByAggregateInput
    _min?: StreamingSubscriptionMinOrderByAggregateInput
    _sum?: StreamingSubscriptionSumOrderByAggregateInput
  }

  export type StreamingSubscriptionScalarWhereWithAggregatesInput = {
    AND?: StreamingSubscriptionScalarWhereWithAggregatesInput | StreamingSubscriptionScalarWhereWithAggregatesInput[]
    OR?: StreamingSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: StreamingSubscriptionScalarWhereWithAggregatesInput | StreamingSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StreamingSubscription"> | string
    userId?: StringWithAggregatesFilter<"StreamingSubscription"> | string
    providerId?: IntWithAggregatesFilter<"StreamingSubscription"> | number
    name?: StringWithAggregatesFilter<"StreamingSubscription"> | string
    logoPath?: StringNullableWithAggregatesFilter<"StreamingSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StreamingSubscription"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    userId?: StringFilter<"UserSettings"> | string
    providerMode?: StringFilter<"UserSettings"> | string
    region?: StringNullableFilter<"UserSettings"> | string | null
    runtimeMin?: IntNullableFilter<"UserSettings"> | number | null
    runtimeMax?: IntNullableFilter<"UserSettings"> | number | null
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    userId?: SortOrder
    providerMode?: SortOrder
    region?: SortOrderInput | SortOrder
    runtimeMin?: SortOrderInput | SortOrder
    runtimeMax?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    providerMode?: StringFilter<"UserSettings"> | string
    region?: StringNullableFilter<"UserSettings"> | string | null
    runtimeMin?: IntNullableFilter<"UserSettings"> | number | null
    runtimeMax?: IntNullableFilter<"UserSettings"> | number | null
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    userId?: SortOrder
    providerMode?: SortOrder
    region?: SortOrderInput | SortOrder
    runtimeMin?: SortOrderInput | SortOrder
    runtimeMax?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _avg?: UserSettingsAvgOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
    _sum?: UserSettingsSumOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    providerMode?: StringWithAggregatesFilter<"UserSettings"> | string
    region?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    runtimeMin?: IntNullableWithAggregatesFilter<"UserSettings"> | number | null
    runtimeMax?: IntNullableWithAggregatesFilter<"UserSettings"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type OnboardingStateWhereInput = {
    AND?: OnboardingStateWhereInput | OnboardingStateWhereInput[]
    OR?: OnboardingStateWhereInput[]
    NOT?: OnboardingStateWhereInput | OnboardingStateWhereInput[]
    userId?: StringFilter<"OnboardingState"> | string
    isCompleted?: BoolFilter<"OnboardingState"> | boolean
    completedAt?: DateTimeNullableFilter<"OnboardingState"> | Date | string | null
    lastNudgedAt?: DateTimeNullableFilter<"OnboardingState"> | Date | string | null
    updatedAt?: DateTimeFilter<"OnboardingState"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OnboardingStateOrderByWithRelationInput = {
    userId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastNudgedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OnboardingStateWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: OnboardingStateWhereInput | OnboardingStateWhereInput[]
    OR?: OnboardingStateWhereInput[]
    NOT?: OnboardingStateWhereInput | OnboardingStateWhereInput[]
    isCompleted?: BoolFilter<"OnboardingState"> | boolean
    completedAt?: DateTimeNullableFilter<"OnboardingState"> | Date | string | null
    lastNudgedAt?: DateTimeNullableFilter<"OnboardingState"> | Date | string | null
    updatedAt?: DateTimeFilter<"OnboardingState"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type OnboardingStateOrderByWithAggregationInput = {
    userId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastNudgedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: OnboardingStateCountOrderByAggregateInput
    _max?: OnboardingStateMaxOrderByAggregateInput
    _min?: OnboardingStateMinOrderByAggregateInput
  }

  export type OnboardingStateScalarWhereWithAggregatesInput = {
    AND?: OnboardingStateScalarWhereWithAggregatesInput | OnboardingStateScalarWhereWithAggregatesInput[]
    OR?: OnboardingStateScalarWhereWithAggregatesInput[]
    NOT?: OnboardingStateScalarWhereWithAggregatesInput | OnboardingStateScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"OnboardingState"> | string
    isCompleted?: BoolWithAggregatesFilter<"OnboardingState"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"OnboardingState"> | Date | string | null
    lastNudgedAt?: DateTimeNullableWithAggregatesFilter<"OnboardingState"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"OnboardingState"> | Date | string
  }

  export type UserPreferredGenreWhereInput = {
    AND?: UserPreferredGenreWhereInput | UserPreferredGenreWhereInput[]
    OR?: UserPreferredGenreWhereInput[]
    NOT?: UserPreferredGenreWhereInput | UserPreferredGenreWhereInput[]
    userId?: StringFilter<"UserPreferredGenre"> | string
    genreId?: IntFilter<"UserPreferredGenre"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferredGenreOrderByWithRelationInput = {
    userId?: SortOrder
    genreId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferredGenreWhereUniqueInput = Prisma.AtLeast<{
    userId_genreId?: UserPreferredGenreUserIdGenreIdCompoundUniqueInput
    AND?: UserPreferredGenreWhereInput | UserPreferredGenreWhereInput[]
    OR?: UserPreferredGenreWhereInput[]
    NOT?: UserPreferredGenreWhereInput | UserPreferredGenreWhereInput[]
    userId?: StringFilter<"UserPreferredGenre"> | string
    genreId?: IntFilter<"UserPreferredGenre"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_genreId">

  export type UserPreferredGenreOrderByWithAggregationInput = {
    userId?: SortOrder
    genreId?: SortOrder
    _count?: UserPreferredGenreCountOrderByAggregateInput
    _avg?: UserPreferredGenreAvgOrderByAggregateInput
    _max?: UserPreferredGenreMaxOrderByAggregateInput
    _min?: UserPreferredGenreMinOrderByAggregateInput
    _sum?: UserPreferredGenreSumOrderByAggregateInput
  }

  export type UserPreferredGenreScalarWhereWithAggregatesInput = {
    AND?: UserPreferredGenreScalarWhereWithAggregatesInput | UserPreferredGenreScalarWhereWithAggregatesInput[]
    OR?: UserPreferredGenreScalarWhereWithAggregatesInput[]
    NOT?: UserPreferredGenreScalarWhereWithAggregatesInput | UserPreferredGenreScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserPreferredGenre"> | string
    genreId?: IntWithAggregatesFilter<"UserPreferredGenre"> | number
  }

  export type UserTopTenWhereInput = {
    AND?: UserTopTenWhereInput | UserTopTenWhereInput[]
    OR?: UserTopTenWhereInput[]
    NOT?: UserTopTenWhereInput | UserTopTenWhereInput[]
    id?: StringFilter<"UserTopTen"> | string
    userId?: StringFilter<"UserTopTen"> | string
    tmdbId?: IntFilter<"UserTopTen"> | number
    position?: IntFilter<"UserTopTen"> | number
    createdAt?: DateTimeFilter<"UserTopTen"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserTopTenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tmdbId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserTopTenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tmdbId?: UserTopTenUserIdTmdbIdCompoundUniqueInput
    userId_position?: UserTopTenUserIdPositionCompoundUniqueInput
    AND?: UserTopTenWhereInput | UserTopTenWhereInput[]
    OR?: UserTopTenWhereInput[]
    NOT?: UserTopTenWhereInput | UserTopTenWhereInput[]
    userId?: StringFilter<"UserTopTen"> | string
    tmdbId?: IntFilter<"UserTopTen"> | number
    position?: IntFilter<"UserTopTen"> | number
    createdAt?: DateTimeFilter<"UserTopTen"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_tmdbId" | "userId_position">

  export type UserTopTenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tmdbId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    _count?: UserTopTenCountOrderByAggregateInput
    _avg?: UserTopTenAvgOrderByAggregateInput
    _max?: UserTopTenMaxOrderByAggregateInput
    _min?: UserTopTenMinOrderByAggregateInput
    _sum?: UserTopTenSumOrderByAggregateInput
  }

  export type UserTopTenScalarWhereWithAggregatesInput = {
    AND?: UserTopTenScalarWhereWithAggregatesInput | UserTopTenScalarWhereWithAggregatesInput[]
    OR?: UserTopTenScalarWhereWithAggregatesInput[]
    NOT?: UserTopTenScalarWhereWithAggregatesInput | UserTopTenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTopTen"> | string
    userId?: StringWithAggregatesFilter<"UserTopTen"> | string
    tmdbId?: IntWithAggregatesFilter<"UserTopTen"> | number
    position?: IntWithAggregatesFilter<"UserTopTen"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserTopTen"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieInteractionCreateInput = {
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInteractionsInput
    movie?: MovieCreateNestedOneWithoutInteractionsInput
  }

  export type MovieInteractionUncheckedCreateInput = {
    userId: string
    movieId: number
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type MovieInteractionUpdateInput = {
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInteractionsNestedInput
    movie?: MovieUpdateOneWithoutInteractionsNestedInput
  }

  export type MovieInteractionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieInteractionCreateManyInput = {
    userId: string
    movieId: number
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type MovieInteractionUpdateManyMutationInput = {
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieInteractionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchLogCreateInput = {
    id?: string
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchLogsInput
    importRun?: ImportRunCreateNestedOneWithoutWatchLogsInput
    movie: MovieCreateNestedOneWithoutWatchLogsInput
    review?: ReviewCreateNestedOneWithoutWatchLogInput
  }

  export type WatchLogUncheckedCreateInput = {
    id?: string
    userId: string
    movieId: number
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importId?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutWatchLogInput
  }

  export type WatchLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchLogsNestedInput
    importRun?: ImportRunUpdateOneWithoutWatchLogsNestedInput
    movie?: MovieUpdateOneRequiredWithoutWatchLogsNestedInput
    review?: ReviewUpdateOneWithoutWatchLogNestedInput
  }

  export type WatchLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutWatchLogNestedInput
  }

  export type WatchLogCreateManyInput = {
    id?: string
    userId: string
    movieId: number
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importId?: string | null
    importRowId?: string | null
    createdAt?: Date | string
  }

  export type WatchLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    movieId: number
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    watchLog?: WatchLogCreateNestedOneWithoutReviewInput
    comments?: ReviewCommentCreateNestedManyWithoutReviewInput
    favorites?: ReviewFavoriteCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    movieId: number
    watchLogId?: string | null
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ReviewCommentUncheckedCreateNestedManyWithoutReviewInput
    favorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    watchLog?: WatchLogUpdateOneWithoutReviewNestedInput
    comments?: ReviewCommentUpdateManyWithoutReviewNestedInput
    favorites?: ReviewFavoriteUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchLogId?: NullableStringFieldUpdateOperationsInput | string | null
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput
    favorites?: ReviewFavoriteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    movieId: number
    watchLogId?: string | null
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchLogId?: NullableStringFieldUpdateOperationsInput | string | null
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentCreateInput = {
    id?: string
    body: string
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutReviewCommentsInput
  }

  export type ReviewCommentUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId: string
    body: string
    createdAt?: Date | string
  }

  export type ReviewCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewCommentsNestedInput
  }

  export type ReviewCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentCreateManyInput = {
    id?: string
    reviewId: string
    userId: string
    body: string
    createdAt?: Date | string
  }

  export type ReviewCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewFavoriteCreateInput = {
    review: ReviewCreateNestedOneWithoutFavoritesInput
    user: UserCreateNestedOneWithoutReviewFavoritesInput
  }

  export type ReviewFavoriteUncheckedCreateInput = {
    reviewId: string
    userId: string
  }

  export type ReviewFavoriteUpdateInput = {
    review?: ReviewUpdateOneRequiredWithoutFavoritesNestedInput
    user?: UserUpdateOneRequiredWithoutReviewFavoritesNestedInput
  }

  export type ReviewFavoriteUncheckedUpdateInput = {
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewFavoriteCreateManyInput = {
    reviewId: string
    userId: string
  }

  export type ReviewFavoriteUpdateManyMutationInput = {

  }

  export type ReviewFavoriteUncheckedUpdateManyInput = {
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MovieListCreateInput = {
    id?: string
    title: string
    description?: string | null
    tags?: string | null
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: string | null
    isPublic?: boolean
    sourceListId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMovieListsInput
    items?: MovieListItemCreateNestedManyWithoutListInput
  }

  export type MovieListUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    tags?: string | null
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: string | null
    isPublic?: boolean
    sourceListId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MovieListItemUncheckedCreateNestedManyWithoutListInput
  }

  export type MovieListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMovieListsNestedInput
    items?: MovieListItemUpdateManyWithoutListNestedInput
  }

  export type MovieListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MovieListItemUncheckedUpdateManyWithoutListNestedInput
  }

  export type MovieListCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    tags?: string | null
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: string | null
    isPublic?: boolean
    sourceListId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieListItemCreateInput = {
    position?: number | null
    note?: string | null
    addedAt?: Date | string
    list: MovieListCreateNestedOneWithoutItemsInput
    movie?: MovieCreateNestedOneWithoutListItemsInput
  }

  export type MovieListItemUncheckedCreateInput = {
    listId: string
    movieId: number
    position?: number | null
    note?: string | null
    addedAt?: Date | string
  }

  export type MovieListItemUpdateInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: MovieListUpdateOneRequiredWithoutItemsNestedInput
    movie?: MovieUpdateOneWithoutListItemsNestedInput
  }

  export type MovieListItemUncheckedUpdateInput = {
    listId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieListItemCreateManyInput = {
    listId: string
    movieId: number
    position?: number | null
    note?: string | null
    addedAt?: Date | string
  }

  export type MovieListItemUpdateManyMutationInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieListItemUncheckedUpdateManyInput = {
    listId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportRunCreateInput = {
    id?: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutImportRunsInput
    auditRows?: ImportAuditRowCreateNestedManyWithoutImportRunInput
    watchLogs?: WatchLogCreateNestedManyWithoutImportRunInput
  }

  export type ImportRunUncheckedCreateInput = {
    id?: string
    userId: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditRows?: ImportAuditRowUncheckedCreateNestedManyWithoutImportRunInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutImportRunInput
  }

  export type ImportRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutImportRunsNestedInput
    auditRows?: ImportAuditRowUpdateManyWithoutImportRunNestedInput
    watchLogs?: WatchLogUpdateManyWithoutImportRunNestedInput
  }

  export type ImportRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditRows?: ImportAuditRowUncheckedUpdateManyWithoutImportRunNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutImportRunNestedInput
  }

  export type ImportRunCreateManyInput = {
    id?: string
    userId: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportAuditRowCreateInput = {
    id?: string
    fileName: string
    rowNumber: number
    title: string
    year?: number | null
    letterboxdUrl?: string | null
    tmdbMovieId?: number | null
    status?: string
    message?: string | null
    rawJson?: string | null
    importRun: ImportRunCreateNestedOneWithoutAuditRowsInput
  }

  export type ImportAuditRowUncheckedCreateInput = {
    id?: string
    importId: string
    fileName: string
    rowNumber: number
    title: string
    year?: number | null
    letterboxdUrl?: string | null
    tmdbMovieId?: number | null
    status?: string
    message?: string | null
    rawJson?: string | null
  }

  export type ImportAuditRowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    letterboxdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tmdbMovieId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
    importRun?: ImportRunUpdateOneRequiredWithoutAuditRowsNestedInput
  }

  export type ImportAuditRowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    importId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    letterboxdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tmdbMovieId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportAuditRowCreateManyInput = {
    id?: string
    importId: string
    fileName: string
    rowNumber: number
    title: string
    year?: number | null
    letterboxdUrl?: string | null
    tmdbMovieId?: number | null
    status?: string
    message?: string | null
    rawJson?: string | null
  }

  export type ImportAuditRowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    letterboxdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tmdbMovieId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportAuditRowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    importId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    letterboxdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tmdbMovieId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BallotCreateInput = {
    id?: string
    eventYear: number
    category: string
    nomineeId: string
    nomineeName: string
    isWinner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBallotsInput
  }

  export type BallotUncheckedCreateInput = {
    id?: string
    userId: string
    eventYear: number
    category: string
    nomineeId: string
    nomineeName: string
    isWinner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BallotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventYear?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    nomineeId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBallotsNestedInput
  }

  export type BallotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventYear?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    nomineeId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BallotCreateManyInput = {
    id?: string
    userId: string
    eventYear: number
    category: string
    nomineeId: string
    nomineeName: string
    isWinner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BallotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventYear?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    nomineeId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BallotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventYear?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    nomineeId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwardEventCreateInput = {
    id?: string
    name: string
    slug: string
    type: string
    seasons?: AwardSeasonCreateNestedManyWithoutEventInput
  }

  export type AwardEventUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    type: string
    seasons?: AwardSeasonUncheckedCreateNestedManyWithoutEventInput
  }

  export type AwardEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasons?: AwardSeasonUpdateManyWithoutEventNestedInput
  }

  export type AwardEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    seasons?: AwardSeasonUncheckedUpdateManyWithoutEventNestedInput
  }

  export type AwardEventCreateManyInput = {
    id?: string
    name: string
    slug: string
    type: string
  }

  export type AwardEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type AwardEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type AwardSeasonCreateInput = {
    id?: string
    year: number
    season?: string
    phase?: string
    date?: Date | string | null
    event: AwardEventCreateNestedOneWithoutSeasonsInput
    winners?: AwardWinnerCreateNestedManyWithoutSeasonRelInput
  }

  export type AwardSeasonUncheckedCreateInput = {
    id?: string
    eventId: string
    year: number
    season?: string
    phase?: string
    date?: Date | string | null
    winners?: AwardWinnerUncheckedCreateNestedManyWithoutSeasonRelInput
  }

  export type AwardSeasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: AwardEventUpdateOneRequiredWithoutSeasonsNestedInput
    winners?: AwardWinnerUpdateManyWithoutSeasonRelNestedInput
  }

  export type AwardSeasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winners?: AwardWinnerUncheckedUpdateManyWithoutSeasonRelNestedInput
  }

  export type AwardSeasonCreateManyInput = {
    id?: string
    eventId: string
    year: number
    season?: string
    phase?: string
    date?: Date | string | null
  }

  export type AwardSeasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AwardSeasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MovieCreateInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    winners?: AwardWinnerCreateNestedManyWithoutMovieInput
    interactions?: MovieInteractionCreateNestedManyWithoutMovieInput
    watchLogs?: WatchLogCreateNestedManyWithoutMovieInput
    listItems?: MovieListItemCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    winners?: AwardWinnerUncheckedCreateNestedManyWithoutMovieInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutMovieInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutMovieInput
    listItems?: MovieListItemUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieUpdateInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    winners?: AwardWinnerUpdateManyWithoutMovieNestedInput
    interactions?: MovieInteractionUpdateManyWithoutMovieNestedInput
    watchLogs?: WatchLogUpdateManyWithoutMovieNestedInput
    listItems?: MovieListItemUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    winners?: AwardWinnerUncheckedUpdateManyWithoutMovieNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutMovieNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutMovieNestedInput
    listItems?: MovieListItemUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type MovieCreateManyInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
  }

  export type MovieUpdateManyMutationInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MovieUncheckedUpdateManyInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AwardWinnerCreateInput = {
    id?: string
    prizeName: string
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
    seasonRel: AwardSeasonCreateNestedOneWithoutWinnersInput
    movie: MovieCreateNestedOneWithoutWinnersInput
  }

  export type AwardWinnerUncheckedCreateInput = {
    id?: string
    seasonId: string
    prizeName: string
    movieId: number
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
  }

  export type AwardWinnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonRel?: AwardSeasonUpdateOneRequiredWithoutWinnersNestedInput
    movie?: MovieUpdateOneRequiredWithoutWinnersNestedInput
  }

  export type AwardWinnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwardWinnerCreateManyInput = {
    id?: string
    seasonId: string
    prizeName: string
    movieId: number
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
  }

  export type AwardWinnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwardWinnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamingSubscriptionCreateInput = {
    id?: string
    providerId: number
    name: string
    logoPath?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type StreamingSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    providerId: number
    name: string
    logoPath?: string | null
    createdAt?: Date | string
  }

  export type StreamingSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type StreamingSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamingSubscriptionCreateManyInput = {
    id?: string
    userId: string
    providerId: number
    name: string
    logoPath?: string | null
    createdAt?: Date | string
  }

  export type StreamingSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamingSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    providerMode?: string
    region?: string | null
    runtimeMin?: number | null
    runtimeMax?: number | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    userId: string
    providerMode?: string
    region?: string | null
    runtimeMin?: number | null
    runtimeMax?: number | null
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    providerMode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    runtimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    providerMode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    runtimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    userId: string
    providerMode?: string
    region?: string | null
    runtimeMin?: number | null
    runtimeMax?: number | null
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    providerMode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    runtimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    providerMode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    runtimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingStateCreateInput = {
    isCompleted?: boolean
    completedAt?: Date | string | null
    lastNudgedAt?: Date | string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOnboardingInput
  }

  export type OnboardingStateUncheckedCreateInput = {
    userId: string
    isCompleted?: boolean
    completedAt?: Date | string | null
    lastNudgedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type OnboardingStateUpdateInput = {
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNudgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOnboardingNestedInput
  }

  export type OnboardingStateUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNudgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingStateCreateManyInput = {
    userId: string
    isCompleted?: boolean
    completedAt?: Date | string | null
    lastNudgedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type OnboardingStateUpdateManyMutationInput = {
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNudgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingStateUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNudgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferredGenreCreateInput = {
    genreId: number
    user: UserCreateNestedOneWithoutPreferredGenresInput
  }

  export type UserPreferredGenreUncheckedCreateInput = {
    userId: string
    genreId: number
  }

  export type UserPreferredGenreUpdateInput = {
    genreId?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutPreferredGenresNestedInput
  }

  export type UserPreferredGenreUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    genreId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPreferredGenreCreateManyInput = {
    userId: string
    genreId: number
  }

  export type UserPreferredGenreUpdateManyMutationInput = {
    genreId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPreferredGenreUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    genreId?: IntFieldUpdateOperationsInput | number
  }

  export type UserTopTenCreateInput = {
    id?: string
    tmdbId: number
    position: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTopTenInput
  }

  export type UserTopTenUncheckedCreateInput = {
    id?: string
    userId: string
    tmdbId: number
    position: number
    createdAt?: Date | string
  }

  export type UserTopTenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTopTenNestedInput
  }

  export type UserTopTenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTopTenCreateManyInput = {
    id?: string
    userId: string
    tmdbId: number
    position: number
    createdAt?: Date | string
  }

  export type UserTopTenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTopTenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type MovieInteractionListRelationFilter = {
    every?: MovieInteractionWhereInput
    some?: MovieInteractionWhereInput
    none?: MovieInteractionWhereInput
  }

  export type WatchLogListRelationFilter = {
    every?: WatchLogWhereInput
    some?: WatchLogWhereInput
    none?: WatchLogWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ReviewCommentListRelationFilter = {
    every?: ReviewCommentWhereInput
    some?: ReviewCommentWhereInput
    none?: ReviewCommentWhereInput
  }

  export type ReviewFavoriteListRelationFilter = {
    every?: ReviewFavoriteWhereInput
    some?: ReviewFavoriteWhereInput
    none?: ReviewFavoriteWhereInput
  }

  export type MovieListListRelationFilter = {
    every?: MovieListWhereInput
    some?: MovieListWhereInput
    none?: MovieListWhereInput
  }

  export type BallotListRelationFilter = {
    every?: BallotWhereInput
    some?: BallotWhereInput
    none?: BallotWhereInput
  }

  export type StreamingSubscriptionListRelationFilter = {
    every?: StreamingSubscriptionWhereInput
    some?: StreamingSubscriptionWhereInput
    none?: StreamingSubscriptionWhereInput
  }

  export type ImportRunListRelationFilter = {
    every?: ImportRunWhereInput
    some?: ImportRunWhereInput
    none?: ImportRunWhereInput
  }

  export type UserTopTenListRelationFilter = {
    every?: UserTopTenWhereInput
    some?: UserTopTenWhereInput
    none?: UserTopTenWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type OnboardingStateNullableScalarRelationFilter = {
    is?: OnboardingStateWhereInput | null
    isNot?: OnboardingStateWhereInput | null
  }

  export type UserPreferredGenreListRelationFilter = {
    every?: UserPreferredGenreWhereInput
    some?: UserPreferredGenreWhereInput
    none?: UserPreferredGenreWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BallotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StreamingSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTopTenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPreferredGenreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MovieNullableScalarRelationFilter = {
    is?: MovieWhereInput | null
    isNot?: MovieWhereInput | null
  }

  export type MovieInteractionUserIdMovieIdCompoundUniqueInput = {
    userId: string
    movieId: number
  }

  export type MovieInteractionCountOrderByAggregateInput = {
    userId?: SortOrder
    movieId?: SortOrder
    watched?: SortOrder
    watchlisted?: SortOrder
    favorited?: SortOrder
    ratingHalf?: SortOrder
    ratedAt?: SortOrder
    favoritedAt?: SortOrder
    watchedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieInteractionAvgOrderByAggregateInput = {
    movieId?: SortOrder
    ratingHalf?: SortOrder
  }

  export type MovieInteractionMaxOrderByAggregateInput = {
    userId?: SortOrder
    movieId?: SortOrder
    watched?: SortOrder
    watchlisted?: SortOrder
    favorited?: SortOrder
    ratingHalf?: SortOrder
    ratedAt?: SortOrder
    favoritedAt?: SortOrder
    watchedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieInteractionMinOrderByAggregateInput = {
    userId?: SortOrder
    movieId?: SortOrder
    watched?: SortOrder
    watchlisted?: SortOrder
    favorited?: SortOrder
    ratingHalf?: SortOrder
    ratedAt?: SortOrder
    favoritedAt?: SortOrder
    watchedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieInteractionSumOrderByAggregateInput = {
    movieId?: SortOrder
    ratingHalf?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ImportRunNullableScalarRelationFilter = {
    is?: ImportRunWhereInput | null
    isNot?: ImportRunWhereInput | null
  }

  export type MovieScalarRelationFilter = {
    is?: MovieWhereInput
    isNot?: MovieWhereInput
  }

  export type ReviewNullableScalarRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type WatchLogUserIdMovieIdWatchedAtImportIdCompoundUniqueInput = {
    userId: string
    movieId: number
    watchedAt: Date | string
    importId: string
  }

  export type WatchLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchedAt?: SortOrder
    rewatch?: SortOrder
    tags?: SortOrder
    note?: SortOrder
    importId?: SortOrder
    importRowId?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchLogAvgOrderByAggregateInput = {
    movieId?: SortOrder
  }

  export type WatchLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchedAt?: SortOrder
    rewatch?: SortOrder
    tags?: SortOrder
    note?: SortOrder
    importId?: SortOrder
    importRowId?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchedAt?: SortOrder
    rewatch?: SortOrder
    tags?: SortOrder
    note?: SortOrder
    importId?: SortOrder
    importRowId?: SortOrder
    createdAt?: SortOrder
  }

  export type WatchLogSumOrderByAggregateInput = {
    movieId?: SortOrder
  }

  export type WatchLogNullableScalarRelationFilter = {
    is?: WatchLogWhereInput | null
    isNot?: WatchLogWhereInput | null
  }

  export type ReviewUserIdMovieIdWatchLogIdCompoundUniqueInput = {
    userId: string
    movieId: number
    watchLogId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchLogId?: SortOrder
    bodyRaw?: SortOrder
    bodyFormat?: SortOrder
    ratingHalf?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    movieId?: SortOrder
    ratingHalf?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchLogId?: SortOrder
    bodyRaw?: SortOrder
    bodyFormat?: SortOrder
    ratingHalf?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    movieId?: SortOrder
    watchLogId?: SortOrder
    bodyRaw?: SortOrder
    bodyFormat?: SortOrder
    ratingHalf?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    movieId?: SortOrder
    ratingHalf?: SortOrder
  }

  export type ReviewScalarRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type ReviewCommentCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewCommentMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewFavoriteReviewIdUserIdCompoundUniqueInput = {
    reviewId: string
    userId: string
  }

  export type ReviewFavoriteCountOrderByAggregateInput = {
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewFavoriteMaxOrderByAggregateInput = {
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type ReviewFavoriteMinOrderByAggregateInput = {
    reviewId?: SortOrder
    userId?: SortOrder
  }

  export type MovieListItemListRelationFilter = {
    every?: MovieListItemWhereInput
    some?: MovieListItemWhereInput
    none?: MovieListItemWhereInput
  }

  export type MovieListItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MovieListUserIdTitleCompoundUniqueInput = {
    userId: string
    title: string
  }

  export type MovieListCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    isRanked?: SortOrder
    isSystem?: SortOrder
    systemKey?: SortOrder
    isPublic?: SortOrder
    sourceListId?: SortOrder
    sourceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieListMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    isRanked?: SortOrder
    isSystem?: SortOrder
    systemKey?: SortOrder
    isPublic?: SortOrder
    sourceListId?: SortOrder
    sourceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieListMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    isRanked?: SortOrder
    isSystem?: SortOrder
    systemKey?: SortOrder
    isPublic?: SortOrder
    sourceListId?: SortOrder
    sourceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MovieListScalarRelationFilter = {
    is?: MovieListWhereInput
    isNot?: MovieListWhereInput
  }

  export type MovieListItemListIdPositionCompoundUniqueInput = {
    listId: string
    position: number
  }

  export type MovieListItemListIdMovieIdCompoundUniqueInput = {
    listId: string
    movieId: number
  }

  export type MovieListItemCountOrderByAggregateInput = {
    listId?: SortOrder
    movieId?: SortOrder
    position?: SortOrder
    note?: SortOrder
    addedAt?: SortOrder
  }

  export type MovieListItemAvgOrderByAggregateInput = {
    movieId?: SortOrder
    position?: SortOrder
  }

  export type MovieListItemMaxOrderByAggregateInput = {
    listId?: SortOrder
    movieId?: SortOrder
    position?: SortOrder
    note?: SortOrder
    addedAt?: SortOrder
  }

  export type MovieListItemMinOrderByAggregateInput = {
    listId?: SortOrder
    movieId?: SortOrder
    position?: SortOrder
    note?: SortOrder
    addedAt?: SortOrder
  }

  export type MovieListItemSumOrderByAggregateInput = {
    movieId?: SortOrder
    position?: SortOrder
  }

  export type ImportAuditRowListRelationFilter = {
    every?: ImportAuditRowWhereInput
    some?: ImportAuditRowWhereInput
    none?: ImportAuditRowWhereInput
  }

  export type ImportAuditRowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportRunCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportRunMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportRunMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportRunScalarRelationFilter = {
    is?: ImportRunWhereInput
    isNot?: ImportRunWhereInput
  }

  export type ImportAuditRowImportIdFileNameRowNumberCompoundUniqueInput = {
    importId: string
    fileName: string
    rowNumber: number
  }

  export type ImportAuditRowCountOrderByAggregateInput = {
    id?: SortOrder
    importId?: SortOrder
    fileName?: SortOrder
    rowNumber?: SortOrder
    title?: SortOrder
    year?: SortOrder
    letterboxdUrl?: SortOrder
    tmdbMovieId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    rawJson?: SortOrder
  }

  export type ImportAuditRowAvgOrderByAggregateInput = {
    rowNumber?: SortOrder
    year?: SortOrder
    tmdbMovieId?: SortOrder
  }

  export type ImportAuditRowMaxOrderByAggregateInput = {
    id?: SortOrder
    importId?: SortOrder
    fileName?: SortOrder
    rowNumber?: SortOrder
    title?: SortOrder
    year?: SortOrder
    letterboxdUrl?: SortOrder
    tmdbMovieId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    rawJson?: SortOrder
  }

  export type ImportAuditRowMinOrderByAggregateInput = {
    id?: SortOrder
    importId?: SortOrder
    fileName?: SortOrder
    rowNumber?: SortOrder
    title?: SortOrder
    year?: SortOrder
    letterboxdUrl?: SortOrder
    tmdbMovieId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    rawJson?: SortOrder
  }

  export type ImportAuditRowSumOrderByAggregateInput = {
    rowNumber?: SortOrder
    year?: SortOrder
    tmdbMovieId?: SortOrder
  }

  export type BallotUserIdEventYearCategoryCompoundUniqueInput = {
    userId: string
    eventYear: number
    category: string
  }

  export type BallotCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventYear?: SortOrder
    category?: SortOrder
    nomineeId?: SortOrder
    nomineeName?: SortOrder
    isWinner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BallotAvgOrderByAggregateInput = {
    eventYear?: SortOrder
  }

  export type BallotMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventYear?: SortOrder
    category?: SortOrder
    nomineeId?: SortOrder
    nomineeName?: SortOrder
    isWinner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BallotMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventYear?: SortOrder
    category?: SortOrder
    nomineeId?: SortOrder
    nomineeName?: SortOrder
    isWinner?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BallotSumOrderByAggregateInput = {
    eventYear?: SortOrder
  }

  export type AwardSeasonListRelationFilter = {
    every?: AwardSeasonWhereInput
    some?: AwardSeasonWhereInput
    none?: AwardSeasonWhereInput
  }

  export type AwardSeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AwardEventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
  }

  export type AwardEventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
  }

  export type AwardEventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
  }

  export type AwardEventScalarRelationFilter = {
    is?: AwardEventWhereInput
    isNot?: AwardEventWhereInput
  }

  export type AwardWinnerListRelationFilter = {
    every?: AwardWinnerWhereInput
    some?: AwardWinnerWhereInput
    none?: AwardWinnerWhereInput
  }

  export type AwardWinnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AwardSeasonEventIdYearCompoundUniqueInput = {
    eventId: string
    year: number
  }

  export type AwardSeasonEventIdSeasonCompoundUniqueInput = {
    eventId: string
    season: string
  }

  export type AwardSeasonCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    year?: SortOrder
    season?: SortOrder
    phase?: SortOrder
    date?: SortOrder
  }

  export type AwardSeasonAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type AwardSeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    year?: SortOrder
    season?: SortOrder
    phase?: SortOrder
    date?: SortOrder
  }

  export type AwardSeasonMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    year?: SortOrder
    season?: SortOrder
    phase?: SortOrder
    date?: SortOrder
  }

  export type AwardSeasonSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type MovieCountOrderByAggregateInput = {
    tmdbId?: SortOrder
    title?: SortOrder
    posterPath?: SortOrder
    backdropPath?: SortOrder
    eligibleDate?: SortOrder
    eligibilityYear?: SortOrder
    seasonKey?: SortOrder
  }

  export type MovieAvgOrderByAggregateInput = {
    tmdbId?: SortOrder
    eligibilityYear?: SortOrder
  }

  export type MovieMaxOrderByAggregateInput = {
    tmdbId?: SortOrder
    title?: SortOrder
    posterPath?: SortOrder
    backdropPath?: SortOrder
    eligibleDate?: SortOrder
    eligibilityYear?: SortOrder
    seasonKey?: SortOrder
  }

  export type MovieMinOrderByAggregateInput = {
    tmdbId?: SortOrder
    title?: SortOrder
    posterPath?: SortOrder
    backdropPath?: SortOrder
    eligibleDate?: SortOrder
    eligibilityYear?: SortOrder
    seasonKey?: SortOrder
  }

  export type MovieSumOrderByAggregateInput = {
    tmdbId?: SortOrder
    eligibilityYear?: SortOrder
  }

  export type AwardSeasonScalarRelationFilter = {
    is?: AwardSeasonWhereInput
    isNot?: AwardSeasonWhereInput
  }

  export type AwardWinnerCountOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    prizeName?: SortOrder
    movieId?: SortOrder
    movieTitle?: SortOrder
    posterPath?: SortOrder
    personName?: SortOrder
    personPath?: SortOrder
    isWinner?: SortOrder
    sourceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type AwardWinnerAvgOrderByAggregateInput = {
    movieId?: SortOrder
  }

  export type AwardWinnerMaxOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    prizeName?: SortOrder
    movieId?: SortOrder
    movieTitle?: SortOrder
    posterPath?: SortOrder
    personName?: SortOrder
    personPath?: SortOrder
    isWinner?: SortOrder
    sourceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type AwardWinnerMinOrderByAggregateInput = {
    id?: SortOrder
    seasonId?: SortOrder
    prizeName?: SortOrder
    movieId?: SortOrder
    movieTitle?: SortOrder
    posterPath?: SortOrder
    personName?: SortOrder
    personPath?: SortOrder
    isWinner?: SortOrder
    sourceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type AwardWinnerSumOrderByAggregateInput = {
    movieId?: SortOrder
  }

  export type StreamingSubscriptionUserIdProviderIdCompoundUniqueInput = {
    userId: string
    providerId: number
  }

  export type StreamingSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    logoPath?: SortOrder
    createdAt?: SortOrder
  }

  export type StreamingSubscriptionAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type StreamingSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    logoPath?: SortOrder
    createdAt?: SortOrder
  }

  export type StreamingSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    logoPath?: SortOrder
    createdAt?: SortOrder
  }

  export type StreamingSubscriptionSumOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type UserSettingsCountOrderByAggregateInput = {
    userId?: SortOrder
    providerMode?: SortOrder
    region?: SortOrder
    runtimeMin?: SortOrder
    runtimeMax?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsAvgOrderByAggregateInput = {
    runtimeMin?: SortOrder
    runtimeMax?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    providerMode?: SortOrder
    region?: SortOrder
    runtimeMin?: SortOrder
    runtimeMax?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    userId?: SortOrder
    providerMode?: SortOrder
    region?: SortOrder
    runtimeMin?: SortOrder
    runtimeMax?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsSumOrderByAggregateInput = {
    runtimeMin?: SortOrder
    runtimeMax?: SortOrder
  }

  export type OnboardingStateCountOrderByAggregateInput = {
    userId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    lastNudgedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingStateMaxOrderByAggregateInput = {
    userId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    lastNudgedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OnboardingStateMinOrderByAggregateInput = {
    userId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    lastNudgedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferredGenreUserIdGenreIdCompoundUniqueInput = {
    userId: string
    genreId: number
  }

  export type UserPreferredGenreCountOrderByAggregateInput = {
    userId?: SortOrder
    genreId?: SortOrder
  }

  export type UserPreferredGenreAvgOrderByAggregateInput = {
    genreId?: SortOrder
  }

  export type UserPreferredGenreMaxOrderByAggregateInput = {
    userId?: SortOrder
    genreId?: SortOrder
  }

  export type UserPreferredGenreMinOrderByAggregateInput = {
    userId?: SortOrder
    genreId?: SortOrder
  }

  export type UserPreferredGenreSumOrderByAggregateInput = {
    genreId?: SortOrder
  }

  export type UserTopTenUserIdTmdbIdCompoundUniqueInput = {
    userId: string
    tmdbId: number
  }

  export type UserTopTenUserIdPositionCompoundUniqueInput = {
    userId: string
    position: number
  }

  export type UserTopTenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tmdbId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTopTenAvgOrderByAggregateInput = {
    tmdbId?: SortOrder
    position?: SortOrder
  }

  export type UserTopTenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tmdbId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTopTenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tmdbId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTopTenSumOrderByAggregateInput = {
    tmdbId?: SortOrder
    position?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type MovieInteractionCreateNestedManyWithoutUserInput = {
    create?: XOR<MovieInteractionCreateWithoutUserInput, MovieInteractionUncheckedCreateWithoutUserInput> | MovieInteractionCreateWithoutUserInput[] | MovieInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MovieInteractionCreateOrConnectWithoutUserInput | MovieInteractionCreateOrConnectWithoutUserInput[]
    createMany?: MovieInteractionCreateManyUserInputEnvelope
    connect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
  }

  export type WatchLogCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchLogCreateWithoutUserInput, WatchLogUncheckedCreateWithoutUserInput> | WatchLogCreateWithoutUserInput[] | WatchLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutUserInput | WatchLogCreateOrConnectWithoutUserInput[]
    createMany?: WatchLogCreateManyUserInputEnvelope
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput> | ReviewCommentCreateWithoutUserInput[] | ReviewCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutUserInput | ReviewCommentCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCommentCreateManyUserInputEnvelope
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
  }

  export type ReviewFavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewFavoriteCreateWithoutUserInput, ReviewFavoriteUncheckedCreateWithoutUserInput> | ReviewFavoriteCreateWithoutUserInput[] | ReviewFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewFavoriteCreateOrConnectWithoutUserInput | ReviewFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewFavoriteCreateManyUserInputEnvelope
    connect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
  }

  export type MovieListCreateNestedManyWithoutUserInput = {
    create?: XOR<MovieListCreateWithoutUserInput, MovieListUncheckedCreateWithoutUserInput> | MovieListCreateWithoutUserInput[] | MovieListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MovieListCreateOrConnectWithoutUserInput | MovieListCreateOrConnectWithoutUserInput[]
    createMany?: MovieListCreateManyUserInputEnvelope
    connect?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
  }

  export type BallotCreateNestedManyWithoutUserInput = {
    create?: XOR<BallotCreateWithoutUserInput, BallotUncheckedCreateWithoutUserInput> | BallotCreateWithoutUserInput[] | BallotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BallotCreateOrConnectWithoutUserInput | BallotCreateOrConnectWithoutUserInput[]
    createMany?: BallotCreateManyUserInputEnvelope
    connect?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
  }

  export type StreamingSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<StreamingSubscriptionCreateWithoutUserInput, StreamingSubscriptionUncheckedCreateWithoutUserInput> | StreamingSubscriptionCreateWithoutUserInput[] | StreamingSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StreamingSubscriptionCreateOrConnectWithoutUserInput | StreamingSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: StreamingSubscriptionCreateManyUserInputEnvelope
    connect?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
  }

  export type ImportRunCreateNestedManyWithoutUserInput = {
    create?: XOR<ImportRunCreateWithoutUserInput, ImportRunUncheckedCreateWithoutUserInput> | ImportRunCreateWithoutUserInput[] | ImportRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImportRunCreateOrConnectWithoutUserInput | ImportRunCreateOrConnectWithoutUserInput[]
    createMany?: ImportRunCreateManyUserInputEnvelope
    connect?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
  }

  export type UserTopTenCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTopTenCreateWithoutUserInput, UserTopTenUncheckedCreateWithoutUserInput> | UserTopTenCreateWithoutUserInput[] | UserTopTenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTopTenCreateOrConnectWithoutUserInput | UserTopTenCreateOrConnectWithoutUserInput[]
    createMany?: UserTopTenCreateManyUserInputEnvelope
    connect?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type OnboardingStateCreateNestedOneWithoutUserInput = {
    create?: XOR<OnboardingStateCreateWithoutUserInput, OnboardingStateUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingStateCreateOrConnectWithoutUserInput
    connect?: OnboardingStateWhereUniqueInput
  }

  export type UserPreferredGenreCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPreferredGenreCreateWithoutUserInput, UserPreferredGenreUncheckedCreateWithoutUserInput> | UserPreferredGenreCreateWithoutUserInput[] | UserPreferredGenreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferredGenreCreateOrConnectWithoutUserInput | UserPreferredGenreCreateOrConnectWithoutUserInput[]
    createMany?: UserPreferredGenreCreateManyUserInputEnvelope
    connect?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type MovieInteractionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MovieInteractionCreateWithoutUserInput, MovieInteractionUncheckedCreateWithoutUserInput> | MovieInteractionCreateWithoutUserInput[] | MovieInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MovieInteractionCreateOrConnectWithoutUserInput | MovieInteractionCreateOrConnectWithoutUserInput[]
    createMany?: MovieInteractionCreateManyUserInputEnvelope
    connect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
  }

  export type WatchLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WatchLogCreateWithoutUserInput, WatchLogUncheckedCreateWithoutUserInput> | WatchLogCreateWithoutUserInput[] | WatchLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutUserInput | WatchLogCreateOrConnectWithoutUserInput[]
    createMany?: WatchLogCreateManyUserInputEnvelope
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput> | ReviewCommentCreateWithoutUserInput[] | ReviewCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutUserInput | ReviewCommentCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCommentCreateManyUserInputEnvelope
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
  }

  export type ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewFavoriteCreateWithoutUserInput, ReviewFavoriteUncheckedCreateWithoutUserInput> | ReviewFavoriteCreateWithoutUserInput[] | ReviewFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewFavoriteCreateOrConnectWithoutUserInput | ReviewFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewFavoriteCreateManyUserInputEnvelope
    connect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
  }

  export type MovieListUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MovieListCreateWithoutUserInput, MovieListUncheckedCreateWithoutUserInput> | MovieListCreateWithoutUserInput[] | MovieListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MovieListCreateOrConnectWithoutUserInput | MovieListCreateOrConnectWithoutUserInput[]
    createMany?: MovieListCreateManyUserInputEnvelope
    connect?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
  }

  export type BallotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BallotCreateWithoutUserInput, BallotUncheckedCreateWithoutUserInput> | BallotCreateWithoutUserInput[] | BallotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BallotCreateOrConnectWithoutUserInput | BallotCreateOrConnectWithoutUserInput[]
    createMany?: BallotCreateManyUserInputEnvelope
    connect?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
  }

  export type StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StreamingSubscriptionCreateWithoutUserInput, StreamingSubscriptionUncheckedCreateWithoutUserInput> | StreamingSubscriptionCreateWithoutUserInput[] | StreamingSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StreamingSubscriptionCreateOrConnectWithoutUserInput | StreamingSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: StreamingSubscriptionCreateManyUserInputEnvelope
    connect?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
  }

  export type ImportRunUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ImportRunCreateWithoutUserInput, ImportRunUncheckedCreateWithoutUserInput> | ImportRunCreateWithoutUserInput[] | ImportRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImportRunCreateOrConnectWithoutUserInput | ImportRunCreateOrConnectWithoutUserInput[]
    createMany?: ImportRunCreateManyUserInputEnvelope
    connect?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
  }

  export type UserTopTenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTopTenCreateWithoutUserInput, UserTopTenUncheckedCreateWithoutUserInput> | UserTopTenCreateWithoutUserInput[] | UserTopTenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTopTenCreateOrConnectWithoutUserInput | UserTopTenCreateOrConnectWithoutUserInput[]
    createMany?: UserTopTenCreateManyUserInputEnvelope
    connect?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type OnboardingStateUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<OnboardingStateCreateWithoutUserInput, OnboardingStateUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingStateCreateOrConnectWithoutUserInput
    connect?: OnboardingStateWhereUniqueInput
  }

  export type UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPreferredGenreCreateWithoutUserInput, UserPreferredGenreUncheckedCreateWithoutUserInput> | UserPreferredGenreCreateWithoutUserInput[] | UserPreferredGenreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferredGenreCreateOrConnectWithoutUserInput | UserPreferredGenreCreateOrConnectWithoutUserInput[]
    createMany?: UserPreferredGenreCreateManyUserInputEnvelope
    connect?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type MovieInteractionUpdateManyWithoutUserNestedInput = {
    create?: XOR<MovieInteractionCreateWithoutUserInput, MovieInteractionUncheckedCreateWithoutUserInput> | MovieInteractionCreateWithoutUserInput[] | MovieInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MovieInteractionCreateOrConnectWithoutUserInput | MovieInteractionCreateOrConnectWithoutUserInput[]
    upsert?: MovieInteractionUpsertWithWhereUniqueWithoutUserInput | MovieInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MovieInteractionCreateManyUserInputEnvelope
    set?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    disconnect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    delete?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    connect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    update?: MovieInteractionUpdateWithWhereUniqueWithoutUserInput | MovieInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MovieInteractionUpdateManyWithWhereWithoutUserInput | MovieInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MovieInteractionScalarWhereInput | MovieInteractionScalarWhereInput[]
  }

  export type WatchLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchLogCreateWithoutUserInput, WatchLogUncheckedCreateWithoutUserInput> | WatchLogCreateWithoutUserInput[] | WatchLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutUserInput | WatchLogCreateOrConnectWithoutUserInput[]
    upsert?: WatchLogUpsertWithWhereUniqueWithoutUserInput | WatchLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchLogCreateManyUserInputEnvelope
    set?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    disconnect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    delete?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    update?: WatchLogUpdateWithWhereUniqueWithoutUserInput | WatchLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchLogUpdateManyWithWhereWithoutUserInput | WatchLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchLogScalarWhereInput | WatchLogScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput> | ReviewCommentCreateWithoutUserInput[] | ReviewCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutUserInput | ReviewCommentCreateOrConnectWithoutUserInput[]
    upsert?: ReviewCommentUpsertWithWhereUniqueWithoutUserInput | ReviewCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCommentCreateManyUserInputEnvelope
    set?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    disconnect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    delete?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    update?: ReviewCommentUpdateWithWhereUniqueWithoutUserInput | ReviewCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewCommentUpdateManyWithWhereWithoutUserInput | ReviewCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
  }

  export type ReviewFavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewFavoriteCreateWithoutUserInput, ReviewFavoriteUncheckedCreateWithoutUserInput> | ReviewFavoriteCreateWithoutUserInput[] | ReviewFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewFavoriteCreateOrConnectWithoutUserInput | ReviewFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewFavoriteUpsertWithWhereUniqueWithoutUserInput | ReviewFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewFavoriteCreateManyUserInputEnvelope
    set?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    disconnect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    delete?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    connect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    update?: ReviewFavoriteUpdateWithWhereUniqueWithoutUserInput | ReviewFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewFavoriteUpdateManyWithWhereWithoutUserInput | ReviewFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewFavoriteScalarWhereInput | ReviewFavoriteScalarWhereInput[]
  }

  export type MovieListUpdateManyWithoutUserNestedInput = {
    create?: XOR<MovieListCreateWithoutUserInput, MovieListUncheckedCreateWithoutUserInput> | MovieListCreateWithoutUserInput[] | MovieListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MovieListCreateOrConnectWithoutUserInput | MovieListCreateOrConnectWithoutUserInput[]
    upsert?: MovieListUpsertWithWhereUniqueWithoutUserInput | MovieListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MovieListCreateManyUserInputEnvelope
    set?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
    disconnect?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
    delete?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
    connect?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
    update?: MovieListUpdateWithWhereUniqueWithoutUserInput | MovieListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MovieListUpdateManyWithWhereWithoutUserInput | MovieListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MovieListScalarWhereInput | MovieListScalarWhereInput[]
  }

  export type BallotUpdateManyWithoutUserNestedInput = {
    create?: XOR<BallotCreateWithoutUserInput, BallotUncheckedCreateWithoutUserInput> | BallotCreateWithoutUserInput[] | BallotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BallotCreateOrConnectWithoutUserInput | BallotCreateOrConnectWithoutUserInput[]
    upsert?: BallotUpsertWithWhereUniqueWithoutUserInput | BallotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BallotCreateManyUserInputEnvelope
    set?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
    disconnect?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
    delete?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
    connect?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
    update?: BallotUpdateWithWhereUniqueWithoutUserInput | BallotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BallotUpdateManyWithWhereWithoutUserInput | BallotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BallotScalarWhereInput | BallotScalarWhereInput[]
  }

  export type StreamingSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StreamingSubscriptionCreateWithoutUserInput, StreamingSubscriptionUncheckedCreateWithoutUserInput> | StreamingSubscriptionCreateWithoutUserInput[] | StreamingSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StreamingSubscriptionCreateOrConnectWithoutUserInput | StreamingSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: StreamingSubscriptionUpsertWithWhereUniqueWithoutUserInput | StreamingSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StreamingSubscriptionCreateManyUserInputEnvelope
    set?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
    disconnect?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
    delete?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
    connect?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
    update?: StreamingSubscriptionUpdateWithWhereUniqueWithoutUserInput | StreamingSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StreamingSubscriptionUpdateManyWithWhereWithoutUserInput | StreamingSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StreamingSubscriptionScalarWhereInput | StreamingSubscriptionScalarWhereInput[]
  }

  export type ImportRunUpdateManyWithoutUserNestedInput = {
    create?: XOR<ImportRunCreateWithoutUserInput, ImportRunUncheckedCreateWithoutUserInput> | ImportRunCreateWithoutUserInput[] | ImportRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImportRunCreateOrConnectWithoutUserInput | ImportRunCreateOrConnectWithoutUserInput[]
    upsert?: ImportRunUpsertWithWhereUniqueWithoutUserInput | ImportRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ImportRunCreateManyUserInputEnvelope
    set?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
    disconnect?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
    delete?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
    connect?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
    update?: ImportRunUpdateWithWhereUniqueWithoutUserInput | ImportRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ImportRunUpdateManyWithWhereWithoutUserInput | ImportRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ImportRunScalarWhereInput | ImportRunScalarWhereInput[]
  }

  export type UserTopTenUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTopTenCreateWithoutUserInput, UserTopTenUncheckedCreateWithoutUserInput> | UserTopTenCreateWithoutUserInput[] | UserTopTenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTopTenCreateOrConnectWithoutUserInput | UserTopTenCreateOrConnectWithoutUserInput[]
    upsert?: UserTopTenUpsertWithWhereUniqueWithoutUserInput | UserTopTenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTopTenCreateManyUserInputEnvelope
    set?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
    disconnect?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
    delete?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
    connect?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
    update?: UserTopTenUpdateWithWhereUniqueWithoutUserInput | UserTopTenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTopTenUpdateManyWithWhereWithoutUserInput | UserTopTenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTopTenScalarWhereInput | UserTopTenScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingStateUpdateOneWithoutUserNestedInput = {
    create?: XOR<OnboardingStateCreateWithoutUserInput, OnboardingStateUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingStateCreateOrConnectWithoutUserInput
    upsert?: OnboardingStateUpsertWithoutUserInput
    disconnect?: OnboardingStateWhereInput | boolean
    delete?: OnboardingStateWhereInput | boolean
    connect?: OnboardingStateWhereUniqueInput
    update?: XOR<XOR<OnboardingStateUpdateToOneWithWhereWithoutUserInput, OnboardingStateUpdateWithoutUserInput>, OnboardingStateUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferredGenreUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPreferredGenreCreateWithoutUserInput, UserPreferredGenreUncheckedCreateWithoutUserInput> | UserPreferredGenreCreateWithoutUserInput[] | UserPreferredGenreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferredGenreCreateOrConnectWithoutUserInput | UserPreferredGenreCreateOrConnectWithoutUserInput[]
    upsert?: UserPreferredGenreUpsertWithWhereUniqueWithoutUserInput | UserPreferredGenreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPreferredGenreCreateManyUserInputEnvelope
    set?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
    disconnect?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
    delete?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
    connect?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
    update?: UserPreferredGenreUpdateWithWhereUniqueWithoutUserInput | UserPreferredGenreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPreferredGenreUpdateManyWithWhereWithoutUserInput | UserPreferredGenreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPreferredGenreScalarWhereInput | UserPreferredGenreScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type MovieInteractionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MovieInteractionCreateWithoutUserInput, MovieInteractionUncheckedCreateWithoutUserInput> | MovieInteractionCreateWithoutUserInput[] | MovieInteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MovieInteractionCreateOrConnectWithoutUserInput | MovieInteractionCreateOrConnectWithoutUserInput[]
    upsert?: MovieInteractionUpsertWithWhereUniqueWithoutUserInput | MovieInteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MovieInteractionCreateManyUserInputEnvelope
    set?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    disconnect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    delete?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    connect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    update?: MovieInteractionUpdateWithWhereUniqueWithoutUserInput | MovieInteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MovieInteractionUpdateManyWithWhereWithoutUserInput | MovieInteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MovieInteractionScalarWhereInput | MovieInteractionScalarWhereInput[]
  }

  export type WatchLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WatchLogCreateWithoutUserInput, WatchLogUncheckedCreateWithoutUserInput> | WatchLogCreateWithoutUserInput[] | WatchLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutUserInput | WatchLogCreateOrConnectWithoutUserInput[]
    upsert?: WatchLogUpsertWithWhereUniqueWithoutUserInput | WatchLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WatchLogCreateManyUserInputEnvelope
    set?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    disconnect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    delete?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    update?: WatchLogUpdateWithWhereUniqueWithoutUserInput | WatchLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WatchLogUpdateManyWithWhereWithoutUserInput | WatchLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WatchLogScalarWhereInput | WatchLogScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput> | ReviewCommentCreateWithoutUserInput[] | ReviewCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutUserInput | ReviewCommentCreateOrConnectWithoutUserInput[]
    upsert?: ReviewCommentUpsertWithWhereUniqueWithoutUserInput | ReviewCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCommentCreateManyUserInputEnvelope
    set?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    disconnect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    delete?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    update?: ReviewCommentUpdateWithWhereUniqueWithoutUserInput | ReviewCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewCommentUpdateManyWithWhereWithoutUserInput | ReviewCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
  }

  export type ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewFavoriteCreateWithoutUserInput, ReviewFavoriteUncheckedCreateWithoutUserInput> | ReviewFavoriteCreateWithoutUserInput[] | ReviewFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewFavoriteCreateOrConnectWithoutUserInput | ReviewFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewFavoriteUpsertWithWhereUniqueWithoutUserInput | ReviewFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewFavoriteCreateManyUserInputEnvelope
    set?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    disconnect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    delete?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    connect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    update?: ReviewFavoriteUpdateWithWhereUniqueWithoutUserInput | ReviewFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewFavoriteUpdateManyWithWhereWithoutUserInput | ReviewFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewFavoriteScalarWhereInput | ReviewFavoriteScalarWhereInput[]
  }

  export type MovieListUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MovieListCreateWithoutUserInput, MovieListUncheckedCreateWithoutUserInput> | MovieListCreateWithoutUserInput[] | MovieListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MovieListCreateOrConnectWithoutUserInput | MovieListCreateOrConnectWithoutUserInput[]
    upsert?: MovieListUpsertWithWhereUniqueWithoutUserInput | MovieListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MovieListCreateManyUserInputEnvelope
    set?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
    disconnect?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
    delete?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
    connect?: MovieListWhereUniqueInput | MovieListWhereUniqueInput[]
    update?: MovieListUpdateWithWhereUniqueWithoutUserInput | MovieListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MovieListUpdateManyWithWhereWithoutUserInput | MovieListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MovieListScalarWhereInput | MovieListScalarWhereInput[]
  }

  export type BallotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BallotCreateWithoutUserInput, BallotUncheckedCreateWithoutUserInput> | BallotCreateWithoutUserInput[] | BallotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BallotCreateOrConnectWithoutUserInput | BallotCreateOrConnectWithoutUserInput[]
    upsert?: BallotUpsertWithWhereUniqueWithoutUserInput | BallotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BallotCreateManyUserInputEnvelope
    set?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
    disconnect?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
    delete?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
    connect?: BallotWhereUniqueInput | BallotWhereUniqueInput[]
    update?: BallotUpdateWithWhereUniqueWithoutUserInput | BallotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BallotUpdateManyWithWhereWithoutUserInput | BallotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BallotScalarWhereInput | BallotScalarWhereInput[]
  }

  export type StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StreamingSubscriptionCreateWithoutUserInput, StreamingSubscriptionUncheckedCreateWithoutUserInput> | StreamingSubscriptionCreateWithoutUserInput[] | StreamingSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StreamingSubscriptionCreateOrConnectWithoutUserInput | StreamingSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: StreamingSubscriptionUpsertWithWhereUniqueWithoutUserInput | StreamingSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StreamingSubscriptionCreateManyUserInputEnvelope
    set?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
    disconnect?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
    delete?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
    connect?: StreamingSubscriptionWhereUniqueInput | StreamingSubscriptionWhereUniqueInput[]
    update?: StreamingSubscriptionUpdateWithWhereUniqueWithoutUserInput | StreamingSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StreamingSubscriptionUpdateManyWithWhereWithoutUserInput | StreamingSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StreamingSubscriptionScalarWhereInput | StreamingSubscriptionScalarWhereInput[]
  }

  export type ImportRunUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ImportRunCreateWithoutUserInput, ImportRunUncheckedCreateWithoutUserInput> | ImportRunCreateWithoutUserInput[] | ImportRunUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ImportRunCreateOrConnectWithoutUserInput | ImportRunCreateOrConnectWithoutUserInput[]
    upsert?: ImportRunUpsertWithWhereUniqueWithoutUserInput | ImportRunUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ImportRunCreateManyUserInputEnvelope
    set?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
    disconnect?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
    delete?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
    connect?: ImportRunWhereUniqueInput | ImportRunWhereUniqueInput[]
    update?: ImportRunUpdateWithWhereUniqueWithoutUserInput | ImportRunUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ImportRunUpdateManyWithWhereWithoutUserInput | ImportRunUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ImportRunScalarWhereInput | ImportRunScalarWhereInput[]
  }

  export type UserTopTenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTopTenCreateWithoutUserInput, UserTopTenUncheckedCreateWithoutUserInput> | UserTopTenCreateWithoutUserInput[] | UserTopTenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTopTenCreateOrConnectWithoutUserInput | UserTopTenCreateOrConnectWithoutUserInput[]
    upsert?: UserTopTenUpsertWithWhereUniqueWithoutUserInput | UserTopTenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTopTenCreateManyUserInputEnvelope
    set?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
    disconnect?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
    delete?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
    connect?: UserTopTenWhereUniqueInput | UserTopTenWhereUniqueInput[]
    update?: UserTopTenUpdateWithWhereUniqueWithoutUserInput | UserTopTenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTopTenUpdateManyWithWhereWithoutUserInput | UserTopTenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTopTenScalarWhereInput | UserTopTenScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingStateUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<OnboardingStateCreateWithoutUserInput, OnboardingStateUncheckedCreateWithoutUserInput>
    connectOrCreate?: OnboardingStateCreateOrConnectWithoutUserInput
    upsert?: OnboardingStateUpsertWithoutUserInput
    disconnect?: OnboardingStateWhereInput | boolean
    delete?: OnboardingStateWhereInput | boolean
    connect?: OnboardingStateWhereUniqueInput
    update?: XOR<XOR<OnboardingStateUpdateToOneWithWhereWithoutUserInput, OnboardingStateUpdateWithoutUserInput>, OnboardingStateUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPreferredGenreCreateWithoutUserInput, UserPreferredGenreUncheckedCreateWithoutUserInput> | UserPreferredGenreCreateWithoutUserInput[] | UserPreferredGenreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPreferredGenreCreateOrConnectWithoutUserInput | UserPreferredGenreCreateOrConnectWithoutUserInput[]
    upsert?: UserPreferredGenreUpsertWithWhereUniqueWithoutUserInput | UserPreferredGenreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPreferredGenreCreateManyUserInputEnvelope
    set?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
    disconnect?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
    delete?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
    connect?: UserPreferredGenreWhereUniqueInput | UserPreferredGenreWhereUniqueInput[]
    update?: UserPreferredGenreUpdateWithWhereUniqueWithoutUserInput | UserPreferredGenreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPreferredGenreUpdateManyWithWhereWithoutUserInput | UserPreferredGenreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPreferredGenreScalarWhereInput | UserPreferredGenreScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInteractionsInput
    connect?: UserWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<MovieCreateWithoutInteractionsInput, MovieUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutInteractionsInput
    connect?: MovieWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInteractionsInput
    upsert?: UserUpsertWithoutInteractionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInteractionsInput, UserUpdateWithoutInteractionsInput>, UserUncheckedUpdateWithoutInteractionsInput>
  }

  export type MovieUpdateOneWithoutInteractionsNestedInput = {
    create?: XOR<MovieCreateWithoutInteractionsInput, MovieUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutInteractionsInput
    upsert?: MovieUpsertWithoutInteractionsInput
    disconnect?: MovieWhereInput | boolean
    delete?: MovieWhereInput | boolean
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutInteractionsInput, MovieUpdateWithoutInteractionsInput>, MovieUncheckedUpdateWithoutInteractionsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutWatchLogsInput = {
    create?: XOR<UserCreateWithoutWatchLogsInput, UserUncheckedCreateWithoutWatchLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ImportRunCreateNestedOneWithoutWatchLogsInput = {
    create?: XOR<ImportRunCreateWithoutWatchLogsInput, ImportRunUncheckedCreateWithoutWatchLogsInput>
    connectOrCreate?: ImportRunCreateOrConnectWithoutWatchLogsInput
    connect?: ImportRunWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutWatchLogsInput = {
    create?: XOR<MovieCreateWithoutWatchLogsInput, MovieUncheckedCreateWithoutWatchLogsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutWatchLogsInput
    connect?: MovieWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutWatchLogInput = {
    create?: XOR<ReviewCreateWithoutWatchLogInput, ReviewUncheckedCreateWithoutWatchLogInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutWatchLogInput
    connect?: ReviewWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedOneWithoutWatchLogInput = {
    create?: XOR<ReviewCreateWithoutWatchLogInput, ReviewUncheckedCreateWithoutWatchLogInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutWatchLogInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWatchLogsNestedInput = {
    create?: XOR<UserCreateWithoutWatchLogsInput, UserUncheckedCreateWithoutWatchLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchLogsInput
    upsert?: UserUpsertWithoutWatchLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWatchLogsInput, UserUpdateWithoutWatchLogsInput>, UserUncheckedUpdateWithoutWatchLogsInput>
  }

  export type ImportRunUpdateOneWithoutWatchLogsNestedInput = {
    create?: XOR<ImportRunCreateWithoutWatchLogsInput, ImportRunUncheckedCreateWithoutWatchLogsInput>
    connectOrCreate?: ImportRunCreateOrConnectWithoutWatchLogsInput
    upsert?: ImportRunUpsertWithoutWatchLogsInput
    disconnect?: ImportRunWhereInput | boolean
    delete?: ImportRunWhereInput | boolean
    connect?: ImportRunWhereUniqueInput
    update?: XOR<XOR<ImportRunUpdateToOneWithWhereWithoutWatchLogsInput, ImportRunUpdateWithoutWatchLogsInput>, ImportRunUncheckedUpdateWithoutWatchLogsInput>
  }

  export type MovieUpdateOneRequiredWithoutWatchLogsNestedInput = {
    create?: XOR<MovieCreateWithoutWatchLogsInput, MovieUncheckedCreateWithoutWatchLogsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutWatchLogsInput
    upsert?: MovieUpsertWithoutWatchLogsInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutWatchLogsInput, MovieUpdateWithoutWatchLogsInput>, MovieUncheckedUpdateWithoutWatchLogsInput>
  }

  export type ReviewUpdateOneWithoutWatchLogNestedInput = {
    create?: XOR<ReviewCreateWithoutWatchLogInput, ReviewUncheckedCreateWithoutWatchLogInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutWatchLogInput
    upsert?: ReviewUpsertWithoutWatchLogInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutWatchLogInput, ReviewUpdateWithoutWatchLogInput>, ReviewUncheckedUpdateWithoutWatchLogInput>
  }

  export type ReviewUncheckedUpdateOneWithoutWatchLogNestedInput = {
    create?: XOR<ReviewCreateWithoutWatchLogInput, ReviewUncheckedCreateWithoutWatchLogInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutWatchLogInput
    upsert?: ReviewUpsertWithoutWatchLogInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutWatchLogInput, ReviewUpdateWithoutWatchLogInput>, ReviewUncheckedUpdateWithoutWatchLogInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type WatchLogCreateNestedOneWithoutReviewInput = {
    create?: XOR<WatchLogCreateWithoutReviewInput, WatchLogUncheckedCreateWithoutReviewInput>
    connectOrCreate?: WatchLogCreateOrConnectWithoutReviewInput
    connect?: WatchLogWhereUniqueInput
  }

  export type ReviewCommentCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput> | ReviewCommentCreateWithoutReviewInput[] | ReviewCommentUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutReviewInput | ReviewCommentCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewCommentCreateManyReviewInputEnvelope
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
  }

  export type ReviewFavoriteCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewFavoriteCreateWithoutReviewInput, ReviewFavoriteUncheckedCreateWithoutReviewInput> | ReviewFavoriteCreateWithoutReviewInput[] | ReviewFavoriteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewFavoriteCreateOrConnectWithoutReviewInput | ReviewFavoriteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewFavoriteCreateManyReviewInputEnvelope
    connect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
  }

  export type ReviewCommentUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput> | ReviewCommentCreateWithoutReviewInput[] | ReviewCommentUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutReviewInput | ReviewCommentCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewCommentCreateManyReviewInputEnvelope
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
  }

  export type ReviewFavoriteUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewFavoriteCreateWithoutReviewInput, ReviewFavoriteUncheckedCreateWithoutReviewInput> | ReviewFavoriteCreateWithoutReviewInput[] | ReviewFavoriteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewFavoriteCreateOrConnectWithoutReviewInput | ReviewFavoriteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewFavoriteCreateManyReviewInputEnvelope
    connect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type WatchLogUpdateOneWithoutReviewNestedInput = {
    create?: XOR<WatchLogCreateWithoutReviewInput, WatchLogUncheckedCreateWithoutReviewInput>
    connectOrCreate?: WatchLogCreateOrConnectWithoutReviewInput
    upsert?: WatchLogUpsertWithoutReviewInput
    disconnect?: WatchLogWhereInput | boolean
    delete?: WatchLogWhereInput | boolean
    connect?: WatchLogWhereUniqueInput
    update?: XOR<XOR<WatchLogUpdateToOneWithWhereWithoutReviewInput, WatchLogUpdateWithoutReviewInput>, WatchLogUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewCommentUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput> | ReviewCommentCreateWithoutReviewInput[] | ReviewCommentUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutReviewInput | ReviewCommentCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewCommentUpsertWithWhereUniqueWithoutReviewInput | ReviewCommentUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewCommentCreateManyReviewInputEnvelope
    set?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    disconnect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    delete?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    update?: ReviewCommentUpdateWithWhereUniqueWithoutReviewInput | ReviewCommentUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewCommentUpdateManyWithWhereWithoutReviewInput | ReviewCommentUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
  }

  export type ReviewFavoriteUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewFavoriteCreateWithoutReviewInput, ReviewFavoriteUncheckedCreateWithoutReviewInput> | ReviewFavoriteCreateWithoutReviewInput[] | ReviewFavoriteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewFavoriteCreateOrConnectWithoutReviewInput | ReviewFavoriteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewFavoriteUpsertWithWhereUniqueWithoutReviewInput | ReviewFavoriteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewFavoriteCreateManyReviewInputEnvelope
    set?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    disconnect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    delete?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    connect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    update?: ReviewFavoriteUpdateWithWhereUniqueWithoutReviewInput | ReviewFavoriteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewFavoriteUpdateManyWithWhereWithoutReviewInput | ReviewFavoriteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewFavoriteScalarWhereInput | ReviewFavoriteScalarWhereInput[]
  }

  export type ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput> | ReviewCommentCreateWithoutReviewInput[] | ReviewCommentUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewCommentCreateOrConnectWithoutReviewInput | ReviewCommentCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewCommentUpsertWithWhereUniqueWithoutReviewInput | ReviewCommentUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewCommentCreateManyReviewInputEnvelope
    set?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    disconnect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    delete?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    connect?: ReviewCommentWhereUniqueInput | ReviewCommentWhereUniqueInput[]
    update?: ReviewCommentUpdateWithWhereUniqueWithoutReviewInput | ReviewCommentUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewCommentUpdateManyWithWhereWithoutReviewInput | ReviewCommentUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
  }

  export type ReviewFavoriteUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewFavoriteCreateWithoutReviewInput, ReviewFavoriteUncheckedCreateWithoutReviewInput> | ReviewFavoriteCreateWithoutReviewInput[] | ReviewFavoriteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewFavoriteCreateOrConnectWithoutReviewInput | ReviewFavoriteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewFavoriteUpsertWithWhereUniqueWithoutReviewInput | ReviewFavoriteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewFavoriteCreateManyReviewInputEnvelope
    set?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    disconnect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    delete?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    connect?: ReviewFavoriteWhereUniqueInput | ReviewFavoriteWhereUniqueInput[]
    update?: ReviewFavoriteUpdateWithWhereUniqueWithoutReviewInput | ReviewFavoriteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewFavoriteUpdateManyWithWhereWithoutReviewInput | ReviewFavoriteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewFavoriteScalarWhereInput | ReviewFavoriteScalarWhereInput[]
  }

  export type ReviewCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ReviewCreateWithoutCommentsInput, ReviewUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutCommentsInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewCommentsInput = {
    create?: XOR<UserCreateWithoutReviewCommentsInput, UserUncheckedCreateWithoutReviewCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ReviewCreateWithoutCommentsInput, ReviewUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutCommentsInput
    upsert?: ReviewUpsertWithoutCommentsInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutCommentsInput, ReviewUpdateWithoutCommentsInput>, ReviewUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewCommentsNestedInput = {
    create?: XOR<UserCreateWithoutReviewCommentsInput, UserUncheckedCreateWithoutReviewCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewCommentsInput
    upsert?: UserUpsertWithoutReviewCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewCommentsInput, UserUpdateWithoutReviewCommentsInput>, UserUncheckedUpdateWithoutReviewCommentsInput>
  }

  export type ReviewCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ReviewCreateWithoutFavoritesInput, ReviewUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutFavoritesInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewFavoritesInput = {
    create?: XOR<UserCreateWithoutReviewFavoritesInput, UserUncheckedCreateWithoutReviewFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ReviewCreateWithoutFavoritesInput, ReviewUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutFavoritesInput
    upsert?: ReviewUpsertWithoutFavoritesInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutFavoritesInput, ReviewUpdateWithoutFavoritesInput>, ReviewUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateOneRequiredWithoutReviewFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutReviewFavoritesInput, UserUncheckedCreateWithoutReviewFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewFavoritesInput
    upsert?: UserUpsertWithoutReviewFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewFavoritesInput, UserUpdateWithoutReviewFavoritesInput>, UserUncheckedUpdateWithoutReviewFavoritesInput>
  }

  export type UserCreateNestedOneWithoutMovieListsInput = {
    create?: XOR<UserCreateWithoutMovieListsInput, UserUncheckedCreateWithoutMovieListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMovieListsInput
    connect?: UserWhereUniqueInput
  }

  export type MovieListItemCreateNestedManyWithoutListInput = {
    create?: XOR<MovieListItemCreateWithoutListInput, MovieListItemUncheckedCreateWithoutListInput> | MovieListItemCreateWithoutListInput[] | MovieListItemUncheckedCreateWithoutListInput[]
    connectOrCreate?: MovieListItemCreateOrConnectWithoutListInput | MovieListItemCreateOrConnectWithoutListInput[]
    createMany?: MovieListItemCreateManyListInputEnvelope
    connect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
  }

  export type MovieListItemUncheckedCreateNestedManyWithoutListInput = {
    create?: XOR<MovieListItemCreateWithoutListInput, MovieListItemUncheckedCreateWithoutListInput> | MovieListItemCreateWithoutListInput[] | MovieListItemUncheckedCreateWithoutListInput[]
    connectOrCreate?: MovieListItemCreateOrConnectWithoutListInput | MovieListItemCreateOrConnectWithoutListInput[]
    createMany?: MovieListItemCreateManyListInputEnvelope
    connect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMovieListsNestedInput = {
    create?: XOR<UserCreateWithoutMovieListsInput, UserUncheckedCreateWithoutMovieListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMovieListsInput
    upsert?: UserUpsertWithoutMovieListsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMovieListsInput, UserUpdateWithoutMovieListsInput>, UserUncheckedUpdateWithoutMovieListsInput>
  }

  export type MovieListItemUpdateManyWithoutListNestedInput = {
    create?: XOR<MovieListItemCreateWithoutListInput, MovieListItemUncheckedCreateWithoutListInput> | MovieListItemCreateWithoutListInput[] | MovieListItemUncheckedCreateWithoutListInput[]
    connectOrCreate?: MovieListItemCreateOrConnectWithoutListInput | MovieListItemCreateOrConnectWithoutListInput[]
    upsert?: MovieListItemUpsertWithWhereUniqueWithoutListInput | MovieListItemUpsertWithWhereUniqueWithoutListInput[]
    createMany?: MovieListItemCreateManyListInputEnvelope
    set?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    disconnect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    delete?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    connect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    update?: MovieListItemUpdateWithWhereUniqueWithoutListInput | MovieListItemUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: MovieListItemUpdateManyWithWhereWithoutListInput | MovieListItemUpdateManyWithWhereWithoutListInput[]
    deleteMany?: MovieListItemScalarWhereInput | MovieListItemScalarWhereInput[]
  }

  export type MovieListItemUncheckedUpdateManyWithoutListNestedInput = {
    create?: XOR<MovieListItemCreateWithoutListInput, MovieListItemUncheckedCreateWithoutListInput> | MovieListItemCreateWithoutListInput[] | MovieListItemUncheckedCreateWithoutListInput[]
    connectOrCreate?: MovieListItemCreateOrConnectWithoutListInput | MovieListItemCreateOrConnectWithoutListInput[]
    upsert?: MovieListItemUpsertWithWhereUniqueWithoutListInput | MovieListItemUpsertWithWhereUniqueWithoutListInput[]
    createMany?: MovieListItemCreateManyListInputEnvelope
    set?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    disconnect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    delete?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    connect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    update?: MovieListItemUpdateWithWhereUniqueWithoutListInput | MovieListItemUpdateWithWhereUniqueWithoutListInput[]
    updateMany?: MovieListItemUpdateManyWithWhereWithoutListInput | MovieListItemUpdateManyWithWhereWithoutListInput[]
    deleteMany?: MovieListItemScalarWhereInput | MovieListItemScalarWhereInput[]
  }

  export type MovieListCreateNestedOneWithoutItemsInput = {
    create?: XOR<MovieListCreateWithoutItemsInput, MovieListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MovieListCreateOrConnectWithoutItemsInput
    connect?: MovieListWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutListItemsInput = {
    create?: XOR<MovieCreateWithoutListItemsInput, MovieUncheckedCreateWithoutListItemsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutListItemsInput
    connect?: MovieWhereUniqueInput
  }

  export type MovieListUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<MovieListCreateWithoutItemsInput, MovieListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MovieListCreateOrConnectWithoutItemsInput
    upsert?: MovieListUpsertWithoutItemsInput
    connect?: MovieListWhereUniqueInput
    update?: XOR<XOR<MovieListUpdateToOneWithWhereWithoutItemsInput, MovieListUpdateWithoutItemsInput>, MovieListUncheckedUpdateWithoutItemsInput>
  }

  export type MovieUpdateOneWithoutListItemsNestedInput = {
    create?: XOR<MovieCreateWithoutListItemsInput, MovieUncheckedCreateWithoutListItemsInput>
    connectOrCreate?: MovieCreateOrConnectWithoutListItemsInput
    upsert?: MovieUpsertWithoutListItemsInput
    disconnect?: MovieWhereInput | boolean
    delete?: MovieWhereInput | boolean
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutListItemsInput, MovieUpdateWithoutListItemsInput>, MovieUncheckedUpdateWithoutListItemsInput>
  }

  export type UserCreateNestedOneWithoutImportRunsInput = {
    create?: XOR<UserCreateWithoutImportRunsInput, UserUncheckedCreateWithoutImportRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImportRunsInput
    connect?: UserWhereUniqueInput
  }

  export type ImportAuditRowCreateNestedManyWithoutImportRunInput = {
    create?: XOR<ImportAuditRowCreateWithoutImportRunInput, ImportAuditRowUncheckedCreateWithoutImportRunInput> | ImportAuditRowCreateWithoutImportRunInput[] | ImportAuditRowUncheckedCreateWithoutImportRunInput[]
    connectOrCreate?: ImportAuditRowCreateOrConnectWithoutImportRunInput | ImportAuditRowCreateOrConnectWithoutImportRunInput[]
    createMany?: ImportAuditRowCreateManyImportRunInputEnvelope
    connect?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
  }

  export type WatchLogCreateNestedManyWithoutImportRunInput = {
    create?: XOR<WatchLogCreateWithoutImportRunInput, WatchLogUncheckedCreateWithoutImportRunInput> | WatchLogCreateWithoutImportRunInput[] | WatchLogUncheckedCreateWithoutImportRunInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutImportRunInput | WatchLogCreateOrConnectWithoutImportRunInput[]
    createMany?: WatchLogCreateManyImportRunInputEnvelope
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
  }

  export type ImportAuditRowUncheckedCreateNestedManyWithoutImportRunInput = {
    create?: XOR<ImportAuditRowCreateWithoutImportRunInput, ImportAuditRowUncheckedCreateWithoutImportRunInput> | ImportAuditRowCreateWithoutImportRunInput[] | ImportAuditRowUncheckedCreateWithoutImportRunInput[]
    connectOrCreate?: ImportAuditRowCreateOrConnectWithoutImportRunInput | ImportAuditRowCreateOrConnectWithoutImportRunInput[]
    createMany?: ImportAuditRowCreateManyImportRunInputEnvelope
    connect?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
  }

  export type WatchLogUncheckedCreateNestedManyWithoutImportRunInput = {
    create?: XOR<WatchLogCreateWithoutImportRunInput, WatchLogUncheckedCreateWithoutImportRunInput> | WatchLogCreateWithoutImportRunInput[] | WatchLogUncheckedCreateWithoutImportRunInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutImportRunInput | WatchLogCreateOrConnectWithoutImportRunInput[]
    createMany?: WatchLogCreateManyImportRunInputEnvelope
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutImportRunsNestedInput = {
    create?: XOR<UserCreateWithoutImportRunsInput, UserUncheckedCreateWithoutImportRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImportRunsInput
    upsert?: UserUpsertWithoutImportRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutImportRunsInput, UserUpdateWithoutImportRunsInput>, UserUncheckedUpdateWithoutImportRunsInput>
  }

  export type ImportAuditRowUpdateManyWithoutImportRunNestedInput = {
    create?: XOR<ImportAuditRowCreateWithoutImportRunInput, ImportAuditRowUncheckedCreateWithoutImportRunInput> | ImportAuditRowCreateWithoutImportRunInput[] | ImportAuditRowUncheckedCreateWithoutImportRunInput[]
    connectOrCreate?: ImportAuditRowCreateOrConnectWithoutImportRunInput | ImportAuditRowCreateOrConnectWithoutImportRunInput[]
    upsert?: ImportAuditRowUpsertWithWhereUniqueWithoutImportRunInput | ImportAuditRowUpsertWithWhereUniqueWithoutImportRunInput[]
    createMany?: ImportAuditRowCreateManyImportRunInputEnvelope
    set?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
    disconnect?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
    delete?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
    connect?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
    update?: ImportAuditRowUpdateWithWhereUniqueWithoutImportRunInput | ImportAuditRowUpdateWithWhereUniqueWithoutImportRunInput[]
    updateMany?: ImportAuditRowUpdateManyWithWhereWithoutImportRunInput | ImportAuditRowUpdateManyWithWhereWithoutImportRunInput[]
    deleteMany?: ImportAuditRowScalarWhereInput | ImportAuditRowScalarWhereInput[]
  }

  export type WatchLogUpdateManyWithoutImportRunNestedInput = {
    create?: XOR<WatchLogCreateWithoutImportRunInput, WatchLogUncheckedCreateWithoutImportRunInput> | WatchLogCreateWithoutImportRunInput[] | WatchLogUncheckedCreateWithoutImportRunInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutImportRunInput | WatchLogCreateOrConnectWithoutImportRunInput[]
    upsert?: WatchLogUpsertWithWhereUniqueWithoutImportRunInput | WatchLogUpsertWithWhereUniqueWithoutImportRunInput[]
    createMany?: WatchLogCreateManyImportRunInputEnvelope
    set?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    disconnect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    delete?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    update?: WatchLogUpdateWithWhereUniqueWithoutImportRunInput | WatchLogUpdateWithWhereUniqueWithoutImportRunInput[]
    updateMany?: WatchLogUpdateManyWithWhereWithoutImportRunInput | WatchLogUpdateManyWithWhereWithoutImportRunInput[]
    deleteMany?: WatchLogScalarWhereInput | WatchLogScalarWhereInput[]
  }

  export type ImportAuditRowUncheckedUpdateManyWithoutImportRunNestedInput = {
    create?: XOR<ImportAuditRowCreateWithoutImportRunInput, ImportAuditRowUncheckedCreateWithoutImportRunInput> | ImportAuditRowCreateWithoutImportRunInput[] | ImportAuditRowUncheckedCreateWithoutImportRunInput[]
    connectOrCreate?: ImportAuditRowCreateOrConnectWithoutImportRunInput | ImportAuditRowCreateOrConnectWithoutImportRunInput[]
    upsert?: ImportAuditRowUpsertWithWhereUniqueWithoutImportRunInput | ImportAuditRowUpsertWithWhereUniqueWithoutImportRunInput[]
    createMany?: ImportAuditRowCreateManyImportRunInputEnvelope
    set?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
    disconnect?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
    delete?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
    connect?: ImportAuditRowWhereUniqueInput | ImportAuditRowWhereUniqueInput[]
    update?: ImportAuditRowUpdateWithWhereUniqueWithoutImportRunInput | ImportAuditRowUpdateWithWhereUniqueWithoutImportRunInput[]
    updateMany?: ImportAuditRowUpdateManyWithWhereWithoutImportRunInput | ImportAuditRowUpdateManyWithWhereWithoutImportRunInput[]
    deleteMany?: ImportAuditRowScalarWhereInput | ImportAuditRowScalarWhereInput[]
  }

  export type WatchLogUncheckedUpdateManyWithoutImportRunNestedInput = {
    create?: XOR<WatchLogCreateWithoutImportRunInput, WatchLogUncheckedCreateWithoutImportRunInput> | WatchLogCreateWithoutImportRunInput[] | WatchLogUncheckedCreateWithoutImportRunInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutImportRunInput | WatchLogCreateOrConnectWithoutImportRunInput[]
    upsert?: WatchLogUpsertWithWhereUniqueWithoutImportRunInput | WatchLogUpsertWithWhereUniqueWithoutImportRunInput[]
    createMany?: WatchLogCreateManyImportRunInputEnvelope
    set?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    disconnect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    delete?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    update?: WatchLogUpdateWithWhereUniqueWithoutImportRunInput | WatchLogUpdateWithWhereUniqueWithoutImportRunInput[]
    updateMany?: WatchLogUpdateManyWithWhereWithoutImportRunInput | WatchLogUpdateManyWithWhereWithoutImportRunInput[]
    deleteMany?: WatchLogScalarWhereInput | WatchLogScalarWhereInput[]
  }

  export type ImportRunCreateNestedOneWithoutAuditRowsInput = {
    create?: XOR<ImportRunCreateWithoutAuditRowsInput, ImportRunUncheckedCreateWithoutAuditRowsInput>
    connectOrCreate?: ImportRunCreateOrConnectWithoutAuditRowsInput
    connect?: ImportRunWhereUniqueInput
  }

  export type ImportRunUpdateOneRequiredWithoutAuditRowsNestedInput = {
    create?: XOR<ImportRunCreateWithoutAuditRowsInput, ImportRunUncheckedCreateWithoutAuditRowsInput>
    connectOrCreate?: ImportRunCreateOrConnectWithoutAuditRowsInput
    upsert?: ImportRunUpsertWithoutAuditRowsInput
    connect?: ImportRunWhereUniqueInput
    update?: XOR<XOR<ImportRunUpdateToOneWithWhereWithoutAuditRowsInput, ImportRunUpdateWithoutAuditRowsInput>, ImportRunUncheckedUpdateWithoutAuditRowsInput>
  }

  export type UserCreateNestedOneWithoutBallotsInput = {
    create?: XOR<UserCreateWithoutBallotsInput, UserUncheckedCreateWithoutBallotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBallotsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBallotsNestedInput = {
    create?: XOR<UserCreateWithoutBallotsInput, UserUncheckedCreateWithoutBallotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBallotsInput
    upsert?: UserUpsertWithoutBallotsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBallotsInput, UserUpdateWithoutBallotsInput>, UserUncheckedUpdateWithoutBallotsInput>
  }

  export type AwardSeasonCreateNestedManyWithoutEventInput = {
    create?: XOR<AwardSeasonCreateWithoutEventInput, AwardSeasonUncheckedCreateWithoutEventInput> | AwardSeasonCreateWithoutEventInput[] | AwardSeasonUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AwardSeasonCreateOrConnectWithoutEventInput | AwardSeasonCreateOrConnectWithoutEventInput[]
    createMany?: AwardSeasonCreateManyEventInputEnvelope
    connect?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
  }

  export type AwardSeasonUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<AwardSeasonCreateWithoutEventInput, AwardSeasonUncheckedCreateWithoutEventInput> | AwardSeasonCreateWithoutEventInput[] | AwardSeasonUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AwardSeasonCreateOrConnectWithoutEventInput | AwardSeasonCreateOrConnectWithoutEventInput[]
    createMany?: AwardSeasonCreateManyEventInputEnvelope
    connect?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
  }

  export type AwardSeasonUpdateManyWithoutEventNestedInput = {
    create?: XOR<AwardSeasonCreateWithoutEventInput, AwardSeasonUncheckedCreateWithoutEventInput> | AwardSeasonCreateWithoutEventInput[] | AwardSeasonUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AwardSeasonCreateOrConnectWithoutEventInput | AwardSeasonCreateOrConnectWithoutEventInput[]
    upsert?: AwardSeasonUpsertWithWhereUniqueWithoutEventInput | AwardSeasonUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AwardSeasonCreateManyEventInputEnvelope
    set?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
    disconnect?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
    delete?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
    connect?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
    update?: AwardSeasonUpdateWithWhereUniqueWithoutEventInput | AwardSeasonUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AwardSeasonUpdateManyWithWhereWithoutEventInput | AwardSeasonUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AwardSeasonScalarWhereInput | AwardSeasonScalarWhereInput[]
  }

  export type AwardSeasonUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<AwardSeasonCreateWithoutEventInput, AwardSeasonUncheckedCreateWithoutEventInput> | AwardSeasonCreateWithoutEventInput[] | AwardSeasonUncheckedCreateWithoutEventInput[]
    connectOrCreate?: AwardSeasonCreateOrConnectWithoutEventInput | AwardSeasonCreateOrConnectWithoutEventInput[]
    upsert?: AwardSeasonUpsertWithWhereUniqueWithoutEventInput | AwardSeasonUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: AwardSeasonCreateManyEventInputEnvelope
    set?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
    disconnect?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
    delete?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
    connect?: AwardSeasonWhereUniqueInput | AwardSeasonWhereUniqueInput[]
    update?: AwardSeasonUpdateWithWhereUniqueWithoutEventInput | AwardSeasonUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: AwardSeasonUpdateManyWithWhereWithoutEventInput | AwardSeasonUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: AwardSeasonScalarWhereInput | AwardSeasonScalarWhereInput[]
  }

  export type AwardEventCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<AwardEventCreateWithoutSeasonsInput, AwardEventUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: AwardEventCreateOrConnectWithoutSeasonsInput
    connect?: AwardEventWhereUniqueInput
  }

  export type AwardWinnerCreateNestedManyWithoutSeasonRelInput = {
    create?: XOR<AwardWinnerCreateWithoutSeasonRelInput, AwardWinnerUncheckedCreateWithoutSeasonRelInput> | AwardWinnerCreateWithoutSeasonRelInput[] | AwardWinnerUncheckedCreateWithoutSeasonRelInput[]
    connectOrCreate?: AwardWinnerCreateOrConnectWithoutSeasonRelInput | AwardWinnerCreateOrConnectWithoutSeasonRelInput[]
    createMany?: AwardWinnerCreateManySeasonRelInputEnvelope
    connect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
  }

  export type AwardWinnerUncheckedCreateNestedManyWithoutSeasonRelInput = {
    create?: XOR<AwardWinnerCreateWithoutSeasonRelInput, AwardWinnerUncheckedCreateWithoutSeasonRelInput> | AwardWinnerCreateWithoutSeasonRelInput[] | AwardWinnerUncheckedCreateWithoutSeasonRelInput[]
    connectOrCreate?: AwardWinnerCreateOrConnectWithoutSeasonRelInput | AwardWinnerCreateOrConnectWithoutSeasonRelInput[]
    createMany?: AwardWinnerCreateManySeasonRelInputEnvelope
    connect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
  }

  export type AwardEventUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<AwardEventCreateWithoutSeasonsInput, AwardEventUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: AwardEventCreateOrConnectWithoutSeasonsInput
    upsert?: AwardEventUpsertWithoutSeasonsInput
    connect?: AwardEventWhereUniqueInput
    update?: XOR<XOR<AwardEventUpdateToOneWithWhereWithoutSeasonsInput, AwardEventUpdateWithoutSeasonsInput>, AwardEventUncheckedUpdateWithoutSeasonsInput>
  }

  export type AwardWinnerUpdateManyWithoutSeasonRelNestedInput = {
    create?: XOR<AwardWinnerCreateWithoutSeasonRelInput, AwardWinnerUncheckedCreateWithoutSeasonRelInput> | AwardWinnerCreateWithoutSeasonRelInput[] | AwardWinnerUncheckedCreateWithoutSeasonRelInput[]
    connectOrCreate?: AwardWinnerCreateOrConnectWithoutSeasonRelInput | AwardWinnerCreateOrConnectWithoutSeasonRelInput[]
    upsert?: AwardWinnerUpsertWithWhereUniqueWithoutSeasonRelInput | AwardWinnerUpsertWithWhereUniqueWithoutSeasonRelInput[]
    createMany?: AwardWinnerCreateManySeasonRelInputEnvelope
    set?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    disconnect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    delete?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    connect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    update?: AwardWinnerUpdateWithWhereUniqueWithoutSeasonRelInput | AwardWinnerUpdateWithWhereUniqueWithoutSeasonRelInput[]
    updateMany?: AwardWinnerUpdateManyWithWhereWithoutSeasonRelInput | AwardWinnerUpdateManyWithWhereWithoutSeasonRelInput[]
    deleteMany?: AwardWinnerScalarWhereInput | AwardWinnerScalarWhereInput[]
  }

  export type AwardWinnerUncheckedUpdateManyWithoutSeasonRelNestedInput = {
    create?: XOR<AwardWinnerCreateWithoutSeasonRelInput, AwardWinnerUncheckedCreateWithoutSeasonRelInput> | AwardWinnerCreateWithoutSeasonRelInput[] | AwardWinnerUncheckedCreateWithoutSeasonRelInput[]
    connectOrCreate?: AwardWinnerCreateOrConnectWithoutSeasonRelInput | AwardWinnerCreateOrConnectWithoutSeasonRelInput[]
    upsert?: AwardWinnerUpsertWithWhereUniqueWithoutSeasonRelInput | AwardWinnerUpsertWithWhereUniqueWithoutSeasonRelInput[]
    createMany?: AwardWinnerCreateManySeasonRelInputEnvelope
    set?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    disconnect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    delete?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    connect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    update?: AwardWinnerUpdateWithWhereUniqueWithoutSeasonRelInput | AwardWinnerUpdateWithWhereUniqueWithoutSeasonRelInput[]
    updateMany?: AwardWinnerUpdateManyWithWhereWithoutSeasonRelInput | AwardWinnerUpdateManyWithWhereWithoutSeasonRelInput[]
    deleteMany?: AwardWinnerScalarWhereInput | AwardWinnerScalarWhereInput[]
  }

  export type AwardWinnerCreateNestedManyWithoutMovieInput = {
    create?: XOR<AwardWinnerCreateWithoutMovieInput, AwardWinnerUncheckedCreateWithoutMovieInput> | AwardWinnerCreateWithoutMovieInput[] | AwardWinnerUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: AwardWinnerCreateOrConnectWithoutMovieInput | AwardWinnerCreateOrConnectWithoutMovieInput[]
    createMany?: AwardWinnerCreateManyMovieInputEnvelope
    connect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
  }

  export type MovieInteractionCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieInteractionCreateWithoutMovieInput, MovieInteractionUncheckedCreateWithoutMovieInput> | MovieInteractionCreateWithoutMovieInput[] | MovieInteractionUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieInteractionCreateOrConnectWithoutMovieInput | MovieInteractionCreateOrConnectWithoutMovieInput[]
    createMany?: MovieInteractionCreateManyMovieInputEnvelope
    connect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
  }

  export type WatchLogCreateNestedManyWithoutMovieInput = {
    create?: XOR<WatchLogCreateWithoutMovieInput, WatchLogUncheckedCreateWithoutMovieInput> | WatchLogCreateWithoutMovieInput[] | WatchLogUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutMovieInput | WatchLogCreateOrConnectWithoutMovieInput[]
    createMany?: WatchLogCreateManyMovieInputEnvelope
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
  }

  export type MovieListItemCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieListItemCreateWithoutMovieInput, MovieListItemUncheckedCreateWithoutMovieInput> | MovieListItemCreateWithoutMovieInput[] | MovieListItemUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieListItemCreateOrConnectWithoutMovieInput | MovieListItemCreateOrConnectWithoutMovieInput[]
    createMany?: MovieListItemCreateManyMovieInputEnvelope
    connect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
  }

  export type AwardWinnerUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<AwardWinnerCreateWithoutMovieInput, AwardWinnerUncheckedCreateWithoutMovieInput> | AwardWinnerCreateWithoutMovieInput[] | AwardWinnerUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: AwardWinnerCreateOrConnectWithoutMovieInput | AwardWinnerCreateOrConnectWithoutMovieInput[]
    createMany?: AwardWinnerCreateManyMovieInputEnvelope
    connect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
  }

  export type MovieInteractionUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieInteractionCreateWithoutMovieInput, MovieInteractionUncheckedCreateWithoutMovieInput> | MovieInteractionCreateWithoutMovieInput[] | MovieInteractionUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieInteractionCreateOrConnectWithoutMovieInput | MovieInteractionCreateOrConnectWithoutMovieInput[]
    createMany?: MovieInteractionCreateManyMovieInputEnvelope
    connect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
  }

  export type WatchLogUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<WatchLogCreateWithoutMovieInput, WatchLogUncheckedCreateWithoutMovieInput> | WatchLogCreateWithoutMovieInput[] | WatchLogUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutMovieInput | WatchLogCreateOrConnectWithoutMovieInput[]
    createMany?: WatchLogCreateManyMovieInputEnvelope
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
  }

  export type MovieListItemUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<MovieListItemCreateWithoutMovieInput, MovieListItemUncheckedCreateWithoutMovieInput> | MovieListItemCreateWithoutMovieInput[] | MovieListItemUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieListItemCreateOrConnectWithoutMovieInput | MovieListItemCreateOrConnectWithoutMovieInput[]
    createMany?: MovieListItemCreateManyMovieInputEnvelope
    connect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
  }

  export type AwardWinnerUpdateManyWithoutMovieNestedInput = {
    create?: XOR<AwardWinnerCreateWithoutMovieInput, AwardWinnerUncheckedCreateWithoutMovieInput> | AwardWinnerCreateWithoutMovieInput[] | AwardWinnerUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: AwardWinnerCreateOrConnectWithoutMovieInput | AwardWinnerCreateOrConnectWithoutMovieInput[]
    upsert?: AwardWinnerUpsertWithWhereUniqueWithoutMovieInput | AwardWinnerUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: AwardWinnerCreateManyMovieInputEnvelope
    set?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    disconnect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    delete?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    connect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    update?: AwardWinnerUpdateWithWhereUniqueWithoutMovieInput | AwardWinnerUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: AwardWinnerUpdateManyWithWhereWithoutMovieInput | AwardWinnerUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: AwardWinnerScalarWhereInput | AwardWinnerScalarWhereInput[]
  }

  export type MovieInteractionUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieInteractionCreateWithoutMovieInput, MovieInteractionUncheckedCreateWithoutMovieInput> | MovieInteractionCreateWithoutMovieInput[] | MovieInteractionUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieInteractionCreateOrConnectWithoutMovieInput | MovieInteractionCreateOrConnectWithoutMovieInput[]
    upsert?: MovieInteractionUpsertWithWhereUniqueWithoutMovieInput | MovieInteractionUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieInteractionCreateManyMovieInputEnvelope
    set?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    disconnect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    delete?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    connect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    update?: MovieInteractionUpdateWithWhereUniqueWithoutMovieInput | MovieInteractionUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieInteractionUpdateManyWithWhereWithoutMovieInput | MovieInteractionUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieInteractionScalarWhereInput | MovieInteractionScalarWhereInput[]
  }

  export type WatchLogUpdateManyWithoutMovieNestedInput = {
    create?: XOR<WatchLogCreateWithoutMovieInput, WatchLogUncheckedCreateWithoutMovieInput> | WatchLogCreateWithoutMovieInput[] | WatchLogUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutMovieInput | WatchLogCreateOrConnectWithoutMovieInput[]
    upsert?: WatchLogUpsertWithWhereUniqueWithoutMovieInput | WatchLogUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: WatchLogCreateManyMovieInputEnvelope
    set?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    disconnect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    delete?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    update?: WatchLogUpdateWithWhereUniqueWithoutMovieInput | WatchLogUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: WatchLogUpdateManyWithWhereWithoutMovieInput | WatchLogUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: WatchLogScalarWhereInput | WatchLogScalarWhereInput[]
  }

  export type MovieListItemUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieListItemCreateWithoutMovieInput, MovieListItemUncheckedCreateWithoutMovieInput> | MovieListItemCreateWithoutMovieInput[] | MovieListItemUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieListItemCreateOrConnectWithoutMovieInput | MovieListItemCreateOrConnectWithoutMovieInput[]
    upsert?: MovieListItemUpsertWithWhereUniqueWithoutMovieInput | MovieListItemUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieListItemCreateManyMovieInputEnvelope
    set?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    disconnect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    delete?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    connect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    update?: MovieListItemUpdateWithWhereUniqueWithoutMovieInput | MovieListItemUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieListItemUpdateManyWithWhereWithoutMovieInput | MovieListItemUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieListItemScalarWhereInput | MovieListItemScalarWhereInput[]
  }

  export type AwardWinnerUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<AwardWinnerCreateWithoutMovieInput, AwardWinnerUncheckedCreateWithoutMovieInput> | AwardWinnerCreateWithoutMovieInput[] | AwardWinnerUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: AwardWinnerCreateOrConnectWithoutMovieInput | AwardWinnerCreateOrConnectWithoutMovieInput[]
    upsert?: AwardWinnerUpsertWithWhereUniqueWithoutMovieInput | AwardWinnerUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: AwardWinnerCreateManyMovieInputEnvelope
    set?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    disconnect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    delete?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    connect?: AwardWinnerWhereUniqueInput | AwardWinnerWhereUniqueInput[]
    update?: AwardWinnerUpdateWithWhereUniqueWithoutMovieInput | AwardWinnerUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: AwardWinnerUpdateManyWithWhereWithoutMovieInput | AwardWinnerUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: AwardWinnerScalarWhereInput | AwardWinnerScalarWhereInput[]
  }

  export type MovieInteractionUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieInteractionCreateWithoutMovieInput, MovieInteractionUncheckedCreateWithoutMovieInput> | MovieInteractionCreateWithoutMovieInput[] | MovieInteractionUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieInteractionCreateOrConnectWithoutMovieInput | MovieInteractionCreateOrConnectWithoutMovieInput[]
    upsert?: MovieInteractionUpsertWithWhereUniqueWithoutMovieInput | MovieInteractionUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieInteractionCreateManyMovieInputEnvelope
    set?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    disconnect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    delete?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    connect?: MovieInteractionWhereUniqueInput | MovieInteractionWhereUniqueInput[]
    update?: MovieInteractionUpdateWithWhereUniqueWithoutMovieInput | MovieInteractionUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieInteractionUpdateManyWithWhereWithoutMovieInput | MovieInteractionUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieInteractionScalarWhereInput | MovieInteractionScalarWhereInput[]
  }

  export type WatchLogUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<WatchLogCreateWithoutMovieInput, WatchLogUncheckedCreateWithoutMovieInput> | WatchLogCreateWithoutMovieInput[] | WatchLogUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: WatchLogCreateOrConnectWithoutMovieInput | WatchLogCreateOrConnectWithoutMovieInput[]
    upsert?: WatchLogUpsertWithWhereUniqueWithoutMovieInput | WatchLogUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: WatchLogCreateManyMovieInputEnvelope
    set?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    disconnect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    delete?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    connect?: WatchLogWhereUniqueInput | WatchLogWhereUniqueInput[]
    update?: WatchLogUpdateWithWhereUniqueWithoutMovieInput | WatchLogUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: WatchLogUpdateManyWithWhereWithoutMovieInput | WatchLogUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: WatchLogScalarWhereInput | WatchLogScalarWhereInput[]
  }

  export type MovieListItemUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<MovieListItemCreateWithoutMovieInput, MovieListItemUncheckedCreateWithoutMovieInput> | MovieListItemCreateWithoutMovieInput[] | MovieListItemUncheckedCreateWithoutMovieInput[]
    connectOrCreate?: MovieListItemCreateOrConnectWithoutMovieInput | MovieListItemCreateOrConnectWithoutMovieInput[]
    upsert?: MovieListItemUpsertWithWhereUniqueWithoutMovieInput | MovieListItemUpsertWithWhereUniqueWithoutMovieInput[]
    createMany?: MovieListItemCreateManyMovieInputEnvelope
    set?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    disconnect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    delete?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    connect?: MovieListItemWhereUniqueInput | MovieListItemWhereUniqueInput[]
    update?: MovieListItemUpdateWithWhereUniqueWithoutMovieInput | MovieListItemUpdateWithWhereUniqueWithoutMovieInput[]
    updateMany?: MovieListItemUpdateManyWithWhereWithoutMovieInput | MovieListItemUpdateManyWithWhereWithoutMovieInput[]
    deleteMany?: MovieListItemScalarWhereInput | MovieListItemScalarWhereInput[]
  }

  export type AwardSeasonCreateNestedOneWithoutWinnersInput = {
    create?: XOR<AwardSeasonCreateWithoutWinnersInput, AwardSeasonUncheckedCreateWithoutWinnersInput>
    connectOrCreate?: AwardSeasonCreateOrConnectWithoutWinnersInput
    connect?: AwardSeasonWhereUniqueInput
  }

  export type MovieCreateNestedOneWithoutWinnersInput = {
    create?: XOR<MovieCreateWithoutWinnersInput, MovieUncheckedCreateWithoutWinnersInput>
    connectOrCreate?: MovieCreateOrConnectWithoutWinnersInput
    connect?: MovieWhereUniqueInput
  }

  export type AwardSeasonUpdateOneRequiredWithoutWinnersNestedInput = {
    create?: XOR<AwardSeasonCreateWithoutWinnersInput, AwardSeasonUncheckedCreateWithoutWinnersInput>
    connectOrCreate?: AwardSeasonCreateOrConnectWithoutWinnersInput
    upsert?: AwardSeasonUpsertWithoutWinnersInput
    connect?: AwardSeasonWhereUniqueInput
    update?: XOR<XOR<AwardSeasonUpdateToOneWithWhereWithoutWinnersInput, AwardSeasonUpdateWithoutWinnersInput>, AwardSeasonUncheckedUpdateWithoutWinnersInput>
  }

  export type MovieUpdateOneRequiredWithoutWinnersNestedInput = {
    create?: XOR<MovieCreateWithoutWinnersInput, MovieUncheckedCreateWithoutWinnersInput>
    connectOrCreate?: MovieCreateOrConnectWithoutWinnersInput
    upsert?: MovieUpsertWithoutWinnersInput
    connect?: MovieWhereUniqueInput
    update?: XOR<XOR<MovieUpdateToOneWithWhereWithoutWinnersInput, MovieUpdateWithoutWinnersInput>, MovieUncheckedUpdateWithoutWinnersInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutOnboardingInput = {
    create?: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOnboardingNestedInput = {
    create?: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    connectOrCreate?: UserCreateOrConnectWithoutOnboardingInput
    upsert?: UserUpsertWithoutOnboardingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOnboardingInput, UserUpdateWithoutOnboardingInput>, UserUncheckedUpdateWithoutOnboardingInput>
  }

  export type UserCreateNestedOneWithoutPreferredGenresInput = {
    create?: XOR<UserCreateWithoutPreferredGenresInput, UserUncheckedCreateWithoutPreferredGenresInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferredGenresInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPreferredGenresNestedInput = {
    create?: XOR<UserCreateWithoutPreferredGenresInput, UserUncheckedCreateWithoutPreferredGenresInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferredGenresInput
    upsert?: UserUpsertWithoutPreferredGenresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferredGenresInput, UserUpdateWithoutPreferredGenresInput>, UserUncheckedUpdateWithoutPreferredGenresInput>
  }

  export type UserCreateNestedOneWithoutTopTenInput = {
    create?: XOR<UserCreateWithoutTopTenInput, UserUncheckedCreateWithoutTopTenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopTenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTopTenNestedInput = {
    create?: XOR<UserCreateWithoutTopTenInput, UserUncheckedCreateWithoutTopTenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopTenInput
    upsert?: UserUpsertWithoutTopTenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTopTenInput, UserUpdateWithoutTopTenInput>, UserUncheckedUpdateWithoutTopTenInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type MovieInteractionCreateWithoutUserInput = {
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
    movie?: MovieCreateNestedOneWithoutInteractionsInput
  }

  export type MovieInteractionUncheckedCreateWithoutUserInput = {
    movieId: number
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type MovieInteractionCreateOrConnectWithoutUserInput = {
    where: MovieInteractionWhereUniqueInput
    create: XOR<MovieInteractionCreateWithoutUserInput, MovieInteractionUncheckedCreateWithoutUserInput>
  }

  export type MovieInteractionCreateManyUserInputEnvelope = {
    data: MovieInteractionCreateManyUserInput | MovieInteractionCreateManyUserInput[]
  }

  export type WatchLogCreateWithoutUserInput = {
    id?: string
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    importRun?: ImportRunCreateNestedOneWithoutWatchLogsInput
    movie: MovieCreateNestedOneWithoutWatchLogsInput
    review?: ReviewCreateNestedOneWithoutWatchLogInput
  }

  export type WatchLogUncheckedCreateWithoutUserInput = {
    id?: string
    movieId: number
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importId?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutWatchLogInput
  }

  export type WatchLogCreateOrConnectWithoutUserInput = {
    where: WatchLogWhereUniqueInput
    create: XOR<WatchLogCreateWithoutUserInput, WatchLogUncheckedCreateWithoutUserInput>
  }

  export type WatchLogCreateManyUserInputEnvelope = {
    data: WatchLogCreateManyUserInput | WatchLogCreateManyUserInput[]
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    movieId: number
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    watchLog?: WatchLogCreateNestedOneWithoutReviewInput
    comments?: ReviewCommentCreateNestedManyWithoutReviewInput
    favorites?: ReviewFavoriteCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    movieId: number
    watchLogId?: string | null
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ReviewCommentUncheckedCreateNestedManyWithoutReviewInput
    favorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
  }

  export type ReviewCommentCreateWithoutUserInput = {
    id?: string
    body: string
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutCommentsInput
  }

  export type ReviewCommentUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    body: string
    createdAt?: Date | string
  }

  export type ReviewCommentCreateOrConnectWithoutUserInput = {
    where: ReviewCommentWhereUniqueInput
    create: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput>
  }

  export type ReviewCommentCreateManyUserInputEnvelope = {
    data: ReviewCommentCreateManyUserInput | ReviewCommentCreateManyUserInput[]
  }

  export type ReviewFavoriteCreateWithoutUserInput = {
    review: ReviewCreateNestedOneWithoutFavoritesInput
  }

  export type ReviewFavoriteUncheckedCreateWithoutUserInput = {
    reviewId: string
  }

  export type ReviewFavoriteCreateOrConnectWithoutUserInput = {
    where: ReviewFavoriteWhereUniqueInput
    create: XOR<ReviewFavoriteCreateWithoutUserInput, ReviewFavoriteUncheckedCreateWithoutUserInput>
  }

  export type ReviewFavoriteCreateManyUserInputEnvelope = {
    data: ReviewFavoriteCreateManyUserInput | ReviewFavoriteCreateManyUserInput[]
  }

  export type MovieListCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    tags?: string | null
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: string | null
    isPublic?: boolean
    sourceListId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MovieListItemCreateNestedManyWithoutListInput
  }

  export type MovieListUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    tags?: string | null
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: string | null
    isPublic?: boolean
    sourceListId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MovieListItemUncheckedCreateNestedManyWithoutListInput
  }

  export type MovieListCreateOrConnectWithoutUserInput = {
    where: MovieListWhereUniqueInput
    create: XOR<MovieListCreateWithoutUserInput, MovieListUncheckedCreateWithoutUserInput>
  }

  export type MovieListCreateManyUserInputEnvelope = {
    data: MovieListCreateManyUserInput | MovieListCreateManyUserInput[]
  }

  export type BallotCreateWithoutUserInput = {
    id?: string
    eventYear: number
    category: string
    nomineeId: string
    nomineeName: string
    isWinner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BallotUncheckedCreateWithoutUserInput = {
    id?: string
    eventYear: number
    category: string
    nomineeId: string
    nomineeName: string
    isWinner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BallotCreateOrConnectWithoutUserInput = {
    where: BallotWhereUniqueInput
    create: XOR<BallotCreateWithoutUserInput, BallotUncheckedCreateWithoutUserInput>
  }

  export type BallotCreateManyUserInputEnvelope = {
    data: BallotCreateManyUserInput | BallotCreateManyUserInput[]
  }

  export type StreamingSubscriptionCreateWithoutUserInput = {
    id?: string
    providerId: number
    name: string
    logoPath?: string | null
    createdAt?: Date | string
  }

  export type StreamingSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    providerId: number
    name: string
    logoPath?: string | null
    createdAt?: Date | string
  }

  export type StreamingSubscriptionCreateOrConnectWithoutUserInput = {
    where: StreamingSubscriptionWhereUniqueInput
    create: XOR<StreamingSubscriptionCreateWithoutUserInput, StreamingSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type StreamingSubscriptionCreateManyUserInputEnvelope = {
    data: StreamingSubscriptionCreateManyUserInput | StreamingSubscriptionCreateManyUserInput[]
  }

  export type ImportRunCreateWithoutUserInput = {
    id?: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditRows?: ImportAuditRowCreateNestedManyWithoutImportRunInput
    watchLogs?: WatchLogCreateNestedManyWithoutImportRunInput
  }

  export type ImportRunUncheckedCreateWithoutUserInput = {
    id?: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditRows?: ImportAuditRowUncheckedCreateNestedManyWithoutImportRunInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutImportRunInput
  }

  export type ImportRunCreateOrConnectWithoutUserInput = {
    where: ImportRunWhereUniqueInput
    create: XOR<ImportRunCreateWithoutUserInput, ImportRunUncheckedCreateWithoutUserInput>
  }

  export type ImportRunCreateManyUserInputEnvelope = {
    data: ImportRunCreateManyUserInput | ImportRunCreateManyUserInput[]
  }

  export type UserTopTenCreateWithoutUserInput = {
    id?: string
    tmdbId: number
    position: number
    createdAt?: Date | string
  }

  export type UserTopTenUncheckedCreateWithoutUserInput = {
    id?: string
    tmdbId: number
    position: number
    createdAt?: Date | string
  }

  export type UserTopTenCreateOrConnectWithoutUserInput = {
    where: UserTopTenWhereUniqueInput
    create: XOR<UserTopTenCreateWithoutUserInput, UserTopTenUncheckedCreateWithoutUserInput>
  }

  export type UserTopTenCreateManyUserInputEnvelope = {
    data: UserTopTenCreateManyUserInput | UserTopTenCreateManyUserInput[]
  }

  export type UserSettingsCreateWithoutUserInput = {
    providerMode?: string
    region?: string | null
    runtimeMin?: number | null
    runtimeMax?: number | null
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    providerMode?: string
    region?: string | null
    runtimeMin?: number | null
    runtimeMax?: number | null
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type OnboardingStateCreateWithoutUserInput = {
    isCompleted?: boolean
    completedAt?: Date | string | null
    lastNudgedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type OnboardingStateUncheckedCreateWithoutUserInput = {
    isCompleted?: boolean
    completedAt?: Date | string | null
    lastNudgedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type OnboardingStateCreateOrConnectWithoutUserInput = {
    where: OnboardingStateWhereUniqueInput
    create: XOR<OnboardingStateCreateWithoutUserInput, OnboardingStateUncheckedCreateWithoutUserInput>
  }

  export type UserPreferredGenreCreateWithoutUserInput = {
    genreId: number
  }

  export type UserPreferredGenreUncheckedCreateWithoutUserInput = {
    genreId: number
  }

  export type UserPreferredGenreCreateOrConnectWithoutUserInput = {
    where: UserPreferredGenreWhereUniqueInput
    create: XOR<UserPreferredGenreCreateWithoutUserInput, UserPreferredGenreUncheckedCreateWithoutUserInput>
  }

  export type UserPreferredGenreCreateManyUserInputEnvelope = {
    data: UserPreferredGenreCreateManyUserInput | UserPreferredGenreCreateManyUserInput[]
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type MovieInteractionUpsertWithWhereUniqueWithoutUserInput = {
    where: MovieInteractionWhereUniqueInput
    update: XOR<MovieInteractionUpdateWithoutUserInput, MovieInteractionUncheckedUpdateWithoutUserInput>
    create: XOR<MovieInteractionCreateWithoutUserInput, MovieInteractionUncheckedCreateWithoutUserInput>
  }

  export type MovieInteractionUpdateWithWhereUniqueWithoutUserInput = {
    where: MovieInteractionWhereUniqueInput
    data: XOR<MovieInteractionUpdateWithoutUserInput, MovieInteractionUncheckedUpdateWithoutUserInput>
  }

  export type MovieInteractionUpdateManyWithWhereWithoutUserInput = {
    where: MovieInteractionScalarWhereInput
    data: XOR<MovieInteractionUpdateManyMutationInput, MovieInteractionUncheckedUpdateManyWithoutUserInput>
  }

  export type MovieInteractionScalarWhereInput = {
    AND?: MovieInteractionScalarWhereInput | MovieInteractionScalarWhereInput[]
    OR?: MovieInteractionScalarWhereInput[]
    NOT?: MovieInteractionScalarWhereInput | MovieInteractionScalarWhereInput[]
    userId?: StringFilter<"MovieInteraction"> | string
    movieId?: IntFilter<"MovieInteraction"> | number
    watched?: BoolFilter<"MovieInteraction"> | boolean
    watchlisted?: BoolFilter<"MovieInteraction"> | boolean
    favorited?: BoolFilter<"MovieInteraction"> | boolean
    ratingHalf?: IntNullableFilter<"MovieInteraction"> | number | null
    ratedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    favoritedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    watchedAt?: DateTimeNullableFilter<"MovieInteraction"> | Date | string | null
    updatedAt?: DateTimeFilter<"MovieInteraction"> | Date | string
  }

  export type WatchLogUpsertWithWhereUniqueWithoutUserInput = {
    where: WatchLogWhereUniqueInput
    update: XOR<WatchLogUpdateWithoutUserInput, WatchLogUncheckedUpdateWithoutUserInput>
    create: XOR<WatchLogCreateWithoutUserInput, WatchLogUncheckedCreateWithoutUserInput>
  }

  export type WatchLogUpdateWithWhereUniqueWithoutUserInput = {
    where: WatchLogWhereUniqueInput
    data: XOR<WatchLogUpdateWithoutUserInput, WatchLogUncheckedUpdateWithoutUserInput>
  }

  export type WatchLogUpdateManyWithWhereWithoutUserInput = {
    where: WatchLogScalarWhereInput
    data: XOR<WatchLogUpdateManyMutationInput, WatchLogUncheckedUpdateManyWithoutUserInput>
  }

  export type WatchLogScalarWhereInput = {
    AND?: WatchLogScalarWhereInput | WatchLogScalarWhereInput[]
    OR?: WatchLogScalarWhereInput[]
    NOT?: WatchLogScalarWhereInput | WatchLogScalarWhereInput[]
    id?: StringFilter<"WatchLog"> | string
    userId?: StringFilter<"WatchLog"> | string
    movieId?: IntFilter<"WatchLog"> | number
    watchedAt?: DateTimeFilter<"WatchLog"> | Date | string
    rewatch?: BoolFilter<"WatchLog"> | boolean
    tags?: StringNullableFilter<"WatchLog"> | string | null
    note?: StringNullableFilter<"WatchLog"> | string | null
    importId?: StringNullableFilter<"WatchLog"> | string | null
    importRowId?: StringNullableFilter<"WatchLog"> | string | null
    createdAt?: DateTimeFilter<"WatchLog"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    movieId?: IntFilter<"Review"> | number
    watchLogId?: StringNullableFilter<"Review"> | string | null
    bodyRaw?: StringFilter<"Review"> | string
    bodyFormat?: StringFilter<"Review"> | string
    ratingHalf?: IntNullableFilter<"Review"> | number | null
    tags?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ReviewCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewCommentWhereUniqueInput
    update: XOR<ReviewCommentUpdateWithoutUserInput, ReviewCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCommentCreateWithoutUserInput, ReviewCommentUncheckedCreateWithoutUserInput>
  }

  export type ReviewCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewCommentWhereUniqueInput
    data: XOR<ReviewCommentUpdateWithoutUserInput, ReviewCommentUncheckedUpdateWithoutUserInput>
  }

  export type ReviewCommentUpdateManyWithWhereWithoutUserInput = {
    where: ReviewCommentScalarWhereInput
    data: XOR<ReviewCommentUpdateManyMutationInput, ReviewCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewCommentScalarWhereInput = {
    AND?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
    OR?: ReviewCommentScalarWhereInput[]
    NOT?: ReviewCommentScalarWhereInput | ReviewCommentScalarWhereInput[]
    id?: StringFilter<"ReviewComment"> | string
    reviewId?: StringFilter<"ReviewComment"> | string
    userId?: StringFilter<"ReviewComment"> | string
    body?: StringFilter<"ReviewComment"> | string
    createdAt?: DateTimeFilter<"ReviewComment"> | Date | string
  }

  export type ReviewFavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewFavoriteWhereUniqueInput
    update: XOR<ReviewFavoriteUpdateWithoutUserInput, ReviewFavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewFavoriteCreateWithoutUserInput, ReviewFavoriteUncheckedCreateWithoutUserInput>
  }

  export type ReviewFavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewFavoriteWhereUniqueInput
    data: XOR<ReviewFavoriteUpdateWithoutUserInput, ReviewFavoriteUncheckedUpdateWithoutUserInput>
  }

  export type ReviewFavoriteUpdateManyWithWhereWithoutUserInput = {
    where: ReviewFavoriteScalarWhereInput
    data: XOR<ReviewFavoriteUpdateManyMutationInput, ReviewFavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewFavoriteScalarWhereInput = {
    AND?: ReviewFavoriteScalarWhereInput | ReviewFavoriteScalarWhereInput[]
    OR?: ReviewFavoriteScalarWhereInput[]
    NOT?: ReviewFavoriteScalarWhereInput | ReviewFavoriteScalarWhereInput[]
    reviewId?: StringFilter<"ReviewFavorite"> | string
    userId?: StringFilter<"ReviewFavorite"> | string
  }

  export type MovieListUpsertWithWhereUniqueWithoutUserInput = {
    where: MovieListWhereUniqueInput
    update: XOR<MovieListUpdateWithoutUserInput, MovieListUncheckedUpdateWithoutUserInput>
    create: XOR<MovieListCreateWithoutUserInput, MovieListUncheckedCreateWithoutUserInput>
  }

  export type MovieListUpdateWithWhereUniqueWithoutUserInput = {
    where: MovieListWhereUniqueInput
    data: XOR<MovieListUpdateWithoutUserInput, MovieListUncheckedUpdateWithoutUserInput>
  }

  export type MovieListUpdateManyWithWhereWithoutUserInput = {
    where: MovieListScalarWhereInput
    data: XOR<MovieListUpdateManyMutationInput, MovieListUncheckedUpdateManyWithoutUserInput>
  }

  export type MovieListScalarWhereInput = {
    AND?: MovieListScalarWhereInput | MovieListScalarWhereInput[]
    OR?: MovieListScalarWhereInput[]
    NOT?: MovieListScalarWhereInput | MovieListScalarWhereInput[]
    id?: StringFilter<"MovieList"> | string
    userId?: StringFilter<"MovieList"> | string
    title?: StringFilter<"MovieList"> | string
    description?: StringNullableFilter<"MovieList"> | string | null
    tags?: StringNullableFilter<"MovieList"> | string | null
    isRanked?: BoolFilter<"MovieList"> | boolean
    isSystem?: BoolFilter<"MovieList"> | boolean
    systemKey?: StringNullableFilter<"MovieList"> | string | null
    isPublic?: BoolFilter<"MovieList"> | boolean
    sourceListId?: StringNullableFilter<"MovieList"> | string | null
    sourceType?: StringNullableFilter<"MovieList"> | string | null
    createdAt?: DateTimeFilter<"MovieList"> | Date | string
    updatedAt?: DateTimeFilter<"MovieList"> | Date | string
  }

  export type BallotUpsertWithWhereUniqueWithoutUserInput = {
    where: BallotWhereUniqueInput
    update: XOR<BallotUpdateWithoutUserInput, BallotUncheckedUpdateWithoutUserInput>
    create: XOR<BallotCreateWithoutUserInput, BallotUncheckedCreateWithoutUserInput>
  }

  export type BallotUpdateWithWhereUniqueWithoutUserInput = {
    where: BallotWhereUniqueInput
    data: XOR<BallotUpdateWithoutUserInput, BallotUncheckedUpdateWithoutUserInput>
  }

  export type BallotUpdateManyWithWhereWithoutUserInput = {
    where: BallotScalarWhereInput
    data: XOR<BallotUpdateManyMutationInput, BallotUncheckedUpdateManyWithoutUserInput>
  }

  export type BallotScalarWhereInput = {
    AND?: BallotScalarWhereInput | BallotScalarWhereInput[]
    OR?: BallotScalarWhereInput[]
    NOT?: BallotScalarWhereInput | BallotScalarWhereInput[]
    id?: StringFilter<"Ballot"> | string
    userId?: StringFilter<"Ballot"> | string
    eventYear?: IntFilter<"Ballot"> | number
    category?: StringFilter<"Ballot"> | string
    nomineeId?: StringFilter<"Ballot"> | string
    nomineeName?: StringFilter<"Ballot"> | string
    isWinner?: BoolFilter<"Ballot"> | boolean
    createdAt?: DateTimeFilter<"Ballot"> | Date | string
    updatedAt?: DateTimeFilter<"Ballot"> | Date | string
  }

  export type StreamingSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: StreamingSubscriptionWhereUniqueInput
    update: XOR<StreamingSubscriptionUpdateWithoutUserInput, StreamingSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<StreamingSubscriptionCreateWithoutUserInput, StreamingSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type StreamingSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: StreamingSubscriptionWhereUniqueInput
    data: XOR<StreamingSubscriptionUpdateWithoutUserInput, StreamingSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type StreamingSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: StreamingSubscriptionScalarWhereInput
    data: XOR<StreamingSubscriptionUpdateManyMutationInput, StreamingSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type StreamingSubscriptionScalarWhereInput = {
    AND?: StreamingSubscriptionScalarWhereInput | StreamingSubscriptionScalarWhereInput[]
    OR?: StreamingSubscriptionScalarWhereInput[]
    NOT?: StreamingSubscriptionScalarWhereInput | StreamingSubscriptionScalarWhereInput[]
    id?: StringFilter<"StreamingSubscription"> | string
    userId?: StringFilter<"StreamingSubscription"> | string
    providerId?: IntFilter<"StreamingSubscription"> | number
    name?: StringFilter<"StreamingSubscription"> | string
    logoPath?: StringNullableFilter<"StreamingSubscription"> | string | null
    createdAt?: DateTimeFilter<"StreamingSubscription"> | Date | string
  }

  export type ImportRunUpsertWithWhereUniqueWithoutUserInput = {
    where: ImportRunWhereUniqueInput
    update: XOR<ImportRunUpdateWithoutUserInput, ImportRunUncheckedUpdateWithoutUserInput>
    create: XOR<ImportRunCreateWithoutUserInput, ImportRunUncheckedCreateWithoutUserInput>
  }

  export type ImportRunUpdateWithWhereUniqueWithoutUserInput = {
    where: ImportRunWhereUniqueInput
    data: XOR<ImportRunUpdateWithoutUserInput, ImportRunUncheckedUpdateWithoutUserInput>
  }

  export type ImportRunUpdateManyWithWhereWithoutUserInput = {
    where: ImportRunScalarWhereInput
    data: XOR<ImportRunUpdateManyMutationInput, ImportRunUncheckedUpdateManyWithoutUserInput>
  }

  export type ImportRunScalarWhereInput = {
    AND?: ImportRunScalarWhereInput | ImportRunScalarWhereInput[]
    OR?: ImportRunScalarWhereInput[]
    NOT?: ImportRunScalarWhereInput | ImportRunScalarWhereInput[]
    id?: StringFilter<"ImportRun"> | string
    userId?: StringFilter<"ImportRun"> | string
    source?: StringFilter<"ImportRun"> | string
    status?: StringFilter<"ImportRun"> | string
    createdAt?: DateTimeFilter<"ImportRun"> | Date | string
    updatedAt?: DateTimeFilter<"ImportRun"> | Date | string
  }

  export type UserTopTenUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTopTenWhereUniqueInput
    update: XOR<UserTopTenUpdateWithoutUserInput, UserTopTenUncheckedUpdateWithoutUserInput>
    create: XOR<UserTopTenCreateWithoutUserInput, UserTopTenUncheckedCreateWithoutUserInput>
  }

  export type UserTopTenUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTopTenWhereUniqueInput
    data: XOR<UserTopTenUpdateWithoutUserInput, UserTopTenUncheckedUpdateWithoutUserInput>
  }

  export type UserTopTenUpdateManyWithWhereWithoutUserInput = {
    where: UserTopTenScalarWhereInput
    data: XOR<UserTopTenUpdateManyMutationInput, UserTopTenUncheckedUpdateManyWithoutUserInput>
  }

  export type UserTopTenScalarWhereInput = {
    AND?: UserTopTenScalarWhereInput | UserTopTenScalarWhereInput[]
    OR?: UserTopTenScalarWhereInput[]
    NOT?: UserTopTenScalarWhereInput | UserTopTenScalarWhereInput[]
    id?: StringFilter<"UserTopTen"> | string
    userId?: StringFilter<"UserTopTen"> | string
    tmdbId?: IntFilter<"UserTopTen"> | number
    position?: IntFilter<"UserTopTen"> | number
    createdAt?: DateTimeFilter<"UserTopTen"> | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    providerMode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    runtimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    providerMode?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    runtimeMin?: NullableIntFieldUpdateOperationsInput | number | null
    runtimeMax?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingStateUpsertWithoutUserInput = {
    update: XOR<OnboardingStateUpdateWithoutUserInput, OnboardingStateUncheckedUpdateWithoutUserInput>
    create: XOR<OnboardingStateCreateWithoutUserInput, OnboardingStateUncheckedCreateWithoutUserInput>
    where?: OnboardingStateWhereInput
  }

  export type OnboardingStateUpdateToOneWithWhereWithoutUserInput = {
    where?: OnboardingStateWhereInput
    data: XOR<OnboardingStateUpdateWithoutUserInput, OnboardingStateUncheckedUpdateWithoutUserInput>
  }

  export type OnboardingStateUpdateWithoutUserInput = {
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNudgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OnboardingStateUncheckedUpdateWithoutUserInput = {
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastNudgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferredGenreUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPreferredGenreWhereUniqueInput
    update: XOR<UserPreferredGenreUpdateWithoutUserInput, UserPreferredGenreUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferredGenreCreateWithoutUserInput, UserPreferredGenreUncheckedCreateWithoutUserInput>
  }

  export type UserPreferredGenreUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPreferredGenreWhereUniqueInput
    data: XOR<UserPreferredGenreUpdateWithoutUserInput, UserPreferredGenreUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferredGenreUpdateManyWithWhereWithoutUserInput = {
    where: UserPreferredGenreScalarWhereInput
    data: XOR<UserPreferredGenreUpdateManyMutationInput, UserPreferredGenreUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPreferredGenreScalarWhereInput = {
    AND?: UserPreferredGenreScalarWhereInput | UserPreferredGenreScalarWhereInput[]
    OR?: UserPreferredGenreScalarWhereInput[]
    NOT?: UserPreferredGenreScalarWhereInput | UserPreferredGenreScalarWhereInput[]
    userId?: StringFilter<"UserPreferredGenre"> | string
    genreId?: IntFilter<"UserPreferredGenre"> | number
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInteractionsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInteractionsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInteractionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
  }

  export type MovieCreateWithoutInteractionsInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    winners?: AwardWinnerCreateNestedManyWithoutMovieInput
    watchLogs?: WatchLogCreateNestedManyWithoutMovieInput
    listItems?: MovieListItemCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutInteractionsInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    winners?: AwardWinnerUncheckedCreateNestedManyWithoutMovieInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutMovieInput
    listItems?: MovieListItemUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutInteractionsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutInteractionsInput, MovieUncheckedCreateWithoutInteractionsInput>
  }

  export type UserUpsertWithoutInteractionsInput = {
    update: XOR<UserUpdateWithoutInteractionsInput, UserUncheckedUpdateWithoutInteractionsInput>
    create: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInteractionsInput, UserUncheckedUpdateWithoutInteractionsInput>
  }

  export type UserUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MovieUpsertWithoutInteractionsInput = {
    update: XOR<MovieUpdateWithoutInteractionsInput, MovieUncheckedUpdateWithoutInteractionsInput>
    create: XOR<MovieCreateWithoutInteractionsInput, MovieUncheckedCreateWithoutInteractionsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutInteractionsInput, MovieUncheckedUpdateWithoutInteractionsInput>
  }

  export type MovieUpdateWithoutInteractionsInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    winners?: AwardWinnerUpdateManyWithoutMovieNestedInput
    watchLogs?: WatchLogUpdateManyWithoutMovieNestedInput
    listItems?: MovieListItemUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutInteractionsInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    winners?: AwardWinnerUncheckedUpdateManyWithoutMovieNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutMovieNestedInput
    listItems?: MovieListItemUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type UserCreateWithoutWatchLogsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWatchLogsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWatchLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchLogsInput, UserUncheckedCreateWithoutWatchLogsInput>
  }

  export type ImportRunCreateWithoutWatchLogsInput = {
    id?: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutImportRunsInput
    auditRows?: ImportAuditRowCreateNestedManyWithoutImportRunInput
  }

  export type ImportRunUncheckedCreateWithoutWatchLogsInput = {
    id?: string
    userId: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auditRows?: ImportAuditRowUncheckedCreateNestedManyWithoutImportRunInput
  }

  export type ImportRunCreateOrConnectWithoutWatchLogsInput = {
    where: ImportRunWhereUniqueInput
    create: XOR<ImportRunCreateWithoutWatchLogsInput, ImportRunUncheckedCreateWithoutWatchLogsInput>
  }

  export type MovieCreateWithoutWatchLogsInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    winners?: AwardWinnerCreateNestedManyWithoutMovieInput
    interactions?: MovieInteractionCreateNestedManyWithoutMovieInput
    listItems?: MovieListItemCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutWatchLogsInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    winners?: AwardWinnerUncheckedCreateNestedManyWithoutMovieInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutMovieInput
    listItems?: MovieListItemUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutWatchLogsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutWatchLogsInput, MovieUncheckedCreateWithoutWatchLogsInput>
  }

  export type ReviewCreateWithoutWatchLogInput = {
    id?: string
    movieId: number
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    comments?: ReviewCommentCreateNestedManyWithoutReviewInput
    favorites?: ReviewFavoriteCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutWatchLogInput = {
    id?: string
    userId: string
    movieId: number
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ReviewCommentUncheckedCreateNestedManyWithoutReviewInput
    favorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutWatchLogInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutWatchLogInput, ReviewUncheckedCreateWithoutWatchLogInput>
  }

  export type UserUpsertWithoutWatchLogsInput = {
    update: XOR<UserUpdateWithoutWatchLogsInput, UserUncheckedUpdateWithoutWatchLogsInput>
    create: XOR<UserCreateWithoutWatchLogsInput, UserUncheckedCreateWithoutWatchLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWatchLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWatchLogsInput, UserUncheckedUpdateWithoutWatchLogsInput>
  }

  export type UserUpdateWithoutWatchLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImportRunUpsertWithoutWatchLogsInput = {
    update: XOR<ImportRunUpdateWithoutWatchLogsInput, ImportRunUncheckedUpdateWithoutWatchLogsInput>
    create: XOR<ImportRunCreateWithoutWatchLogsInput, ImportRunUncheckedCreateWithoutWatchLogsInput>
    where?: ImportRunWhereInput
  }

  export type ImportRunUpdateToOneWithWhereWithoutWatchLogsInput = {
    where?: ImportRunWhereInput
    data: XOR<ImportRunUpdateWithoutWatchLogsInput, ImportRunUncheckedUpdateWithoutWatchLogsInput>
  }

  export type ImportRunUpdateWithoutWatchLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutImportRunsNestedInput
    auditRows?: ImportAuditRowUpdateManyWithoutImportRunNestedInput
  }

  export type ImportRunUncheckedUpdateWithoutWatchLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditRows?: ImportAuditRowUncheckedUpdateManyWithoutImportRunNestedInput
  }

  export type MovieUpsertWithoutWatchLogsInput = {
    update: XOR<MovieUpdateWithoutWatchLogsInput, MovieUncheckedUpdateWithoutWatchLogsInput>
    create: XOR<MovieCreateWithoutWatchLogsInput, MovieUncheckedCreateWithoutWatchLogsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutWatchLogsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutWatchLogsInput, MovieUncheckedUpdateWithoutWatchLogsInput>
  }

  export type MovieUpdateWithoutWatchLogsInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    winners?: AwardWinnerUpdateManyWithoutMovieNestedInput
    interactions?: MovieInteractionUpdateManyWithoutMovieNestedInput
    listItems?: MovieListItemUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutWatchLogsInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    winners?: AwardWinnerUncheckedUpdateManyWithoutMovieNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutMovieNestedInput
    listItems?: MovieListItemUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type ReviewUpsertWithoutWatchLogInput = {
    update: XOR<ReviewUpdateWithoutWatchLogInput, ReviewUncheckedUpdateWithoutWatchLogInput>
    create: XOR<ReviewCreateWithoutWatchLogInput, ReviewUncheckedCreateWithoutWatchLogInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutWatchLogInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutWatchLogInput, ReviewUncheckedUpdateWithoutWatchLogInput>
  }

  export type ReviewUpdateWithoutWatchLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    comments?: ReviewCommentUpdateManyWithoutReviewNestedInput
    favorites?: ReviewFavoriteUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutWatchLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput
    favorites?: ReviewFavoriteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type WatchLogCreateWithoutReviewInput = {
    id?: string
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchLogsInput
    importRun?: ImportRunCreateNestedOneWithoutWatchLogsInput
    movie: MovieCreateNestedOneWithoutWatchLogsInput
  }

  export type WatchLogUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    movieId: number
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importId?: string | null
    importRowId?: string | null
    createdAt?: Date | string
  }

  export type WatchLogCreateOrConnectWithoutReviewInput = {
    where: WatchLogWhereUniqueInput
    create: XOR<WatchLogCreateWithoutReviewInput, WatchLogUncheckedCreateWithoutReviewInput>
  }

  export type ReviewCommentCreateWithoutReviewInput = {
    id?: string
    body: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewCommentsInput
  }

  export type ReviewCommentUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    body: string
    createdAt?: Date | string
  }

  export type ReviewCommentCreateOrConnectWithoutReviewInput = {
    where: ReviewCommentWhereUniqueInput
    create: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput>
  }

  export type ReviewCommentCreateManyReviewInputEnvelope = {
    data: ReviewCommentCreateManyReviewInput | ReviewCommentCreateManyReviewInput[]
  }

  export type ReviewFavoriteCreateWithoutReviewInput = {
    user: UserCreateNestedOneWithoutReviewFavoritesInput
  }

  export type ReviewFavoriteUncheckedCreateWithoutReviewInput = {
    userId: string
  }

  export type ReviewFavoriteCreateOrConnectWithoutReviewInput = {
    where: ReviewFavoriteWhereUniqueInput
    create: XOR<ReviewFavoriteCreateWithoutReviewInput, ReviewFavoriteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewFavoriteCreateManyReviewInputEnvelope = {
    data: ReviewFavoriteCreateManyReviewInput | ReviewFavoriteCreateManyReviewInput[]
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WatchLogUpsertWithoutReviewInput = {
    update: XOR<WatchLogUpdateWithoutReviewInput, WatchLogUncheckedUpdateWithoutReviewInput>
    create: XOR<WatchLogCreateWithoutReviewInput, WatchLogUncheckedCreateWithoutReviewInput>
    where?: WatchLogWhereInput
  }

  export type WatchLogUpdateToOneWithWhereWithoutReviewInput = {
    where?: WatchLogWhereInput
    data: XOR<WatchLogUpdateWithoutReviewInput, WatchLogUncheckedUpdateWithoutReviewInput>
  }

  export type WatchLogUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchLogsNestedInput
    importRun?: ImportRunUpdateOneWithoutWatchLogsNestedInput
    movie?: MovieUpdateOneRequiredWithoutWatchLogsNestedInput
  }

  export type WatchLogUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewCommentWhereUniqueInput
    update: XOR<ReviewCommentUpdateWithoutReviewInput, ReviewCommentUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewCommentCreateWithoutReviewInput, ReviewCommentUncheckedCreateWithoutReviewInput>
  }

  export type ReviewCommentUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewCommentWhereUniqueInput
    data: XOR<ReviewCommentUpdateWithoutReviewInput, ReviewCommentUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewCommentUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewCommentScalarWhereInput
    data: XOR<ReviewCommentUpdateManyMutationInput, ReviewCommentUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewFavoriteUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewFavoriteWhereUniqueInput
    update: XOR<ReviewFavoriteUpdateWithoutReviewInput, ReviewFavoriteUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewFavoriteCreateWithoutReviewInput, ReviewFavoriteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewFavoriteUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewFavoriteWhereUniqueInput
    data: XOR<ReviewFavoriteUpdateWithoutReviewInput, ReviewFavoriteUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewFavoriteUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewFavoriteScalarWhereInput
    data: XOR<ReviewFavoriteUpdateManyMutationInput, ReviewFavoriteUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewCreateWithoutCommentsInput = {
    id?: string
    movieId: number
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    watchLog?: WatchLogCreateNestedOneWithoutReviewInput
    favorites?: ReviewFavoriteCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    movieId: number
    watchLogId?: string | null
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutCommentsInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutCommentsInput, ReviewUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutReviewCommentsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewCommentsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewCommentsInput, UserUncheckedCreateWithoutReviewCommentsInput>
  }

  export type ReviewUpsertWithoutCommentsInput = {
    update: XOR<ReviewUpdateWithoutCommentsInput, ReviewUncheckedUpdateWithoutCommentsInput>
    create: XOR<ReviewCreateWithoutCommentsInput, ReviewUncheckedCreateWithoutCommentsInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutCommentsInput, ReviewUncheckedUpdateWithoutCommentsInput>
  }

  export type ReviewUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    watchLog?: WatchLogUpdateOneWithoutReviewNestedInput
    favorites?: ReviewFavoriteUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchLogId?: NullableStringFieldUpdateOperationsInput | string | null
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorites?: ReviewFavoriteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewCommentsInput = {
    update: XOR<UserUpdateWithoutReviewCommentsInput, UserUncheckedUpdateWithoutReviewCommentsInput>
    create: XOR<UserCreateWithoutReviewCommentsInput, UserUncheckedCreateWithoutReviewCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewCommentsInput, UserUncheckedUpdateWithoutReviewCommentsInput>
  }

  export type UserUpdateWithoutReviewCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReviewCreateWithoutFavoritesInput = {
    id?: string
    movieId: number
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    watchLog?: WatchLogCreateNestedOneWithoutReviewInput
    comments?: ReviewCommentCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutFavoritesInput = {
    id?: string
    userId: string
    movieId: number
    watchLogId?: string | null
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ReviewCommentUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutFavoritesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutFavoritesInput, ReviewUncheckedCreateWithoutFavoritesInput>
  }

  export type UserCreateWithoutReviewFavoritesInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewFavoritesInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewFavoritesInput, UserUncheckedCreateWithoutReviewFavoritesInput>
  }

  export type ReviewUpsertWithoutFavoritesInput = {
    update: XOR<ReviewUpdateWithoutFavoritesInput, ReviewUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ReviewCreateWithoutFavoritesInput, ReviewUncheckedCreateWithoutFavoritesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutFavoritesInput, ReviewUncheckedUpdateWithoutFavoritesInput>
  }

  export type ReviewUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    watchLog?: WatchLogUpdateOneWithoutReviewNestedInput
    comments?: ReviewCommentUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchLogId?: NullableStringFieldUpdateOperationsInput | string | null
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewFavoritesInput = {
    update: XOR<UserUpdateWithoutReviewFavoritesInput, UserUncheckedUpdateWithoutReviewFavoritesInput>
    create: XOR<UserCreateWithoutReviewFavoritesInput, UserUncheckedCreateWithoutReviewFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewFavoritesInput, UserUncheckedUpdateWithoutReviewFavoritesInput>
  }

  export type UserUpdateWithoutReviewFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMovieListsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMovieListsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMovieListsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMovieListsInput, UserUncheckedCreateWithoutMovieListsInput>
  }

  export type MovieListItemCreateWithoutListInput = {
    position?: number | null
    note?: string | null
    addedAt?: Date | string
    movie?: MovieCreateNestedOneWithoutListItemsInput
  }

  export type MovieListItemUncheckedCreateWithoutListInput = {
    movieId: number
    position?: number | null
    note?: string | null
    addedAt?: Date | string
  }

  export type MovieListItemCreateOrConnectWithoutListInput = {
    where: MovieListItemWhereUniqueInput
    create: XOR<MovieListItemCreateWithoutListInput, MovieListItemUncheckedCreateWithoutListInput>
  }

  export type MovieListItemCreateManyListInputEnvelope = {
    data: MovieListItemCreateManyListInput | MovieListItemCreateManyListInput[]
  }

  export type UserUpsertWithoutMovieListsInput = {
    update: XOR<UserUpdateWithoutMovieListsInput, UserUncheckedUpdateWithoutMovieListsInput>
    create: XOR<UserCreateWithoutMovieListsInput, UserUncheckedCreateWithoutMovieListsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMovieListsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMovieListsInput, UserUncheckedUpdateWithoutMovieListsInput>
  }

  export type UserUpdateWithoutMovieListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMovieListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MovieListItemUpsertWithWhereUniqueWithoutListInput = {
    where: MovieListItemWhereUniqueInput
    update: XOR<MovieListItemUpdateWithoutListInput, MovieListItemUncheckedUpdateWithoutListInput>
    create: XOR<MovieListItemCreateWithoutListInput, MovieListItemUncheckedCreateWithoutListInput>
  }

  export type MovieListItemUpdateWithWhereUniqueWithoutListInput = {
    where: MovieListItemWhereUniqueInput
    data: XOR<MovieListItemUpdateWithoutListInput, MovieListItemUncheckedUpdateWithoutListInput>
  }

  export type MovieListItemUpdateManyWithWhereWithoutListInput = {
    where: MovieListItemScalarWhereInput
    data: XOR<MovieListItemUpdateManyMutationInput, MovieListItemUncheckedUpdateManyWithoutListInput>
  }

  export type MovieListItemScalarWhereInput = {
    AND?: MovieListItemScalarWhereInput | MovieListItemScalarWhereInput[]
    OR?: MovieListItemScalarWhereInput[]
    NOT?: MovieListItemScalarWhereInput | MovieListItemScalarWhereInput[]
    listId?: StringFilter<"MovieListItem"> | string
    movieId?: IntFilter<"MovieListItem"> | number
    position?: IntNullableFilter<"MovieListItem"> | number | null
    note?: StringNullableFilter<"MovieListItem"> | string | null
    addedAt?: DateTimeFilter<"MovieListItem"> | Date | string
  }

  export type MovieListCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    tags?: string | null
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: string | null
    isPublic?: boolean
    sourceListId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMovieListsInput
  }

  export type MovieListUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    tags?: string | null
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: string | null
    isPublic?: boolean
    sourceListId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieListCreateOrConnectWithoutItemsInput = {
    where: MovieListWhereUniqueInput
    create: XOR<MovieListCreateWithoutItemsInput, MovieListUncheckedCreateWithoutItemsInput>
  }

  export type MovieCreateWithoutListItemsInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    winners?: AwardWinnerCreateNestedManyWithoutMovieInput
    interactions?: MovieInteractionCreateNestedManyWithoutMovieInput
    watchLogs?: WatchLogCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutListItemsInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    winners?: AwardWinnerUncheckedCreateNestedManyWithoutMovieInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutMovieInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutListItemsInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutListItemsInput, MovieUncheckedCreateWithoutListItemsInput>
  }

  export type MovieListUpsertWithoutItemsInput = {
    update: XOR<MovieListUpdateWithoutItemsInput, MovieListUncheckedUpdateWithoutItemsInput>
    create: XOR<MovieListCreateWithoutItemsInput, MovieListUncheckedCreateWithoutItemsInput>
    where?: MovieListWhereInput
  }

  export type MovieListUpdateToOneWithWhereWithoutItemsInput = {
    where?: MovieListWhereInput
    data: XOR<MovieListUpdateWithoutItemsInput, MovieListUncheckedUpdateWithoutItemsInput>
  }

  export type MovieListUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMovieListsNestedInput
  }

  export type MovieListUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieUpsertWithoutListItemsInput = {
    update: XOR<MovieUpdateWithoutListItemsInput, MovieUncheckedUpdateWithoutListItemsInput>
    create: XOR<MovieCreateWithoutListItemsInput, MovieUncheckedCreateWithoutListItemsInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutListItemsInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutListItemsInput, MovieUncheckedUpdateWithoutListItemsInput>
  }

  export type MovieUpdateWithoutListItemsInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    winners?: AwardWinnerUpdateManyWithoutMovieNestedInput
    interactions?: MovieInteractionUpdateManyWithoutMovieNestedInput
    watchLogs?: WatchLogUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutListItemsInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    winners?: AwardWinnerUncheckedUpdateManyWithoutMovieNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutMovieNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type UserCreateWithoutImportRunsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutImportRunsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutImportRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImportRunsInput, UserUncheckedCreateWithoutImportRunsInput>
  }

  export type ImportAuditRowCreateWithoutImportRunInput = {
    id?: string
    fileName: string
    rowNumber: number
    title: string
    year?: number | null
    letterboxdUrl?: string | null
    tmdbMovieId?: number | null
    status?: string
    message?: string | null
    rawJson?: string | null
  }

  export type ImportAuditRowUncheckedCreateWithoutImportRunInput = {
    id?: string
    fileName: string
    rowNumber: number
    title: string
    year?: number | null
    letterboxdUrl?: string | null
    tmdbMovieId?: number | null
    status?: string
    message?: string | null
    rawJson?: string | null
  }

  export type ImportAuditRowCreateOrConnectWithoutImportRunInput = {
    where: ImportAuditRowWhereUniqueInput
    create: XOR<ImportAuditRowCreateWithoutImportRunInput, ImportAuditRowUncheckedCreateWithoutImportRunInput>
  }

  export type ImportAuditRowCreateManyImportRunInputEnvelope = {
    data: ImportAuditRowCreateManyImportRunInput | ImportAuditRowCreateManyImportRunInput[]
  }

  export type WatchLogCreateWithoutImportRunInput = {
    id?: string
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchLogsInput
    movie: MovieCreateNestedOneWithoutWatchLogsInput
    review?: ReviewCreateNestedOneWithoutWatchLogInput
  }

  export type WatchLogUncheckedCreateWithoutImportRunInput = {
    id?: string
    userId: string
    movieId: number
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutWatchLogInput
  }

  export type WatchLogCreateOrConnectWithoutImportRunInput = {
    where: WatchLogWhereUniqueInput
    create: XOR<WatchLogCreateWithoutImportRunInput, WatchLogUncheckedCreateWithoutImportRunInput>
  }

  export type WatchLogCreateManyImportRunInputEnvelope = {
    data: WatchLogCreateManyImportRunInput | WatchLogCreateManyImportRunInput[]
  }

  export type UserUpsertWithoutImportRunsInput = {
    update: XOR<UserUpdateWithoutImportRunsInput, UserUncheckedUpdateWithoutImportRunsInput>
    create: XOR<UserCreateWithoutImportRunsInput, UserUncheckedCreateWithoutImportRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutImportRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutImportRunsInput, UserUncheckedUpdateWithoutImportRunsInput>
  }

  export type UserUpdateWithoutImportRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutImportRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImportAuditRowUpsertWithWhereUniqueWithoutImportRunInput = {
    where: ImportAuditRowWhereUniqueInput
    update: XOR<ImportAuditRowUpdateWithoutImportRunInput, ImportAuditRowUncheckedUpdateWithoutImportRunInput>
    create: XOR<ImportAuditRowCreateWithoutImportRunInput, ImportAuditRowUncheckedCreateWithoutImportRunInput>
  }

  export type ImportAuditRowUpdateWithWhereUniqueWithoutImportRunInput = {
    where: ImportAuditRowWhereUniqueInput
    data: XOR<ImportAuditRowUpdateWithoutImportRunInput, ImportAuditRowUncheckedUpdateWithoutImportRunInput>
  }

  export type ImportAuditRowUpdateManyWithWhereWithoutImportRunInput = {
    where: ImportAuditRowScalarWhereInput
    data: XOR<ImportAuditRowUpdateManyMutationInput, ImportAuditRowUncheckedUpdateManyWithoutImportRunInput>
  }

  export type ImportAuditRowScalarWhereInput = {
    AND?: ImportAuditRowScalarWhereInput | ImportAuditRowScalarWhereInput[]
    OR?: ImportAuditRowScalarWhereInput[]
    NOT?: ImportAuditRowScalarWhereInput | ImportAuditRowScalarWhereInput[]
    id?: StringFilter<"ImportAuditRow"> | string
    importId?: StringFilter<"ImportAuditRow"> | string
    fileName?: StringFilter<"ImportAuditRow"> | string
    rowNumber?: IntFilter<"ImportAuditRow"> | number
    title?: StringFilter<"ImportAuditRow"> | string
    year?: IntNullableFilter<"ImportAuditRow"> | number | null
    letterboxdUrl?: StringNullableFilter<"ImportAuditRow"> | string | null
    tmdbMovieId?: IntNullableFilter<"ImportAuditRow"> | number | null
    status?: StringFilter<"ImportAuditRow"> | string
    message?: StringNullableFilter<"ImportAuditRow"> | string | null
    rawJson?: StringNullableFilter<"ImportAuditRow"> | string | null
  }

  export type WatchLogUpsertWithWhereUniqueWithoutImportRunInput = {
    where: WatchLogWhereUniqueInput
    update: XOR<WatchLogUpdateWithoutImportRunInput, WatchLogUncheckedUpdateWithoutImportRunInput>
    create: XOR<WatchLogCreateWithoutImportRunInput, WatchLogUncheckedCreateWithoutImportRunInput>
  }

  export type WatchLogUpdateWithWhereUniqueWithoutImportRunInput = {
    where: WatchLogWhereUniqueInput
    data: XOR<WatchLogUpdateWithoutImportRunInput, WatchLogUncheckedUpdateWithoutImportRunInput>
  }

  export type WatchLogUpdateManyWithWhereWithoutImportRunInput = {
    where: WatchLogScalarWhereInput
    data: XOR<WatchLogUpdateManyMutationInput, WatchLogUncheckedUpdateManyWithoutImportRunInput>
  }

  export type ImportRunCreateWithoutAuditRowsInput = {
    id?: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutImportRunsInput
    watchLogs?: WatchLogCreateNestedManyWithoutImportRunInput
  }

  export type ImportRunUncheckedCreateWithoutAuditRowsInput = {
    id?: string
    userId: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutImportRunInput
  }

  export type ImportRunCreateOrConnectWithoutAuditRowsInput = {
    where: ImportRunWhereUniqueInput
    create: XOR<ImportRunCreateWithoutAuditRowsInput, ImportRunUncheckedCreateWithoutAuditRowsInput>
  }

  export type ImportRunUpsertWithoutAuditRowsInput = {
    update: XOR<ImportRunUpdateWithoutAuditRowsInput, ImportRunUncheckedUpdateWithoutAuditRowsInput>
    create: XOR<ImportRunCreateWithoutAuditRowsInput, ImportRunUncheckedCreateWithoutAuditRowsInput>
    where?: ImportRunWhereInput
  }

  export type ImportRunUpdateToOneWithWhereWithoutAuditRowsInput = {
    where?: ImportRunWhereInput
    data: XOR<ImportRunUpdateWithoutAuditRowsInput, ImportRunUncheckedUpdateWithoutAuditRowsInput>
  }

  export type ImportRunUpdateWithoutAuditRowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutImportRunsNestedInput
    watchLogs?: WatchLogUpdateManyWithoutImportRunNestedInput
  }

  export type ImportRunUncheckedUpdateWithoutAuditRowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchLogs?: WatchLogUncheckedUpdateManyWithoutImportRunNestedInput
  }

  export type UserCreateWithoutBallotsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBallotsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBallotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBallotsInput, UserUncheckedCreateWithoutBallotsInput>
  }

  export type UserUpsertWithoutBallotsInput = {
    update: XOR<UserUpdateWithoutBallotsInput, UserUncheckedUpdateWithoutBallotsInput>
    create: XOR<UserCreateWithoutBallotsInput, UserUncheckedCreateWithoutBallotsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBallotsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBallotsInput, UserUncheckedUpdateWithoutBallotsInput>
  }

  export type UserUpdateWithoutBallotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBallotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AwardSeasonCreateWithoutEventInput = {
    id?: string
    year: number
    season?: string
    phase?: string
    date?: Date | string | null
    winners?: AwardWinnerCreateNestedManyWithoutSeasonRelInput
  }

  export type AwardSeasonUncheckedCreateWithoutEventInput = {
    id?: string
    year: number
    season?: string
    phase?: string
    date?: Date | string | null
    winners?: AwardWinnerUncheckedCreateNestedManyWithoutSeasonRelInput
  }

  export type AwardSeasonCreateOrConnectWithoutEventInput = {
    where: AwardSeasonWhereUniqueInput
    create: XOR<AwardSeasonCreateWithoutEventInput, AwardSeasonUncheckedCreateWithoutEventInput>
  }

  export type AwardSeasonCreateManyEventInputEnvelope = {
    data: AwardSeasonCreateManyEventInput | AwardSeasonCreateManyEventInput[]
  }

  export type AwardSeasonUpsertWithWhereUniqueWithoutEventInput = {
    where: AwardSeasonWhereUniqueInput
    update: XOR<AwardSeasonUpdateWithoutEventInput, AwardSeasonUncheckedUpdateWithoutEventInput>
    create: XOR<AwardSeasonCreateWithoutEventInput, AwardSeasonUncheckedCreateWithoutEventInput>
  }

  export type AwardSeasonUpdateWithWhereUniqueWithoutEventInput = {
    where: AwardSeasonWhereUniqueInput
    data: XOR<AwardSeasonUpdateWithoutEventInput, AwardSeasonUncheckedUpdateWithoutEventInput>
  }

  export type AwardSeasonUpdateManyWithWhereWithoutEventInput = {
    where: AwardSeasonScalarWhereInput
    data: XOR<AwardSeasonUpdateManyMutationInput, AwardSeasonUncheckedUpdateManyWithoutEventInput>
  }

  export type AwardSeasonScalarWhereInput = {
    AND?: AwardSeasonScalarWhereInput | AwardSeasonScalarWhereInput[]
    OR?: AwardSeasonScalarWhereInput[]
    NOT?: AwardSeasonScalarWhereInput | AwardSeasonScalarWhereInput[]
    id?: StringFilter<"AwardSeason"> | string
    eventId?: StringFilter<"AwardSeason"> | string
    year?: IntFilter<"AwardSeason"> | number
    season?: StringFilter<"AwardSeason"> | string
    phase?: StringFilter<"AwardSeason"> | string
    date?: DateTimeNullableFilter<"AwardSeason"> | Date | string | null
  }

  export type AwardEventCreateWithoutSeasonsInput = {
    id?: string
    name: string
    slug: string
    type: string
  }

  export type AwardEventUncheckedCreateWithoutSeasonsInput = {
    id?: string
    name: string
    slug: string
    type: string
  }

  export type AwardEventCreateOrConnectWithoutSeasonsInput = {
    where: AwardEventWhereUniqueInput
    create: XOR<AwardEventCreateWithoutSeasonsInput, AwardEventUncheckedCreateWithoutSeasonsInput>
  }

  export type AwardWinnerCreateWithoutSeasonRelInput = {
    id?: string
    prizeName: string
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
    movie: MovieCreateNestedOneWithoutWinnersInput
  }

  export type AwardWinnerUncheckedCreateWithoutSeasonRelInput = {
    id?: string
    prizeName: string
    movieId: number
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
  }

  export type AwardWinnerCreateOrConnectWithoutSeasonRelInput = {
    where: AwardWinnerWhereUniqueInput
    create: XOR<AwardWinnerCreateWithoutSeasonRelInput, AwardWinnerUncheckedCreateWithoutSeasonRelInput>
  }

  export type AwardWinnerCreateManySeasonRelInputEnvelope = {
    data: AwardWinnerCreateManySeasonRelInput | AwardWinnerCreateManySeasonRelInput[]
  }

  export type AwardEventUpsertWithoutSeasonsInput = {
    update: XOR<AwardEventUpdateWithoutSeasonsInput, AwardEventUncheckedUpdateWithoutSeasonsInput>
    create: XOR<AwardEventCreateWithoutSeasonsInput, AwardEventUncheckedCreateWithoutSeasonsInput>
    where?: AwardEventWhereInput
  }

  export type AwardEventUpdateToOneWithWhereWithoutSeasonsInput = {
    where?: AwardEventWhereInput
    data: XOR<AwardEventUpdateWithoutSeasonsInput, AwardEventUncheckedUpdateWithoutSeasonsInput>
  }

  export type AwardEventUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type AwardEventUncheckedUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type AwardWinnerUpsertWithWhereUniqueWithoutSeasonRelInput = {
    where: AwardWinnerWhereUniqueInput
    update: XOR<AwardWinnerUpdateWithoutSeasonRelInput, AwardWinnerUncheckedUpdateWithoutSeasonRelInput>
    create: XOR<AwardWinnerCreateWithoutSeasonRelInput, AwardWinnerUncheckedCreateWithoutSeasonRelInput>
  }

  export type AwardWinnerUpdateWithWhereUniqueWithoutSeasonRelInput = {
    where: AwardWinnerWhereUniqueInput
    data: XOR<AwardWinnerUpdateWithoutSeasonRelInput, AwardWinnerUncheckedUpdateWithoutSeasonRelInput>
  }

  export type AwardWinnerUpdateManyWithWhereWithoutSeasonRelInput = {
    where: AwardWinnerScalarWhereInput
    data: XOR<AwardWinnerUpdateManyMutationInput, AwardWinnerUncheckedUpdateManyWithoutSeasonRelInput>
  }

  export type AwardWinnerScalarWhereInput = {
    AND?: AwardWinnerScalarWhereInput | AwardWinnerScalarWhereInput[]
    OR?: AwardWinnerScalarWhereInput[]
    NOT?: AwardWinnerScalarWhereInput | AwardWinnerScalarWhereInput[]
    id?: StringFilter<"AwardWinner"> | string
    seasonId?: StringFilter<"AwardWinner"> | string
    prizeName?: StringFilter<"AwardWinner"> | string
    movieId?: IntFilter<"AwardWinner"> | number
    movieTitle?: StringFilter<"AwardWinner"> | string
    posterPath?: StringNullableFilter<"AwardWinner"> | string | null
    personName?: StringNullableFilter<"AwardWinner"> | string | null
    personPath?: StringNullableFilter<"AwardWinner"> | string | null
    isWinner?: BoolFilter<"AwardWinner"> | boolean
    sourceUrl?: StringNullableFilter<"AwardWinner"> | string | null
    createdAt?: DateTimeFilter<"AwardWinner"> | Date | string
  }

  export type AwardWinnerCreateWithoutMovieInput = {
    id?: string
    prizeName: string
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
    seasonRel: AwardSeasonCreateNestedOneWithoutWinnersInput
  }

  export type AwardWinnerUncheckedCreateWithoutMovieInput = {
    id?: string
    seasonId: string
    prizeName: string
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
  }

  export type AwardWinnerCreateOrConnectWithoutMovieInput = {
    where: AwardWinnerWhereUniqueInput
    create: XOR<AwardWinnerCreateWithoutMovieInput, AwardWinnerUncheckedCreateWithoutMovieInput>
  }

  export type AwardWinnerCreateManyMovieInputEnvelope = {
    data: AwardWinnerCreateManyMovieInput | AwardWinnerCreateManyMovieInput[]
  }

  export type MovieInteractionCreateWithoutMovieInput = {
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInteractionsInput
  }

  export type MovieInteractionUncheckedCreateWithoutMovieInput = {
    userId: string
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type MovieInteractionCreateOrConnectWithoutMovieInput = {
    where: MovieInteractionWhereUniqueInput
    create: XOR<MovieInteractionCreateWithoutMovieInput, MovieInteractionUncheckedCreateWithoutMovieInput>
  }

  export type MovieInteractionCreateManyMovieInputEnvelope = {
    data: MovieInteractionCreateManyMovieInput | MovieInteractionCreateManyMovieInput[]
  }

  export type WatchLogCreateWithoutMovieInput = {
    id?: string
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWatchLogsInput
    importRun?: ImportRunCreateNestedOneWithoutWatchLogsInput
    review?: ReviewCreateNestedOneWithoutWatchLogInput
  }

  export type WatchLogUncheckedCreateWithoutMovieInput = {
    id?: string
    userId: string
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importId?: string | null
    importRowId?: string | null
    createdAt?: Date | string
    review?: ReviewUncheckedCreateNestedOneWithoutWatchLogInput
  }

  export type WatchLogCreateOrConnectWithoutMovieInput = {
    where: WatchLogWhereUniqueInput
    create: XOR<WatchLogCreateWithoutMovieInput, WatchLogUncheckedCreateWithoutMovieInput>
  }

  export type WatchLogCreateManyMovieInputEnvelope = {
    data: WatchLogCreateManyMovieInput | WatchLogCreateManyMovieInput[]
  }

  export type MovieListItemCreateWithoutMovieInput = {
    position?: number | null
    note?: string | null
    addedAt?: Date | string
    list: MovieListCreateNestedOneWithoutItemsInput
  }

  export type MovieListItemUncheckedCreateWithoutMovieInput = {
    listId: string
    position?: number | null
    note?: string | null
    addedAt?: Date | string
  }

  export type MovieListItemCreateOrConnectWithoutMovieInput = {
    where: MovieListItemWhereUniqueInput
    create: XOR<MovieListItemCreateWithoutMovieInput, MovieListItemUncheckedCreateWithoutMovieInput>
  }

  export type MovieListItemCreateManyMovieInputEnvelope = {
    data: MovieListItemCreateManyMovieInput | MovieListItemCreateManyMovieInput[]
  }

  export type AwardWinnerUpsertWithWhereUniqueWithoutMovieInput = {
    where: AwardWinnerWhereUniqueInput
    update: XOR<AwardWinnerUpdateWithoutMovieInput, AwardWinnerUncheckedUpdateWithoutMovieInput>
    create: XOR<AwardWinnerCreateWithoutMovieInput, AwardWinnerUncheckedCreateWithoutMovieInput>
  }

  export type AwardWinnerUpdateWithWhereUniqueWithoutMovieInput = {
    where: AwardWinnerWhereUniqueInput
    data: XOR<AwardWinnerUpdateWithoutMovieInput, AwardWinnerUncheckedUpdateWithoutMovieInput>
  }

  export type AwardWinnerUpdateManyWithWhereWithoutMovieInput = {
    where: AwardWinnerScalarWhereInput
    data: XOR<AwardWinnerUpdateManyMutationInput, AwardWinnerUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieInteractionUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieInteractionWhereUniqueInput
    update: XOR<MovieInteractionUpdateWithoutMovieInput, MovieInteractionUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieInteractionCreateWithoutMovieInput, MovieInteractionUncheckedCreateWithoutMovieInput>
  }

  export type MovieInteractionUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieInteractionWhereUniqueInput
    data: XOR<MovieInteractionUpdateWithoutMovieInput, MovieInteractionUncheckedUpdateWithoutMovieInput>
  }

  export type MovieInteractionUpdateManyWithWhereWithoutMovieInput = {
    where: MovieInteractionScalarWhereInput
    data: XOR<MovieInteractionUpdateManyMutationInput, MovieInteractionUncheckedUpdateManyWithoutMovieInput>
  }

  export type WatchLogUpsertWithWhereUniqueWithoutMovieInput = {
    where: WatchLogWhereUniqueInput
    update: XOR<WatchLogUpdateWithoutMovieInput, WatchLogUncheckedUpdateWithoutMovieInput>
    create: XOR<WatchLogCreateWithoutMovieInput, WatchLogUncheckedCreateWithoutMovieInput>
  }

  export type WatchLogUpdateWithWhereUniqueWithoutMovieInput = {
    where: WatchLogWhereUniqueInput
    data: XOR<WatchLogUpdateWithoutMovieInput, WatchLogUncheckedUpdateWithoutMovieInput>
  }

  export type WatchLogUpdateManyWithWhereWithoutMovieInput = {
    where: WatchLogScalarWhereInput
    data: XOR<WatchLogUpdateManyMutationInput, WatchLogUncheckedUpdateManyWithoutMovieInput>
  }

  export type MovieListItemUpsertWithWhereUniqueWithoutMovieInput = {
    where: MovieListItemWhereUniqueInput
    update: XOR<MovieListItemUpdateWithoutMovieInput, MovieListItemUncheckedUpdateWithoutMovieInput>
    create: XOR<MovieListItemCreateWithoutMovieInput, MovieListItemUncheckedCreateWithoutMovieInput>
  }

  export type MovieListItemUpdateWithWhereUniqueWithoutMovieInput = {
    where: MovieListItemWhereUniqueInput
    data: XOR<MovieListItemUpdateWithoutMovieInput, MovieListItemUncheckedUpdateWithoutMovieInput>
  }

  export type MovieListItemUpdateManyWithWhereWithoutMovieInput = {
    where: MovieListItemScalarWhereInput
    data: XOR<MovieListItemUpdateManyMutationInput, MovieListItemUncheckedUpdateManyWithoutMovieInput>
  }

  export type AwardSeasonCreateWithoutWinnersInput = {
    id?: string
    year: number
    season?: string
    phase?: string
    date?: Date | string | null
    event: AwardEventCreateNestedOneWithoutSeasonsInput
  }

  export type AwardSeasonUncheckedCreateWithoutWinnersInput = {
    id?: string
    eventId: string
    year: number
    season?: string
    phase?: string
    date?: Date | string | null
  }

  export type AwardSeasonCreateOrConnectWithoutWinnersInput = {
    where: AwardSeasonWhereUniqueInput
    create: XOR<AwardSeasonCreateWithoutWinnersInput, AwardSeasonUncheckedCreateWithoutWinnersInput>
  }

  export type MovieCreateWithoutWinnersInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    interactions?: MovieInteractionCreateNestedManyWithoutMovieInput
    watchLogs?: WatchLogCreateNestedManyWithoutMovieInput
    listItems?: MovieListItemCreateNestedManyWithoutMovieInput
  }

  export type MovieUncheckedCreateWithoutWinnersInput = {
    tmdbId: number
    title: string
    posterPath?: string | null
    backdropPath?: string | null
    eligibleDate?: Date | string | null
    eligibilityYear?: number | null
    seasonKey?: string | null
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutMovieInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutMovieInput
    listItems?: MovieListItemUncheckedCreateNestedManyWithoutMovieInput
  }

  export type MovieCreateOrConnectWithoutWinnersInput = {
    where: MovieWhereUniqueInput
    create: XOR<MovieCreateWithoutWinnersInput, MovieUncheckedCreateWithoutWinnersInput>
  }

  export type AwardSeasonUpsertWithoutWinnersInput = {
    update: XOR<AwardSeasonUpdateWithoutWinnersInput, AwardSeasonUncheckedUpdateWithoutWinnersInput>
    create: XOR<AwardSeasonCreateWithoutWinnersInput, AwardSeasonUncheckedCreateWithoutWinnersInput>
    where?: AwardSeasonWhereInput
  }

  export type AwardSeasonUpdateToOneWithWhereWithoutWinnersInput = {
    where?: AwardSeasonWhereInput
    data: XOR<AwardSeasonUpdateWithoutWinnersInput, AwardSeasonUncheckedUpdateWithoutWinnersInput>
  }

  export type AwardSeasonUpdateWithoutWinnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: AwardEventUpdateOneRequiredWithoutSeasonsNestedInput
  }

  export type AwardSeasonUncheckedUpdateWithoutWinnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MovieUpsertWithoutWinnersInput = {
    update: XOR<MovieUpdateWithoutWinnersInput, MovieUncheckedUpdateWithoutWinnersInput>
    create: XOR<MovieCreateWithoutWinnersInput, MovieUncheckedCreateWithoutWinnersInput>
    where?: MovieWhereInput
  }

  export type MovieUpdateToOneWithWhereWithoutWinnersInput = {
    where?: MovieWhereInput
    data: XOR<MovieUpdateWithoutWinnersInput, MovieUncheckedUpdateWithoutWinnersInput>
  }

  export type MovieUpdateWithoutWinnersInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: MovieInteractionUpdateManyWithoutMovieNestedInput
    watchLogs?: WatchLogUpdateManyWithoutMovieNestedInput
    listItems?: MovieListItemUpdateManyWithoutMovieNestedInput
  }

  export type MovieUncheckedUpdateWithoutWinnersInput = {
    tmdbId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    backdropPath?: NullableStringFieldUpdateOperationsInput | string | null
    eligibleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilityYear?: NullableIntFieldUpdateOperationsInput | number | null
    seasonKey?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: MovieInteractionUncheckedUpdateManyWithoutMovieNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutMovieNestedInput
    listItems?: MovieListItemUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOnboardingInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOnboardingInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOnboardingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
  }

  export type UserUpsertWithoutOnboardingInput = {
    update: XOR<UserUpdateWithoutOnboardingInput, UserUncheckedUpdateWithoutOnboardingInput>
    create: XOR<UserCreateWithoutOnboardingInput, UserUncheckedCreateWithoutOnboardingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOnboardingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOnboardingInput, UserUncheckedUpdateWithoutOnboardingInput>
  }

  export type UserUpdateWithoutOnboardingInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOnboardingInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPreferredGenresInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    topTen?: UserTopTenCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferredGenresInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    topTen?: UserTopTenUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferredGenresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferredGenresInput, UserUncheckedCreateWithoutPreferredGenresInput>
  }

  export type UserUpsertWithoutPreferredGenresInput = {
    update: XOR<UserUpdateWithoutPreferredGenresInput, UserUncheckedUpdateWithoutPreferredGenresInput>
    create: XOR<UserCreateWithoutPreferredGenresInput, UserUncheckedCreateWithoutPreferredGenresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferredGenresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferredGenresInput, UserUncheckedUpdateWithoutPreferredGenresInput>
  }

  export type UserUpdateWithoutPreferredGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferredGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    topTen?: UserTopTenUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutTopTenInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteCreateNestedManyWithoutUserInput
    movieLists?: MovieListCreateNestedManyWithoutUserInput
    ballots?: BallotCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionCreateNestedManyWithoutUserInput
    importRuns?: ImportRunCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTopTenInput = {
    id?: string
    clerkId?: string | null
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    interactions?: MovieInteractionUncheckedCreateNestedManyWithoutUserInput
    watchLogs?: WatchLogUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewComments?: ReviewCommentUncheckedCreateNestedManyWithoutUserInput
    reviewFavorites?: ReviewFavoriteUncheckedCreateNestedManyWithoutUserInput
    movieLists?: MovieListUncheckedCreateNestedManyWithoutUserInput
    ballots?: BallotUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: StreamingSubscriptionUncheckedCreateNestedManyWithoutUserInput
    importRuns?: ImportRunUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    onboarding?: OnboardingStateUncheckedCreateNestedOneWithoutUserInput
    preferredGenres?: UserPreferredGenreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTopTenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTopTenInput, UserUncheckedCreateWithoutTopTenInput>
  }

  export type UserUpsertWithoutTopTenInput = {
    update: XOR<UserUpdateWithoutTopTenInput, UserUncheckedUpdateWithoutTopTenInput>
    create: XOR<UserCreateWithoutTopTenInput, UserUncheckedCreateWithoutTopTenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTopTenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTopTenInput, UserUncheckedUpdateWithoutTopTenInput>
  }

  export type UserUpdateWithoutTopTenInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUpdateManyWithoutUserNestedInput
    ballots?: BallotUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTopTenInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    interactions?: MovieInteractionUncheckedUpdateManyWithoutUserNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewComments?: ReviewCommentUncheckedUpdateManyWithoutUserNestedInput
    reviewFavorites?: ReviewFavoriteUncheckedUpdateManyWithoutUserNestedInput
    movieLists?: MovieListUncheckedUpdateManyWithoutUserNestedInput
    ballots?: BallotUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: StreamingSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    importRuns?: ImportRunUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    onboarding?: OnboardingStateUncheckedUpdateOneWithoutUserNestedInput
    preferredGenres?: UserPreferredGenreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MovieInteractionCreateManyUserInput = {
    movieId: number
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type WatchLogCreateManyUserInput = {
    id?: string
    movieId: number
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importId?: string | null
    importRowId?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    movieId: number
    watchLogId?: string | null
    bodyRaw: string
    bodyFormat?: string
    ratingHalf?: number | null
    tags?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCommentCreateManyUserInput = {
    id?: string
    reviewId: string
    body: string
    createdAt?: Date | string
  }

  export type ReviewFavoriteCreateManyUserInput = {
    reviewId: string
  }

  export type MovieListCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    tags?: string | null
    isRanked?: boolean
    isSystem?: boolean
    systemKey?: string | null
    isPublic?: boolean
    sourceListId?: string | null
    sourceType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BallotCreateManyUserInput = {
    id?: string
    eventYear: number
    category: string
    nomineeId: string
    nomineeName: string
    isWinner?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreamingSubscriptionCreateManyUserInput = {
    id?: string
    providerId: number
    name: string
    logoPath?: string | null
    createdAt?: Date | string
  }

  export type ImportRunCreateManyUserInput = {
    id?: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTopTenCreateManyUserInput = {
    id?: string
    tmdbId: number
    position: number
    createdAt?: Date | string
  }

  export type UserPreferredGenreCreateManyUserInput = {
    genreId: number
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieInteractionUpdateWithoutUserInput = {
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneWithoutInteractionsNestedInput
  }

  export type MovieInteractionUncheckedUpdateWithoutUserInput = {
    movieId?: IntFieldUpdateOperationsInput | number
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieInteractionUncheckedUpdateManyWithoutUserInput = {
    movieId?: IntFieldUpdateOperationsInput | number
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    importRun?: ImportRunUpdateOneWithoutWatchLogsNestedInput
    movie?: MovieUpdateOneRequiredWithoutWatchLogsNestedInput
    review?: ReviewUpdateOneWithoutWatchLogNestedInput
  }

  export type WatchLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutWatchLogNestedInput
  }

  export type WatchLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    watchLog?: WatchLogUpdateOneWithoutReviewNestedInput
    comments?: ReviewCommentUpdateManyWithoutReviewNestedInput
    favorites?: ReviewFavoriteUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchLogId?: NullableStringFieldUpdateOperationsInput | string | null
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ReviewCommentUncheckedUpdateManyWithoutReviewNestedInput
    favorites?: ReviewFavoriteUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchLogId?: NullableStringFieldUpdateOperationsInput | string | null
    bodyRaw?: StringFieldUpdateOperationsInput | string
    bodyFormat?: StringFieldUpdateOperationsInput | string
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ReviewCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewFavoriteUpdateWithoutUserInput = {
    review?: ReviewUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type ReviewFavoriteUncheckedUpdateWithoutUserInput = {
    reviewId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewFavoriteUncheckedUpdateManyWithoutUserInput = {
    reviewId?: StringFieldUpdateOperationsInput | string
  }

  export type MovieListUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MovieListItemUpdateManyWithoutListNestedInput
  }

  export type MovieListUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MovieListItemUncheckedUpdateManyWithoutListNestedInput
  }

  export type MovieListUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isRanked?: BoolFieldUpdateOperationsInput | boolean
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    systemKey?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sourceListId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BallotUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventYear?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    nomineeId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BallotUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventYear?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    nomineeId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BallotUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventYear?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    nomineeId?: StringFieldUpdateOperationsInput | string
    nomineeName?: StringFieldUpdateOperationsInput | string
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamingSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamingSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreamingSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logoPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportRunUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditRows?: ImportAuditRowUpdateManyWithoutImportRunNestedInput
    watchLogs?: WatchLogUpdateManyWithoutImportRunNestedInput
  }

  export type ImportRunUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditRows?: ImportAuditRowUncheckedUpdateManyWithoutImportRunNestedInput
    watchLogs?: WatchLogUncheckedUpdateManyWithoutImportRunNestedInput
  }

  export type ImportRunUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTopTenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTopTenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTopTenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tmdbId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferredGenreUpdateWithoutUserInput = {
    genreId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPreferredGenreUncheckedUpdateWithoutUserInput = {
    genreId?: IntFieldUpdateOperationsInput | number
  }

  export type UserPreferredGenreUncheckedUpdateManyWithoutUserInput = {
    genreId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCommentCreateManyReviewInput = {
    id?: string
    userId: string
    body: string
    createdAt?: Date | string
  }

  export type ReviewFavoriteCreateManyReviewInput = {
    userId: string
  }

  export type ReviewCommentUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewCommentsNestedInput
  }

  export type ReviewCommentUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCommentUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewFavoriteUpdateWithoutReviewInput = {
    user?: UserUpdateOneRequiredWithoutReviewFavoritesNestedInput
  }

  export type ReviewFavoriteUncheckedUpdateWithoutReviewInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewFavoriteUncheckedUpdateManyWithoutReviewInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MovieListItemCreateManyListInput = {
    movieId: number
    position?: number | null
    note?: string | null
    addedAt?: Date | string
  }

  export type MovieListItemUpdateWithoutListInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneWithoutListItemsNestedInput
  }

  export type MovieListItemUncheckedUpdateWithoutListInput = {
    movieId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieListItemUncheckedUpdateManyWithoutListInput = {
    movieId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportAuditRowCreateManyImportRunInput = {
    id?: string
    fileName: string
    rowNumber: number
    title: string
    year?: number | null
    letterboxdUrl?: string | null
    tmdbMovieId?: number | null
    status?: string
    message?: string | null
    rawJson?: string | null
  }

  export type WatchLogCreateManyImportRunInput = {
    id?: string
    userId: string
    movieId: number
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importRowId?: string | null
    createdAt?: Date | string
  }

  export type ImportAuditRowUpdateWithoutImportRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    letterboxdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tmdbMovieId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportAuditRowUncheckedUpdateWithoutImportRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    letterboxdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tmdbMovieId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportAuditRowUncheckedUpdateManyWithoutImportRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    rowNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    letterboxdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tmdbMovieId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WatchLogUpdateWithoutImportRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchLogsNestedInput
    movie?: MovieUpdateOneRequiredWithoutWatchLogsNestedInput
    review?: ReviewUpdateOneWithoutWatchLogNestedInput
  }

  export type WatchLogUncheckedUpdateWithoutImportRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutWatchLogNestedInput
  }

  export type WatchLogUncheckedUpdateManyWithoutImportRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwardSeasonCreateManyEventInput = {
    id?: string
    year: number
    season?: string
    phase?: string
    date?: Date | string | null
  }

  export type AwardSeasonUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winners?: AwardWinnerUpdateManyWithoutSeasonRelNestedInput
  }

  export type AwardSeasonUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    winners?: AwardWinnerUncheckedUpdateManyWithoutSeasonRelNestedInput
  }

  export type AwardSeasonUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    season?: StringFieldUpdateOperationsInput | string
    phase?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AwardWinnerCreateManySeasonRelInput = {
    id?: string
    prizeName: string
    movieId: number
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
  }

  export type AwardWinnerUpdateWithoutSeasonRelInput = {
    id?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movie?: MovieUpdateOneRequiredWithoutWinnersNestedInput
  }

  export type AwardWinnerUncheckedUpdateWithoutSeasonRelInput = {
    id?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwardWinnerUncheckedUpdateManyWithoutSeasonRelInput = {
    id?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieId?: IntFieldUpdateOperationsInput | number
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwardWinnerCreateManyMovieInput = {
    id?: string
    seasonId: string
    prizeName: string
    movieTitle: string
    posterPath?: string | null
    personName?: string | null
    personPath?: string | null
    isWinner?: boolean
    sourceUrl?: string | null
    createdAt?: Date | string
  }

  export type MovieInteractionCreateManyMovieInput = {
    userId: string
    watched?: boolean
    watchlisted?: boolean
    favorited?: boolean
    ratingHalf?: number | null
    ratedAt?: Date | string | null
    favoritedAt?: Date | string | null
    watchedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type WatchLogCreateManyMovieInput = {
    id?: string
    userId: string
    watchedAt: Date | string
    rewatch?: boolean
    tags?: string | null
    note?: string | null
    importId?: string | null
    importRowId?: string | null
    createdAt?: Date | string
  }

  export type MovieListItemCreateManyMovieInput = {
    listId: string
    position?: number | null
    note?: string | null
    addedAt?: Date | string
  }

  export type AwardWinnerUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasonRel?: AwardSeasonUpdateOneRequiredWithoutWinnersNestedInput
  }

  export type AwardWinnerUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AwardWinnerUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    prizeName?: StringFieldUpdateOperationsInput | string
    movieTitle?: StringFieldUpdateOperationsInput | string
    posterPath?: NullableStringFieldUpdateOperationsInput | string | null
    personName?: NullableStringFieldUpdateOperationsInput | string | null
    personPath?: NullableStringFieldUpdateOperationsInput | string | null
    isWinner?: BoolFieldUpdateOperationsInput | boolean
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieInteractionUpdateWithoutMovieInput = {
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type MovieInteractionUncheckedUpdateWithoutMovieInput = {
    userId?: StringFieldUpdateOperationsInput | string
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieInteractionUncheckedUpdateManyWithoutMovieInput = {
    userId?: StringFieldUpdateOperationsInput | string
    watched?: BoolFieldUpdateOperationsInput | boolean
    watchlisted?: BoolFieldUpdateOperationsInput | boolean
    favorited?: BoolFieldUpdateOperationsInput | boolean
    ratingHalf?: NullableIntFieldUpdateOperationsInput | number | null
    ratedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    favoritedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchLogUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWatchLogsNestedInput
    importRun?: ImportRunUpdateOneWithoutWatchLogsNestedInput
    review?: ReviewUpdateOneWithoutWatchLogNestedInput
  }

  export type WatchLogUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUncheckedUpdateOneWithoutWatchLogNestedInput
  }

  export type WatchLogUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    watchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rewatch?: BoolFieldUpdateOperationsInput | boolean
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    importId?: NullableStringFieldUpdateOperationsInput | string | null
    importRowId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieListItemUpdateWithoutMovieInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    list?: MovieListUpdateOneRequiredWithoutItemsNestedInput
  }

  export type MovieListItemUncheckedUpdateWithoutMovieInput = {
    listId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MovieListItemUncheckedUpdateManyWithoutMovieInput = {
    listId?: StringFieldUpdateOperationsInput | string
    position?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}